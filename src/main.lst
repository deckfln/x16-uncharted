ca65 V2.19 - Git e4f01a2
Main file   : main.asm
Current file: main.asm

000000r 1               .org $080D
00080D  1               .segment "STARTUP"
00080D  1               .segment "INIT"
00080D  1               .segment "ONCE"
00080D  1               .segment "CODE"
00080D  1               
00080D  1  4C 3D 14        jmp start
000810  1               
000810  1               .macro LOAD_r0 addr16
000810  1               	lda #<addr16
000810  1               	sta r0L
000810  1               	lda #>addr16
000810  1               	sta r0H
000810  1               .endmacro
000810  1               .macro SAVE_r0 addr16
000810  1               	lda r0L
000810  1               	sta addr16
000810  1               	lda r0H
000810  1               	sta addr16 + 1
000810  1               .endmacro
000810  1               .macro LOAD_r1 addr16
000810  1               	lda #<addr16
000810  1               	sta r1L
000810  1               	lda #>addr16
000810  1               	sta r1H
000810  1               .endmacro
000810  1               .macro LOAD_r3 addr16
000810  1               	lda #<addr16
000810  1               	sta r3L
000810  1               	lda #>addr16
000810  1               	sta r3H
000810  1               .endmacro
000810  1               
000810  1               .include "x16.inc"
000810  2               .ifndef X16_INC
000810  2               X16_INC = 1
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Commodore 64 API
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               ; Channel I/O
000810  2               SETMSG		= $FF90 ; set verbosity
000810  2               READST		= $FFB7 ; return status byte
000810  2               SETLFS		= $FFBA ; set LA, FA and SA
000810  2               SETNAM		= $FFBD ; set filename
000810  2               OPEN		= $FFC0 ; open a channel
000810  2               CLOSE		= $FFC3 ; close a channel
000810  2               CHKIN		= $FFC6 ; set channel for character input
000810  2               CHKOUT		= $FFC9 ; set channel for character output
000810  2               CLRCHN		= $FFCC ; restore character I/O to screen/keyboard
000810  2               BASIN		= $FFCF ; get character
000810  2               BSOUT		= $FFD2 ; write character
000810  2               LOAD		= $FFD5 ; load a file into memory
000810  2               SAVE		= $FFD8 ; save a file from memory
000810  2               CLALL		= $FFE7 ; close all channels
000810  2               
000810  2               ; Commodore Peripheral Bus
000810  2               TALK		= $FFB4 ; send TALK command
000810  2               LISTEN		= $FFB1 ; send LISTEN command
000810  2               UNLSN		= $FFAE ; send UNLISTEN command
000810  2               UNTLK		= $FFAB ; send UNTALK command
000810  2               IECOUT		= $FFA8 ; send byte to serial bus
000810  2               IECIN		= $FFA5 ; read byte from serial bus
000810  2               SETTMO		= $FFA2 ; set timeout
000810  2               TKSA		= $FF96 ; send TALK secondary address
000810  2               SECOND		= $FF93 ; send LISTEN secondary address
000810  2               
000810  2               ; Memory
000810  2               MEMBOT		= $FF9C ; read/write address of start of usable RAM
000810  2               MEMTOP		= $FF99 ; read/write address of end of usable RAM
000810  2               
000810  2               ; Time
000810  2               RDTIM		= $FFDE ; read system clock
000810  2               SETTIM		= $FFDB ; write system clock
000810  2               UDTIM		= $FFEA ; advance clock
000810  2               
000810  2               ; Other:
000810  2               STOP		= $FFE1 ; test for STOP key
000810  2               GETIN		= $FFE4 ; get character from keyboard
000810  2               SCREEN		= $FFED ; get the screen resolution
000810  2               PLOT		= $FFF0 ; read/write cursor position
000810  2               IOBASE		= $FFF3 ; return start of I/O area
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Commodore 128 API
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               CLOSE_ALL		= $FF4A ; close all files on a device
000810  2               LKUPLA		= $FF8D ; search tables for given LA
000810  2               LKUPSA		= $FF8A ; search tables for given SA
000810  2               DLCHR		= $FF62 ; activate a text mode font in the video hardware [not yet implemented]
000810  2               PFKEY		= $FF65 ; program a function key [not yet implemented]
000810  2               FETCH		= $FF74 ; LDA (fetvec),Y from any bank
000810  2               STASH		= $FF77 ; STA (stavec),Y to any bank
000810  2               CMPARE		= $FF7A ; CMP (cmpvec),Y to any bank
000810  2               PRIMM		= $FF7D ; print string following the callerâ€™s code
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Commander X16 API
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               ; Clock
000810  2               clock_set_date_time		= $FF4D ; set date and time
000810  2               clock_get_date_time		= $FF50 ; get date and time
000810  2               
000810  2               ; Mouse
000810  2               mouse_config			= $FF68 ; configure mouse pointer
000810  2               mouse_get				= $FF6B ; get state of mouse
000810  2               
000810  2               ; Joystick
000810  2               joystick_scan			= $FF53 ; query joysticks
000810  2               joystick_get			= $FF56 ; get state of one joystick
000810  2               
000810  2               ; Sprites
000810  2               sprite_set_image		= $FEF0 ; set the image of a sprite
000810  2               sprite_set_position		= $FEF3 ; set the position of a sprite
000810  2               
000810  2               ; Framebuffer
000810  2               FB_init					= $FEF6 ; enable graphics mode
000810  2               FB_get_info				= $FEF9 ; get screen size and color depth
000810  2               FB_set_palette			= $FEFC ; set (parts of) the palette
000810  2               FB_cursor_position		= $FEFF ; position the direct;access cursor
000810  2               FB_cursor_next_line		= $FF02 ; move direct;access cursor to next line
000810  2               FB_get_pixel			= $FF05 ; read one pixel, update cursor
000810  2               FB_get_pixels			= $FF08 ; copy pixels into RAM, update cursor
000810  2               FB_set_pixel			= $FF0B ; set one pixel, update cursor
000810  2               FB_set_pixels			= $FF0E ; copy pixels from RAM, update cursor
000810  2               FB_set_8_pixels			= $FF11 ; set 8 pixels from bit mask (transparent), update cursor
000810  2               FB_set_8_pixels_opaque	= $FF14 ; set 8 pixels from bit mask (opaque), update cursor
000810  2               FB_fill_pixels			= $FF17 ; fill pixels with constant color, update cursor
000810  2               FB_filter_pixels		= $FF1A ; apply transform to pixels, update cursor
000810  2               FB_move_pixels			= $FF1D ; copy horizontally consecutive pixels to a different position
000810  2               
000810  2               ; Graphics
000810  2               GRAPH_init				= $FF20 ; initialize graphics
000810  2               GRAPH_clear				= $FF23 ; clear screen
000810  2               GRAPH_set_window		= $FF26 ; set clipping region
000810  2               GRAPH_set_colors		= $FF29 ; set stroke, fill and background colors
000810  2               GRAPH_draw_line			= $FF2C ; draw a line
000810  2               GRAPH_draw_rect			= $FF2F ; draw a rectangle (optionally filled)
000810  2               GRAPH_move_rect			= $FF32 ; move pixels
000810  2               GRAPH_draw_oval			= $FF35 ; draw an oval or circle
000810  2               GRAPH_draw_image		= $FF38 ; draw a rectangular image
000810  2               GRAPH_set_font			= $FF3B ; set the current font
000810  2               GRAPH_get_char_size		= $FF3E ; get size and baseline of a character
000810  2               GRAPH_put_char			= $FF41 ; print a character
000810  2               
000810  2               ; Console
000810  2               CONSOLE_init					= $FEDB ; initialize console mode
000810  2               CONSOLE_put_char				= $FEDE ; print character to console
000810  2               CONSOLE_put_image				= $FED8 ; draw image as if it was a character
000810  2               CONSOLE_get_char				= $FEE1 ; get character from console
000810  2               CONSOLE_set_paging_message		= $FED5 ; set paging message or disable paging
000810  2               
000810  2               ; Other
000810  2               memory_fill				= $FEE4 ; fill memory region with a byte value
000810  2               memory_copy				= $FEE7 ; copy memory region
000810  2               memory_crc				= $FEEA ; calculate CRC16 of memory region
000810  2               memory_decompress		= $FEED ; decompress LZSA2 block
000810  2               entropy_get				= $FECF ; Get 24 random bits
000810  2               monitor					= $FF44 ; enter machine language monitor
000810  2               restore_basic			= $FF47 ; enter BASIC
000810  2               screen_set_mode			= $FF5F ; set screen mode
000810  2               screen_set_charset		= $FF62 ; activate 8x8 text mode charset
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; VRAM Addresses
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               VRAM_composer		= $F0000
000810  2               VRAM_hscale			= VRAM_composer+1
000810  2               VRAM_vscale			= VRAM_composer+2
000810  2               VRAM_palette		= $F1000
000810  2               VRAM_layer0			= $F2000
000810  2               VRAM_layer1			= $F3000
000810  2               VRAM_sprreg			= $F4000
000810  2               VRAM_sprattr		= $F5000
000810  2               VRAM_audio			= $F6000
000810  2               VRAM_spi			= $F7000
000810  2               VRAM_uart			= $F8000
000810  2               
000810  2               VROM_petscii				= $1F000
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; IRQs
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               IRQVec		= $0314
000810  2               BRKVec		= $0316
000810  2               NMIVec		= $0318
000810  2               
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Virtual registers
000810  2               ; ------------------------------------------------------------
000810  2               r0			= $02
000810  2               r0L			= $02
000810  2               r0H			= $03
000810  2               r1			= $04
000810  2               r1L			= $04
000810  2               r1H			= $05
000810  2               r2			= $06
000810  2               r2L			= $06
000810  2               r2H			= $07
000810  2               r3			= $08
000810  2               r3L			= $08
000810  2               r3H			= $09
000810  2               r4			= $0a
000810  2               r4L			= $0a
000810  2               r4H			= $0b
000810  2               r5			= $0c
000810  2               r5L			= $0c
000810  2               r5H			= $0d
000810  2               r6			= $0e
000810  2               r6L			= $0e
000810  2               r6H			= $0f
000810  2               r7			= $10
000810  2               r7L			= $10
000810  2               r7H			= $11
000810  2               r8			= $12
000810  2               r8L			= $12
000810  2               r8H			= $13
000810  2               r9			= $14
000810  2               r9L			= $14
000810  2               r9H			= $15
000810  2               r10			= $16
000810  2               r10L		= $16
000810  2               r10H		= $17
000810  2               r11			= $18
000810  2               r11L		= $18
000810  2               r11H		= $19
000810  2               r12			= $1a
000810  2               r12L		= $1a
000810  2               r12H		= $1b
000810  2               r13			= $1c
000810  2               r13L		= $1c
000810  2               r13H		= $1d
000810  2               r14			= $1e
000810  2               r14L		= $1e
000810  2               r14H		= $1f
000810  2               r15			= $20
000810  2               r15L		= $20
000810  2               r15H		= $21
000810  2               
000810  2               
000810  2               .endif
000810  2               
000810  1               .include "vera.inc"
000810  2               ; License: Public Domain
000810  2               .ifndef VERA_INC
000810  2               VERA_INC = 1
000810  2               
000810  2               verareg =$9f20
000810  2               
000810  2               veralo  		= verareg+$0
000810  2               veramid 		= verareg+$1
000810  2               verahi  		= verareg+$2
000810  2               veradat 		= verareg+$3
000810  2               veradat2		= verareg+$4
000810  2               veractl 		= verareg+$5
000810  2               veraien 		= verareg+$6
000810  2               veraisr 		= verareg+$7
000810  2               verairqlo 		= verareg+$8
000810  2               
000810  2               ; DCSEl = 0
000810  2               veradcvideo		= verareg+$9
000810  2               
000810  2               VERA_VGA		= %00000001
000810  2               VERA_LAYER0		= %00010000
000810  2               VERA_LAYER1		= %00100000
000810  2               VERA_SPRITE		= %01000000
000810  2               
000810  2               veradchscale	= verareg+$a
000810  2               veradcvscale	= verareg+$b
000810  2               veradcborder	= verareg+$c
000810  2               
000810  2               ; DCSEl = 1
000810  2               veradchstart	= verareg+$9
000810  2               veradchstop		= verareg+$a
000810  2               veradcvstart	= verareg+$b
000810  2               veradcvstop		= verareg+$c
000810  2               
000810  2               ; L0
000810  2               veral0config	= verareg+$d
000810  2               veral0mapbase	= verareg+$e
000810  2               veral0tilebase	= verareg+$f
000810  2               VERA_L0_hscrolllo	= verareg+$10
000810  2               VERA_L0_hscrollhi	= verareg+$11
000810  2               veral0vscrolllo	= verareg+$12
000810  2               veral0vscrollhi	= verareg+$13
000810  2               
000810  2               ; L1
000810  2               veral1config	= verareg+$14
000810  2               veral1mapbase	= verareg+$15
000810  2               veral1tilebase	= verareg+$16
000810  2               VERA_L1_hscrolllo	= verareg+$17
000810  2               VERA_L1_hscrollhi	= verareg+$18
000810  2               VERA_L1_vscrolllo	= verareg+$19
000810  2               VERA_L1_vscrollhi	= verareg+$1a
000810  2               
000810  2               VERA_CONFIG_CLEAR_TILES=%00001111
000810  2               VERA_CONFIG_32x32 = 	%00000000
000810  2               VERA_CONFIG_32x64 = 	%00010000
000810  2               VERA_CONFIG_32x128 = 	%00100000
000810  2               VERA_CONFIG_32x256 = 	%00110000
000810  2               VERA_CONFIG_64x32 = 	%01000000
000810  2               VERA_CONFIG_128x32 = 	%10000000
000810  2               VERA_CONFIG_256x32 = 	%11000000
000810  2               VERA_CONFIG_64x64 = 	%01010000
000810  2               VERA_CONFIG_64x128 = 	%01100000
000810  2               VERA_CONFIG_64x256 = 	%01110000
000810  2               VERA_CONFIG_128x64 = 	%10010000
000810  2               VERA_CONFIG_128x128 = 	%10100000
000810  2               VERA_CONFIG_128x256 = 	%10110000
000810  2               VERA_CONFIG_256x64 = 	%11010000
000810  2               VERA_CONFIG_256x128 = 	%11100000
000810  2               VERA_CONFIG_256x256 = 	%11110000
000810  2               
000810  2               VERA_CONFIG_CLEAR_DEPTH=%00001111
000810  2               VERA_CONFIG_1BPP	=	%00000000
000810  2               VERA_CONFIG_2BPP	=	%00000001
000810  2               VERA_CONFIG_4BPP	=	%00000010
000810  2               VERA_CONFIG_8BPP	=	%00000011
000810  2               
000810  2               VERA_CLEAR_TILE_SIZE= %11111100
000810  2               VERA_TILE_8x8 		= %00000000
000810  2               VERA_TILE_8x16 		= %00000010
000810  2               VERA_TILE_16x8 		= %00000001
000810  2               VERA_TILE_16x16 	= %00000011
000810  2               
000810  2               VERA_TILEBASE_CLEAR_ADR = %00000011
000810  2               
000810  2               ; audio
000810  2               veraaudioctl	= verareg+$1b
000810  2               veraaudiorate	= verareg+$1c
000810  2               veraaudiodata	= verareg+$1d
000810  2               veraspidata		= verareg+$1e
000810  2               veraspictl		= verareg+$1f
000810  2               
000810  2               vram_sprd  = $1fc00
000810  2               
000810  2               AUTO_INC_0 		= $000000
000810  2               AUTO_INC_1 		= $100000
000810  2               AUTO_INC_2 		= $200000
000810  2               AUTO_INC_4 		= $300000
000810  2               AUTO_INC_8 		= $400000
000810  2               AUTO_INC_16		= $500000
000810  2               AUTO_INC_32		= $600000
000810  2               AUTO_INC_64		= $700000
000810  2               AUTO_INC_128	= $800000
000810  2               AUTO_INC_256	= $900000
000810  2               AUTO_INC_512	= $A00000
000810  2               AUTO_INC_40		= $B00000
000810  2               AUTO_INC_80		= $C00000
000810  2               AUTO_INC_160	= $C00000
000810  2               AUTO_INC_320	= $E00000
000810  2               AUTO_INC_640	= $F00000
000810  2               
000810  2               SPRITE_SIZE_8	= $0
000810  2               SPRITE_SIZE_16	= $1
000810  2               SPRITE_SIZE_32	= $2
000810  2               SPRITE_SIZE_64	= $3
000810  2               
000810  2               SPRITE_ZDEPTH_DISABLED = %00000000
000810  2               SPRITE_ZDEPTH_BGto0 = %00000100
000810  2               SPRITE_ZDEPTH_0to1 = %00001000
000810  2               SPRITE_ZDEPTH_TOP = %00001100
000810  2               
000810  2               SPRITE_FLIP_CLEAR = %11111100
000810  2               SPRITE_FLIP_NONE = %00000000
000810  2               SPRITE_FLIP_H = %00000001
000810  2               SPRITE_FLIP_V = %00000010
000810  2               
000810  2               veral0mode = %00010000
000810  2               VERA_VSYNC_BIT         = $01
000810  2               
000810  2               
000810  2               .macro vset addr
000810  2               	lda #0
000810  2               	sta veractl
000810  2               	lda #<(addr >> 16) | $10
000810  2               	sta verahi
000810  2               	lda #<(addr >> 8)
000810  2               	sta veramid
000810  2               	lda #<(addr)
000810  2               	sta veralo
000810  2               .endmacro
000810  2               
000810  2               .macro vset2 addr
000810  2               	lda #1
000810  2               	sta veractl
000810  2               	lda #<(addr >> 16) | $10
000810  2               	sta verahi
000810  2               	lda #<(addr >> 8)
000810  2               	sta veramid
000810  2               	lda #<(addr)
000810  2               	sta veralo
000810  2               .endmacro
000810  2               
000810  2               .macro vstore addr
000810  2               	pha
000810  2               	vset addr
000810  2               	pla
000810  2               	sta veradat
000810  2               .endmacro
000810  2               
000810  2               .macro vstore2 addr
000810  2               	pha
000810  2               	vset addr
000810  2               	pla
000810  2               	sta veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro vload addr
000810  2               	vset addr
000810  2               	lda veradat
000810  2               .endmacro
000810  2               
000810  2               .macro vload2 addr
000810  2               	vset addr
000810  2               	lda veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro sprset offset
000810  2               	lda #<(vram_sprd >> 16) | $10
000810  2               	sta verahi
000810  2               	txa
000810  2               	lsr
000810  2               	lsr
000810  2               	lsr
000810  2               	lsr
000810  2               	lsr
000810  2               	clc
000810  2               	adc #<((vram_sprd + offset) >> 8)
000810  2               	sta veramid
000810  2               	txa
000810  2               	asl
000810  2               	asl
000810  2               	asl
000810  2               	clc
000810  2               	adc #<(vram_sprd + offset)
000810  2               	sta veralo
000810  2               .endmacro
000810  2               
000810  2               .macro sprload offset
000810  2               	sprset offset
000810  2               	lda veradat
000810  2               .endmacro
000810  2               
000810  2               .macro sprload2 offset
000810  2               	sprset offset
000810  2               	lda veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro sprstore offset
000810  2               	pha
000810  2               	sprset offset
000810  2               	pla
000810  2               	sta veradat
000810  2               .endmacro
000810  2               
000810  2               .macro sprstore2 offset
000810  2               	pha
000810  2               	sprset offset
000810  2               	pla
000810  2               	sta veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro video_init
000810  2               	lda #0
000810  2               	sta veractl ; set ADDR1 active
000810  2               	sta veramid
000810  2               	lda #$1F    ; $F0000 increment 1
000810  2               	sta verahi
000810  2               	lda #$00
000810  2               	sta veralo
000810  2               	lda #1
000810  2               	sta veradat ; VGA output
000810  2               .endmacro
000810  2               
000810  2               .endif
000810  2               
000810  1               
000810  1               ; VRAM Addresses
000810  1               VRAM_layer0_map   = $00000
000810  1               VRAM_layer1_map   = $00800
000810  1               VRAM_tiles        = $01000
000810  1               
000810  1               HIMEM = $a000
000810  1               
000810  1               SCREEN_WIDTH = 320
000810  1               SCREEN_HEIGHT = 240
000810  1               LEVEL_TILES_WIDTH = 32
000810  1               LEVEL_WIDTH = LEVEL_TILES_WIDTH*16
000810  1               LEVEL_HEIGHT = 32*16
000810  1               
000810  1               .enum
000810  1               	TILE_NO_COLLISION
000810  1               	TILE_SOLID_GROUND
000810  1               	TILE_SOLD_SLOP_LEFT
000810  1               	TILE_SOLD_SLOP_RIGHT
000810  1               	TILE_SOLID_LADER
000810  1               	TILE_LEDGE
000810  1               .endenum
000810  1               
000810  1               .macro SET_DEBUG
000810  1               	inc trigger_debug
000810  1               .endmacro
000810  1               
000810  1               .macro CHECK_DEBUG
000810  1               	pha
000810  1               	lda trigger_debug
000810  1               	beq @no_debug
000810  1               	dec trigger_debug
000810  1               	stp
000810  1               @no_debug:
000810  1               	pla
000810  1               .endmacro
000810  1               
000810  1               ;---------------------------------
000810  1               ; joystick management
000810  1               ;---------------------------------
000810  1               
000810  1               JOY_RIGHT 	= %00000001
000810  1               JOY_LEFT 	= %00000010
000810  1               JOY_DOWN 	= %00000100
000810  1               JOY_UP 		= %00001000
000810  1               JOY_START	= %00010000
000810  1               JOY_SEL		= %00100000
000810  1               JOY_Y		= %01000000
000810  1               JOY_B		= %10000000
000810  1               
000810  1               .macro VCOPY from, to, blocks
000810  1               	LOAD_r0 from
000810  1               	LOAD_r1 (to & $00ffff)
000810  1               	ldy #(to >> 16)
000810  1               	ldx #(blocks)
000810  1               	jsr Vera::vcopy
000810  1               .endmacro
000810  1               
000810  1               ;-----------------------------------------------------------------------------
000810  1               ;/////////////////////////////////////////////////////////////////////////////
000810  1               ; START Vera code
000810  1               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000810  1               ;-----------------------------------------------------------------------------
000810  1               
000810  1  00 00        current_load: .word 0		; end of the last memory load
000812  1               
000812  1               .macro LOAD_FILE filename, length, ram
000812  1               	lda #1
000812  1               	ldx #8
000812  1               	ldy #0
000812  1               	jsr SETLFS
000812  1               	lda #length
000812  1               	ldx #<filename
000812  1               	ldy #>filename
000812  1               	jsr SETNAM
000812  1               	lda #0
000812  1               	ldx #<ram
000812  1               	ldy #>ram
000812  1               	jsr LOAD
000812  1               	stx current_load
000812  1               	sty current_load + 1
000812  1               .endmacro
000812  1               
000812  1               .macro LOAD_FILE_NEXT filename, length
000812  1               	lda #1
000812  1               	ldx #8
000812  1               	ldy #0
000812  1               	jsr SETLFS
000812  1               	lda #length
000812  1               	ldx #<filename
000812  1               	ldy #>filename
000812  1               	jsr SETNAM
000812  1               	lda #0
000812  1               	ldx current_load
000812  1               	ldy current_load + 1
000812  1               	jsr LOAD
000812  1               	stx current_load
000812  1               	sty current_load + 1
000812  1               .endmacro
000812  1               
000812  1               .scope Vera
000812  1               
000812  1  00 00        vram_load: .word 0		; end of the last memory load
000814  1               
000814  1               .macro VLOAD_FILE filename, length, vram
000814  1               	lda #1
000814  1               	ldx #8
000814  1               	ldy #0
000814  1               	jsr SETLFS
000814  1               	lda #length
000814  1               	ldx #<filename
000814  1               	ldy #>filename
000814  1               	jsr SETNAM
000814  1               	lda #(^vram + 2)
000814  1               	ldx #<vram
000814  1               	ldy #>vram
000814  1               	jsr LOAD
000814  1               	stx Vera::vram_load
000814  1               	sty Vera::vram_load + 1
000814  1               .endmacro
000814  1               
000814  1               .macro VLOAD_FILE_NEXT filename, length
000814  1               	lda #1
000814  1               	ldx #8
000814  1               	ldy #0
000814  1               	jsr SETLFS
000814  1               	lda #length
000814  1               	ldx #<filename
000814  1               	ldy #>filename
000814  1               	jsr SETNAM
000814  1               	lda #(^Vera::vram_load + 2)
000814  1               	ldx Vera::vram_load
000814  1               	ldy Vera::vram_load + 1
000814  1               	jsr LOAD
000814  1               	stx Vera::vram_load
000814  1               	sty Vera::vram_load + 1
000814  1               .endmacro
000814  1               
000814  1               ;
000814  1               ; copy from rom to vram
000814  1               ;	r0 : from
000814  1               ;	r1 : to (first 16 bites)
000814  1               ;   	y : vera bank (0, 1)
000814  1               ;	X: blocks
000814  1               ;
000814  1               vcopy:
000814  1  A9 00        	lda #0
000816  1  8D 25 9F     	sta veractl
000819  1  98           	tya
00081A  1  09 10        	ora #$10
00081C  1  8D 22 9F     	sta verahi
00081F  1  A5 05        	lda r1H
000821  1  8D 21 9F     	sta veramid
000824  1  A5 04        	lda r1L
000826  1  8D 20 9F     	sta veralo
000829  1               
000829  1               @loop:
000829  1  A0 00            ldy #0
00082B  1               @loop1tile:
00082B  1  B1 02        	lda (r0),y                         	; read from tiles data
00082D  1  8D 23 9F         sta veradat                      	; Write to VRAM with +1 Autoincrement
000830  1  C8               iny
000831  1  D0 F8            bne @loop1tile
000833  1               
000833  1  E6 03        	inc r0H
000835  1  CA           	dex
000836  1  D0 F1        	bne @loop
000838  1  60           	rts
000839  1               .endscope
000839  1               
000839  1               
000839  1               .include "sprites.asm"
000839  2               ;-----------------------------------------------------------------------------
000839  2               ;/////////////////////////////////////////////////////////////////////////////
000839  2               ; START Sprite code
000839  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000839  2               ;-----------------------------------------------------------------------------
000839  2               
000839  2               .struct VSPRITE
000839  2               	address125 .byte
000839  2               	mode_xxx_address1613 .byte
000839  2               	x70 .byte
000839  2               	x98 .byte
000839  2               	y70 .byte
000839  2               	y98 .byte
000839  2               	collision_zdepth_vflip_hflip .byte
000839  2               	height_width_offset .byte
000839  2               .endstruct
000839  2               
000839  2               .scope Sprite
000839  2               
000839  2  xx xx xx xx  sprites: .res 256
00083D  2  xx xx xx xx  
000841  2  xx xx xx xx  
000939  2               
000939  2               ;
000939  2               ; create a table with the VERA @addr for each sprite
000939  2               ;
000939  2               init_addr_table:
000939  2               	; all sprites are availble but ZERO (reserved player)
000939  2  A2 FF        	ldx #$ff
00093B  2               :
00093B  2  9E 39 08     	stz sprites,X
00093E  2  CA           	dex
00093F  2  D0 FA        	bne :-
000941  2  A9 01        	lda #01
000943  2  8D 39 08     	sta sprites
000946  2               
000946  2               	; start of the sprites in VERA memory
000946  2  A9 00        	lda #<vram_sprd
000948  2  85 02        	sta r0L
00094A  2  A9 FC        	lda #>vram_sprd
00094C  2  85 03        	sta r0H
00094E  2               
00094E  2  A2 80        	ldx #128
000950  2  A0 00        	ldy #0
000952  2                @loop:
000952  2  A5 03        	lda r0H
000954  2  99 18 16     	sta sprites_table,y
000957  2  C8           	iny
000958  2  A5 02        	lda r0L
00095A  2  99 18 16     	sta sprites_table,y
00095D  2  C8           	iny
00095E  2               
00095E  2  18           	clc
00095F  2  A5 02        	lda r0L
000961  2  69 08        	adc #8
000963  2  85 02        	sta r0L
000965  2  A5 03        	lda r0H
000967  2  69 00        	adc #0
000969  2  85 03        	sta r0H	; move to next sprite
00096B  2               
00096B  2  CA           	dex
00096C  2  D0 E4        	bne @loop
00096E  2               
00096E  2  60           	rts
00096F  2               
00096F  2               ;************************************************
00096F  2               ; get a new available vera sprite
00096F  2               ;	output: X = index of the vera sprite
00096F  2               ;			0 = no sprite available
00096F  2               ;
00096F  2               new:
00096F  2  A2 01        	ldx #$01
000971  2               :
000971  2  BD 39 08     	lda sprites,x
000974  2  F0 03        	beq @return
000976  2  E8           	inx
000977  2  D0 F8        	bne :-
000979  2               @return:
000979  2  A9 01        	lda #01
00097B  2  9D 39 08     	sta sprites,x
00097E  2  60           	rts
00097F  2               
00097F  2               ;
00097F  2               ; the the VERA memory pointer to sprite Y + attribute X
00097F  2               ;	Y = sprite index
00097F  2               ;	X = attribute offset
00097F  2               ;
00097F  2               vram:
00097F  2  DA           	phx			; save X on the stack
000980  2               
000980  2  98           	tya			; index of the sprite
000981  2  0A           	asl
000982  2  A8           	tay			; index of the address of the sprite (y*2)
000983  2               
000983  2  A9 00        	lda #0
000985  2  8D 25 9F     	sta veractl
000988  2  A9 11        	lda #<(vram_sprd >> 16) | $10
00098A  2  8D 22 9F     	sta verahi
00098D  2  B9 18 16     	lda sprites_table, y
000990  2  8D 21 9F     	sta veramid
000993  2  C8           	iny
000994  2  BA           	tsx
000995  2  BD 01 01     	lda $0101,x	; reload X from the stack
000998  2  79 18 16     	adc sprites_table, y
00099B  2  8D 20 9F     	sta veralo	; vera = $1fc00 + sprite index (X) * 8
00099E  2  FA           	plx
00099F  2  60           	rts
0009A0  2               
0009A0  2               ;************************************************
0009A0  2               ; configure the sprite
0009A0  2               ;	input: Y = sprite index
0009A0  2               ;		   X = sprite size :
0009A0  2               ;			r0 = vram @ of the sprite data
0009A0  2               ;
0009A0  2               load:
0009A0  2  86 30        	stx $30
0009A2  2  20 D8 09     	jsr set_bitmap
0009A5  2               
0009A5  2  9C 23 9F     	stz veradat					; x = 0
0009A8  2  9C 23 9F     	stz veradat
0009AB  2  9C 23 9F     	stz veradat					; y = 0
0009AE  2  9C 23 9F     	stz veradat
0009B1  2  A9 00        	lda #%00000000				; collision mask + sprite = disabled + vflip=none + hflip=none
0009B3  2  8D 23 9F     	sta veradat
0009B6  2  A5 30        	lda $30						; 32x32 sprite
0009B8  2  8D 23 9F     	sta veradat
0009BB  2  60           	rts
0009BC  2               
0009BC  2               ;************************************************
0009BC  2               ; configure full veram memory (16:0) into optimized one (12:5)
0009BC  2               ;	input: r0 = vram @ of the sprite data
0009BC  2               ;	output: r1
0009BC  2               ;
0009BC  2               vram_to_16_5:
0009BC  2               	; load full VERA memory (12:0) into R0
0009BC  2  A5 02        	lda r0L
0009BE  2  85 04        	sta r1L
0009C0  2  A5 03        	lda r0H
0009C2  2  85 05        	sta r1H
0009C4  2               
0009C4  2               	; convert full addr to vera mode (bit shiting >> 5)
0009C4  2  A5 05        	lda r1H
0009C6  2  4A           	lsr
0009C7  2  66 04        	ror r1L
0009C9  2  4A           	lsr
0009CA  2  66 04        	ror r1L
0009CC  2  4A           	lsr
0009CD  2  66 04        	ror r1L
0009CF  2  4A           	lsr
0009D0  2  66 04        	ror r1L						; bit shift 4x 16 bits vera memory
0009D2  2  4A           	lsr
0009D3  2  66 04        	ror r1L						; bit shift 4x 16 bits vera memory
0009D5  2  85 05        	sta r1H
0009D7  2  60           	rts
0009D8  2               
0009D8  2               ;
0009D8  2               ; change the address of the bitmap for the sprite
0009D8  2               ;	Y = sprite index
0009D8  2               ;	r0 = vera memory (12:5)
0009D8  2               ;
0009D8  2               set_bitmap:
0009D8  2  A2 00        	ldx #VSPRITE::address125
0009DA  2  20 7F 09     	jsr vram			; set very pointer to the address of the bitmap
0009DD  2               
0009DD  2  A5 02        	lda r0L
0009DF  2  8D 23 9F     	sta veradat
0009E2  2  A5 03        	lda r0H
0009E4  2  09 80        	ora #$80						; M = 8 bits
0009E6  2  8D 23 9F     	sta veradat
0009E9  2               
0009E9  2  60           	rts
0009EA  2               ;
0009EA  2               ; change the display byte for a sprite
0009EA  2               ;	Y = sprite index
0009EA  2               ;	X = display value to set
0009EA  2               ;
0009EA  2               display:
0009EA  2  86 02        	stx r0L		; save X for later
0009EC  2               
0009EC  2               	; set vram memory on the X sprite
0009EC  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
0009EE  2  20 7F 09     	jsr vram
0009F1  2               
0009F1  2  A5 02        	lda r0L
0009F3  2  8D 23 9F     	sta veradat
0009F6  2  60           	rts
0009F7  2               
0009F7  2               ;
0009F7  2               ; define position of sprite
0009F7  2               ;	Y = sprite index
0009F7  2               ;	r0 = addr of word X & word Y
0009F7  2               ;
0009F7  2               position:
0009F7  2               	; set vram memory on the X sprite
0009F7  2  A2 02        	ldx #VSPRITE::x70
0009F9  2  20 7F 09     	jsr vram
0009FC  2               
0009FC  2  A0 01        	ldy #1
0009FE  2  B2 02        	lda (r0L)
000A00  2  8D 23 9F     	sta veradat
000A03  2  B1 02        	lda (r0L),y
000A05  2  8D 23 9F     	sta veradat
000A08  2  C8           	iny
000A09  2  B1 02        	lda (r0L),y
000A0B  2  8D 23 9F     	sta veradat
000A0E  2  C8           	iny
000A0F  2  B1 02        	lda (r0L),y
000A11  2  8D 23 9F     	sta veradat
000A14  2  60           	rts
000A15  2               
000A15  2               ;
000A15  2               ; Change the flipping of a sprite
000A15  2               ;	Y = sprite index
000A15  2               ;	A = value to set
000A15  2               ;
000A15  2               set_flip:
000A15  2  85 30        	sta $30
000A17  2  84 31        	sty $31
000A19  2               
000A19  2               	; set vram memory on the X sprite
000A19  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000A1B  2  20 7F 09     	jsr vram
000A1E  2               
000A1E  2  AD 23 9F     	lda veradat				;get current value
000A21  2  29 FC        	and #SPRITE_FLIP_CLEAR
000A23  2  05 30        	ora $30					; change only the flip value
000A25  2  85 30        	sta $30
000A27  2               
000A27  2  A4 31        	ldy $31
000A29  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000A2B  2  20 7F 09     	jsr vram
000A2E  2  A5 30        	lda $30
000A30  2  8D 23 9F     	sta veradat
000A33  2  60           	rts
000A34  2               .endscope
000A34  2               
000A34  1               .include "objects.asm"
000A34  2               ;-----------------------------------------------------------------------------
000A34  2               ;/////////////////////////////////////////////////////////////////////////////
000A34  2               ;           start OBJECT code
000A34  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000A34  2               ;-----------------------------------------------------------------------------
000A34  2               
000A34  2               .scope Objects
000A34  2               
000A34  2  00 00        objects_map: .word 0
000A36  2  00 00        objects_sprites: .word 0    ; vera memory of the start of the sprites
000A38  2               
000A38  2               .struct Object
000A38  2                   spriteID    .byte   ; ID of the vera sprite
000A38  2                   imageID     .byte   ; ID of the image in the spritesheet
000A38  2                   levelx      .word   ; level position
000A38  2                   levely      .word
000A38  2                   px          .word   ; screen position
000A38  2                   py          .word
000A38  2               .endstruct
000A38  2               
000A38  2               ;************************************************
000A38  2               ; init the object data of the level
000A38  2               ;
000A38  2               init:
000A38  2                   ; load the list of objects at the end of the previous load
000A38  2  AD 10 08         lda current_load
000A3B  2  8D 34 0A         sta objects_map
000A3E  2  AD 11 08         lda current_load + 1
000A41  2  8D 35 0A         sta objects_map + 1
000A44  2  A9 01 A2 08  	LOAD_FILE_NEXT fsobjects, (fsobjects_end-fsobjects)
000A48  2  A0 00 20 BA  
000A4C  2  FF A9 0B A2  
000A67  2               
000A67  2                   ; load the sprites  of objects at the end of the previous vload
000A67  2  AD 12 08         lda Vera::vram_load
000A6A  2  8D 36 0A         sta objects_sprites
000A6D  2  AD 13 08         lda Vera::vram_load + 1
000A70  2  8D 37 0A         sta objects_sprites + 1
000A73  2  A9 01 A2 08  	VLOAD_FILE_NEXT fssprites1, (fssprites1_end-fssprites1)
000A77  2  A0 00 20 BA  
000A7B  2  FF A9 0C A2  
000A96  2               
000A96  2                   ; add each available sprites on screen
000A96  2  AD 34 0A         lda objects_map
000A99  2  85 08            sta r3L
000A9B  2  AD 35 0A         lda objects_map + 1
000A9E  2  85 09            sta r3H
000AA0  2               
000AA0  2  B2 08            lda (r3)
000AA2  2  85 31            sta $31     ; number of objects
000AA4  2  64 32            stz $32     ; object #0
000AA6  2               
000AA6  2  E6 08            inc r3L
000AA8  2               
000AA8  2               @loop:
000AA8  2                   ; get a free sprite
000AA8  2  20 6F 09         jsr Sprite::new
000AAB  2  8A               txa
000AAC  2  92 08            sta (r3)
000AAE  2               
000AAE  2                   ; load the first object
000AAE  2  AD 36 0A     	lda objects_sprites
000AB1  2  85 02        	sta r0L
000AB3  2  AD 37 0A     	lda objects_sprites + 1
000AB6  2  85 03        	sta r0H
000AB8  2  20 BC 09         jsr Sprite::vram_to_16_5
000ABB  2  A5 04            lda r1L
000ABD  2  85 02            sta r0L
000ABF  2  A5 05            lda r1H
000AC1  2  85 03            sta r0H
000AC3  2               
000AC3  2  B2 08        	lda (r3)                        ; sprite id
000AC5  2  A8               tay
000AC6  2  A2 50           	ldx #%01010000					; 16x16 sprite
000AC8  2  20 A0 09     	jsr Sprite::load
000ACB  2               
000ACB  2                   ; display the object
000ACB  2  B2 08        	lda (r3)                        ; sprite id
000ACD  2  A8               tay
000ACE  2  A2 0C        	ldx #SPRITE_ZDEPTH_TOP
000AD0  2  20 EA 09     	jsr Sprite::display
000AD3  2               
000AD3  2                   ; position the first object
000AD3  2  20 0C 0B         jsr set_position_r3
000AD6  2               
000AD6  2                   ; last object ?
000AD6  2  C6 31            dec $31
000AD8  2  F0 11            beq @return
000ADA  2               
000ADA  2                   ; move to the next object
000ADA  2  18               clc
000ADB  2  A5 08            lda r3L
000ADD  2  69 0A            adc #.sizeof(Object)
000ADF  2  85 08            sta r3L
000AE1  2  A5 09            lda r3H
000AE3  2  69 00            adc #00
000AE5  2  85 09            sta r3H
000AE7  2               
000AE7  2  E6 32            inc $32                     ; object #next
000AE9  2  80 BD            bra @loop
000AEB  2               
000AEB  2               @return:
000AEB  2  60               rts
000AEC  2               
000AEC  2               ;************************************************
000AEC  2               ; change  position of the sprite (level view) => (screen view)
000AEC  2               ;   input: X = index of the object
000AEC  2               ;
000AEC  2               set_position_index:
000AEC  2  AD 34 0A         lda objects_map
000AEF  2  85 08            sta r3L
000AF1  2  AD 35 0A         lda objects_map + 1
000AF4  2  85 09            sta r3H
000AF6  2  E6 08            inc r3L
000AF8  2               
000AF8  2  E0 00            cpx #00                 ; ignore object 0
000AFA  2  F0 10            beq @next
000AFC  2               
000AFC  2               @mult:
000AFC  2  18               clc
000AFD  2  A5 08            lda r3L
000AFF  2  69 0A            adc #.sizeof(Object)
000B01  2  85 08            sta r3L
000B03  2  A5 09            lda r3H
000B05  2  69 00            adc #00
000B07  2  85 09            sta r3H
000B09  2  CA               dex
000B0A  2  D0 F0            bne @mult               ; r2 = objects_map + X*sizeof(Object)
000B0C  2               
000B0C  2               @next:
000B0C  2               
000B0C  2               ;************************************************
000B0C  2               ; change  position of the sprite (level view) => (screen view)
000B0C  2               ;   input: R3 = start of the object
000B0C  2               ;
000B0C  2               set_position_r3:
000B0C  2                   ; screenX = levelX - layer1_scroll_x
000B0C  2  A0 02            ldy #Object::levelx
000B0E  2  38               sec
000B0F  2  B1 08            lda (r3), y
000B11  2  ED 37 9F         sbc VERA_L1_hscrolllo
000B14  2  85 02            sta r0L
000B16  2  C8               iny
000B17  2  B1 08            lda (r3), y
000B19  2  ED 38 9F         sbc VERA_L1_hscrolllo + 1
000B1C  2  85 03            sta r0H
000B1E  2               
000B1E  2                   ; screenY = levelY - layer1_scroll_y
000B1E  2  A0 04            ldy #Object::levely
000B20  2  38               sec
000B21  2  B1 08            lda (r3), y
000B23  2  ED 39 9F         sbc VERA_L1_vscrolllo
000B26  2  85 04            sta r1L
000B28  2  C8               iny
000B29  2  B1 08            lda (r3), y
000B2B  2  ED 3A 9F         sbc VERA_L1_vscrolllo + 1
000B2E  2  85 05            sta r1H
000B30  2               
000B30  2                   ; save the screen positions in the object
000B30  2  A0 06            ldy #Object::px
000B32  2  A5 02            lda r0L
000B34  2  91 08            sta (r3), Y
000B36  2  C8               iny
000B37  2  A5 03            lda r0H
000B39  2  91 08            sta (r3), Y
000B3B  2               
000B3B  2  A0 08            ldy #Object::py
000B3D  2  A5 04            lda r1L
000B3F  2  91 08            sta (r3), Y
000B41  2  C8               iny
000B42  2  A5 05            lda r1H
000B44  2  91 08            sta (r3), Y
000B46  2               
000B46  2                   ; set the player position
000B46  2  B2 08        	lda (r3)                        ; sprite id
000B48  2  A8               tay
000B49  2               
000B49  2                   ; adresse of thepx, py attributes
000B49  2  18               clc
000B4A  2  A5 08            lda r3L
000B4C  2  69 06            adc #Object::px
000B4E  2  85 02            sta r0L
000B50  2  A5 09            lda r3H
000B52  2  69 00            adc #00
000B54  2  85 03            sta r0H
000B56  2  20 F7 09     	jsr Sprite::position			; set position of the sprite
000B59  2               
000B59  2  60               rts
000B5A  2               
000B5A  2               ;************************************************
000B5A  2               ; change position of all sprites when the layer moves (level view) => (screen view)
000B5A  2               ;
000B5A  2               fix_positions:
000B5A  2  AD 34 0A         lda objects_map
000B5D  2  85 08            sta r3L
000B5F  2  AD 35 0A         lda objects_map + 1
000B62  2  85 09            sta r3H
000B64  2               
000B64  2  B2 08            lda (r3)
000B66  2  85 31            sta $31     ; number of objects
000B68  2  64 32            stz $32
000B6A  2  E6 08            inc r3L
000B6C  2               
000B6C  2               @loop:
000B6C  2                   ; position the first object
000B6C  2  20 0C 0B         jsr set_position_r3
000B6F  2               
000B6F  2                   ; last object ?
000B6F  2  E6 32            inc $32
000B71  2  C6 31            dec $31
000B73  2  F0 0F            beq @return
000B75  2               
000B75  2                   ; move to the next object
000B75  2  18               clc
000B76  2  A5 08            lda r3L
000B78  2  69 0A            adc #.sizeof(Object)
000B7A  2  85 08            sta r3L
000B7C  2  A5 09            lda r3H
000B7E  2  69 00            adc #00
000B80  2  85 09            sta r3H
000B82  2               
000B82  2  80 E8            bra @loop
000B84  2               
000B84  2               @return:
000B84  2  60               rts
000B85  2               
000B85  2               .endscope
000B85  2               
000B85  1               .include "layers.asm"
000B85  2               ;-----------------------------------------------------------------------------
000B85  2               ;/////////////////////////////////////////////////////////////////////////////
000B85  2               ; START Layers code
000B85  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000B85  2               ;-----------------------------------------------------------------------------
000B85  2               
000B85  2               .scope Layers
000B85  2               
000B85  2               HSCROLL = 0
000B85  2               VSCROLL = 2
000B85  2               
000B85  2               ; define size of tiles for layer
000B85  2               .macro VTILEMODE layer, mode
000B85  2               	lda veral0tilebase + layer * 7
000B85  2               	and #VERA_CLEAR_TILE_SIZE
000B85  2               	ora #mode
000B85  2               	sta veral0tilebase + layer * 7
000B85  2               .endmacro
000B85  2               
000B85  2               ; define number of tiles in the map
000B85  2               .macro VCONFIG_TILES layer,mode
000B85  2               	lda veral0config + layer * 7
000B85  2               	and #VERA_CONFIG_CLEAR_TILES
000B85  2               	ora #mode
000B85  2               	sta veral0config + layer * 7
000B85  2               .endmacro
000B85  2               
000B85  2               ; define number of colors for the map
000B85  2               .macro VCONFIG_DEPTH layer,mode
000B85  2               	lda veral0config + layer * 7
000B85  2               	and #VERA_CONFIG_CLEAR_DEPTH
000B85  2               	ora #mode
000B85  2               	sta veral0config + layer * 7
000B85  2               .endmacro
000B85  2               
000B85  2               ; set the tilebase for the layer
000B85  2               .macro VTILEBASE layer,addr
000B85  2                   lda veral0tilebase + layer * 7                  ; set memory for tilebase
000B85  2               	and #VERA_TILEBASE_CLEAR_ADR
000B85  2               	ora #(addr >> 9)
000B85  2               	sta veral0tilebase + layer * 7
000B85  2               .endmacro
000B85  2               
000B85  2               ; set the mapbase for the layer
000B85  2               .macro VMAPBASE layer,addr
000B85  2                   lda #(addr >> 9)         ; store 2 last bits
000B85  2                   sta veral0mapbase + layer * 7                   ; Store to Map Base Pointer
000B85  2               .endmacro
000B85  2               
000B85  2               ;************************************************
000B85  2               ; increase layer scrolling with a 8bits limit
000B85  2               ;	X: : 0 = horizontal
000B85  2               ;	   : 2 = vertical
000B85  2               ;	Y: limit
000B85  2               ;
000B85  2               scroll_inc_8:
000B85  2  84 02        	sty r0L
000B87  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
000B8A  2  C5 02        	cmp r0L
000B8C  2  F0 0F        	beq @noscroll
000B8E  2               @scrollinc:
000B8E  2  1A           	inc
000B8F  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
000B92  2  D0 03        	bne @scrolled
000B94  2  FE 38 9F     	inc VERA_L1_hscrollhi, x
000B97  2               @scrolled:
000B97  2               	; fix the objects position now that the layers scrolled
000B97  2  20 5A 0B     	jsr Objects::fix_positions
000B9A  2  A9 01        	lda #01		; clear ZERO => scrolled
000B9C  2  60           	rts
000B9D  2               @noscroll:
000B9D  2  A9 00        	lda #00		; set ZERO => noscroll
000B9F  2  60           	rts
000BA0  2               
000BA0  2               ;************************************************
000BA0  2               ; increase layer scrolling with a 16bits limit
000BA0  2               ;	X: : 0 = horizontal
000BA0  2               ;	   : 2 = vertical
000BA0  2               ;	r0L: limit
000BA0  2               ;
000BA0  2               scroll_inc_16:
000BA0  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
000BA3  2  C5 02        	cmp r0L
000BA5  2  D0 09        	bne @scrollinc								; if low bits are not equals to the limit low bits => safe to increase
000BA7  2  A8           	tay
000BA8  2  BD 38 9F     	lda VERA_L1_hscrollhi, x
000BAB  2  C5 03        	cmp r0H
000BAD  2  F0 10        	beq @noscroll								; if high bits are equals to the limit high bits => we reached the limit
000BAF  2  98           	tya
000BB0  2               @scrollinc:
000BB0  2  1A           	inc
000BB1  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
000BB4  2  D0 03        	bne @scrolled
000BB6  2  FE 38 9F     	inc VERA_L1_hscrollhi, x
000BB9  2               @scrolled:
000BB9  2               	; fix the objects position now that the layers scrolled
000BB9  2  20 5A 0B     	jsr Objects::fix_positions
000BBC  2  A9 01        	lda #01	; clear ZERO => scrolled
000BBE  2  60           	rts
000BBF  2               @noscroll:
000BBF  2  A9 00        	lda #00	; set ZERO => noscroll
000BC1  2  60           	rts
000BC2  2               
000BC2  2               ; increase a layer scroll offset but do NOT overlap
000BC2  2               .macro VSCROLL_INC direction,limit
000BC2  2               .if limit > 255
000BC2  2               	LOAD_r0 limit
000BC2  2               	ldx #direction
000BC2  2               	jsr Layers::scroll_inc_16
000BC2  2               .else
000BC2  2               	ldy #limit
000BC2  2               	ldx #direction
000BC2  2               	jsr Layers::scroll_inc_8
000BC2  2               .endif
000BC2  2               .endmacro
000BC2  2               
000BC2  2               ;
000BC2  2               ;
000BC2  2               ; decrease a layer scroll offset
000BC2  2               ;	X : 0 = horizontal
000BC2  2               ;	  : 2 = vertical
000BC2  2               ;
000BC2  2               scroll_dec:
000BC2  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
000BC5  2  F0 06        	beq @scrollHI			; 00 => decrease high bits
000BC7  2  3A           	dec
000BC8  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
000BCB  2  80 0E        	bra @scrolled
000BCD  2               @scrollHI:
000BCD  2  BC 38 9F     	ldy VERA_L1_hscrollhi, x
000BD0  2  F0 0F        	beq @noscroll		; 0000 => no scrolling
000BD2  2  3A           	dec
000BD3  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
000BD6  2  88           	dey
000BD7  2  98           	tya
000BD8  2  9D 38 9F     	sta VERA_L1_hscrollhi, x
000BDB  2               
000BDB  2               @scrolled:
000BDB  2               	; fix the objects position now that the layers scrolled
000BDB  2  20 5A 0B     	jsr Objects::fix_positions
000BDE  2  A9 01        	lda #01		; clear ZERO => scrolled
000BE0  2  60           	rts
000BE1  2               
000BE1  2               @noscroll:
000BE1  2  A9 00        	lda #00		; set ZERO => noscroll
000BE3  2  60           	rts
000BE4  2               
000BE4  2               ;
000BE4  2               ; force layer0 scrolling to be half of the layer1 scrolling
000BE4  2               ;
000BE4  2               scroll_l0:
000BE4  2  BD 38 9F     	lda VERA_L1_hscrollhi, x	; layer0 hScroll is layer 1 / 2
000BE7  2  4A           	lsr
000BE8  2  9D 31 9F     	sta VERA_L0_hscrollhi, x
000BEB  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
000BEE  2  6A           	ror
000BEF  2  9D 30 9F     	sta VERA_L0_hscrolllo, x
000BF2  2  60           	rts
000BF3  2               .endscope
000BF3  2               
000BF3  1               .include "player.asm"
000BF3  2               ;-----------------------------------------------------------------------------
000BF3  2               ;/////////////////////////////////////////////////////////////////////////////
000BF3  2               ; START player code
000BF3  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000BF3  2               ;-----------------------------------------------------------------------------
000BF3  2               
000BF3  2               PLAYER_SPRITE_ANIMATION = 3
000BF3  2               
000BF3  2               JUMP_LO_TICKS = 10
000BF3  2               JUMP_HI_TICKS = 2
000BF3  2               FALL_LO_TICKS = 8
000BF3  2               FALL_HI_TICKS = 2
000BF3  2               
000BF3  2               .enum
000BF3  2               	STATUS_WALKING_IDLE
000BF3  2               	STATUS_WALKING
000BF3  2               	STATUS_CLIMBING
000BF3  2               	STATUS_CLIMBING_IDLE
000BF3  2               	STATUS_FALLING
000BF3  2               	STATUS_JUMPING
000BF3  2               	STATUS_JUMPING_IDLE
000BF3  2               .endenum
000BF3  2               
000BF3  2               .enum
000BF3  2               	SITTING_NO_SLOP
000BF3  2               	SITTING_ON_SLOPE
000BF3  2               	SITTING_ABOVE_SLOPE
000BF3  2               .endenum
000BF3  2               
000BF3  2               .enum TILE_ATTR
000BF3  2               	SOLID_GROUND = 1
000BF3  2               	SOLID_WALL = 2
000BF3  2               	SOLID_CEILING = 4
000BF3  2               	GRABBING = 8			; player can grab the tile (ladder, ledge, rope)
000BF3  2               .endenum
000BF3  2               
000BF3  2               .struct PLAYER
000BF3  2               	sprite			.byte	; sprite index
000BF3  2               	status			.byte	; status of the player : IDLE, WALKING, CLIMBING, FALLING
000BF3  2               	falling_ticks	.word	; ticks since the player is fllaing (thing t in gravity)
000BF3  2               	delta_x			.byte	; when driving by phisics, original delta_x value
000BF3  2               	animation_tick	.byte
000BF3  2               	spriteID 		.byte	; current animation loop start
000BF3  2               	spriteAnim 		.byte	; current frame
000BF3  2               	spriteAnimDirection .byte ; direction of the animation
000BF3  2               	px 				.word	; relative X & Y on screen
000BF3  2               	py 				.word
000BF3  2               	levelx			.word	; absolute X & Y in the level
000BF3  2               	levely			.word
000BF3  2               	flip 			.byte
000BF3  2               	tilemap			.word	; cached @ of the tilemap equivalent of the center of the player
000BF3  2               	vera_bitmaps    .res 	2*12	; 9 words to store vera bitmaps address
000BF3  2               .endstruct
000BF3  2               
000BF3  2               .macro m_status value
000BF3  2               	lda #(value)
000BF3  2               	sta player0 + PLAYER::status
000BF3  2               .endmacro
000BF3  2               
000BF3  2               .scope Player
000BF3  2               
000BF3  2               .macro SET_SPRITE id, frame
000BF3  2               	lda #id
000BF3  2               	sta player0 + PLAYER::spriteID
000BF3  2               	lda #frame
000BF3  2               	sta player0 + PLAYER::spriteAnim
000BF3  2               	jsr set_bitmap
000BF3  2               .endmacro
000BF3  2               
000BF3  2               ;************************************************
000BF3  2               ; player sprites status
000BF3  2               ;
000BF3  2               .enum Sprites
000BF3  2               	FRONT = 0
000BF3  2               	LEFT = 3
000BF3  2               	CLIMB = 6
000BF3  2               	HANG = 9
000BF3  2               .endenum
000BF3  2               
000BF3  2               ;************************************************
000BF3  2               ; local variables
000BF3  2               ;
000BF3  2               
000BF3  2  00           player_on_slop: .byte 0
000BF4  2  00           ladders: .byte 0
000BF5  2  00           test_right_left: .byte 0
000BF6  2               
000BF6  2               ;************************************************
000BF6  2               ; init the player data
000BF6  2               ;
000BF6  2               init:
000BF6  2  9C 18 17     	stz player0 + PLAYER::sprite
000BF9  2  A9 0A        	lda #10
000BFB  2  8D 1D 17     	sta player0 + PLAYER::animation_tick
000BFE  2  A9 00        	lda #STATUS_WALKING_IDLE
000C00  2  8D 19 17     	sta player0 + PLAYER::status
000C03  2  9C 1A 17     	stz player0 + PLAYER::falling_ticks
000C06  2  9C 1B 17     	stz player0 + PLAYER::falling_ticks + 1
000C09  2  A9 03        	lda #Player::Sprites::LEFT
000C0B  2  8D 1E 17     	sta player0 + PLAYER::spriteID
000C0E  2  9C 1F 17     	stz player0 + PLAYER::spriteAnim
000C11  2  A9 01        	lda #1
000C13  2  8D 20 17     	sta player0 + PLAYER::spriteAnimDirection
000C16  2  9C 21 17     	stz player0 + PLAYER::px
000C19  2  9C 22 17     	stz player0 + PLAYER::px+1
000C1C  2  9C 23 17     	stz player0 + PLAYER::py
000C1F  2  9C 24 17     	stz player0 + PLAYER::py+1
000C22  2  9C 25 17     	stz player0 + PLAYER::levelx
000C25  2  9C 26 17     	stz player0 + PLAYER::levelx+1
000C28  2  9C 27 17     	stz player0 + PLAYER::levely
000C2B  2  9C 28 17     	stz player0 + PLAYER::levely+1
000C2E  2  9C 29 17     	stz player0 + PLAYER::flip
000C31  2               
000C31  2               	; load sprites data at the end of the tiles
000C31  2  A9 01 A2 08  	VLOAD_FILE fssprite, (fsspriteend-fssprite), (VRAM_tiles + tiles * tile_size)
000C35  2  A0 00 20 BA  
000C39  2  FF A9 0B A2  
000C52  2               
000C52  2  AD 2C 17     	lda player0 + PLAYER::vera_bitmaps
000C55  2  85 02        	sta r0L
000C57  2  AD 2D 17     	lda player0 + PLAYER::vera_bitmaps+1
000C5A  2  85 03        	sta r0H
000C5C  2               
000C5C  2  AC 18 17     	ldy player0 + PLAYER::sprite
000C5F  2  A2 A0        	ldx #%10100000					; 32x32 sprite
000C61  2  20 A0 09     	jsr Sprite::load
000C64  2               
000C64  2               	; turn sprite 0 on
000C64  2  AC 18 17     	ldy player0 + PLAYER::sprite
000C67  2  A2 0C        	ldx #SPRITE_ZDEPTH_TOP
000C69  2  20 EA 09     	jsr Sprite::display
000C6C  2               
000C6C  2               	; register the vera simplified memory 12:5
000C6C  2  A2 00        	ldx #0
000C6E  2  A0 0C        	ldy #(3*4)
000C70  2  A9 00 85 04  	LOAD_r1 (VRAM_tiles + tiles * tile_size)
000C74  2  A9 3B 85 05  
000C78  2               
000C78  2               @loop:
000C78  2               	; load full VERA memory (12:0) into R0
000C78  2  A5 04        	lda r1L
000C7A  2  85 02        	sta r0L
000C7C  2  A5 05        	lda r1H
000C7E  2  85 03        	sta r0H
000C80  2               
000C80  2               	; convert full addr to vera mode (bit shiting >> 5)
000C80  2  A5 03        	lda r0H
000C82  2  4A           	lsr
000C83  2  66 02        	ror r0L
000C85  2  4A           	lsr
000C86  2  66 02        	ror r0L
000C88  2  4A           	lsr
000C89  2  66 02        	ror r0L
000C8B  2  4A           	lsr
000C8C  2  66 02        	ror r0L						; bit shift 4x 16 bits vera memory
000C8E  2  4A           	lsr
000C8F  2  66 02        	ror r0L						; bit shift 4x 16 bits vera memory
000C91  2               
000C91  2               	; store 12:5 into our cache
000C91  2  9D 2C 17     	sta player0 + PLAYER::vera_bitmaps, x
000C94  2  E8           	inx
000C95  2  A5 02        	lda r0L
000C97  2  9D 2C 17     	sta player0 + PLAYER::vera_bitmaps, x
000C9A  2  E8           	inx
000C9B  2               
000C9B  2               	; increase the vram (+4 r1H = +1024 r1)
000C9B  2  18           	clc
000C9C  2  A5 05        	lda r1H
000C9E  2  69 04        	adc #4
000CA0  2  85 05        	sta r1H
000CA2  2               
000CA2  2  88           	dey
000CA3  2  D0 D3        	bne @loop
000CA5  2               
000CA5  2               	; set first bitmap
000CA5  2  20 B8 0C     	jsr set_bitmap
000CA8  2  60           	rts
000CA9  2               
000CA9  2               ;************************************************
000CA9  2               ; force the current player sprite at its position
000CA9  2               ;
000CA9  2               position_set:
000CA9  2  AC 18 17     	ldy player0 + PLAYER::sprite
000CAC  2  A9 21 85 02  	LOAD_r0 (player0 + PLAYER::px)
000CB0  2  A9 17 85 03  
000CB4  2  20 F7 09     	jsr Sprite::position			; set position of the sprite
000CB7  2  60           	rts
000CB8  2               
000CB8  2               ;************************************************
000CB8  2               ; change the player bitmap
000CB8  2               ;
000CB8  2               set_bitmap:
000CB8  2  18           	clc
000CB9  2  AD 1F 17     	lda player0 + PLAYER::spriteAnim
000CBC  2  6D 1E 17     	adc player0 + PLAYER::spriteID
000CBF  2  0A           	asl						; convert sprite index to work position
000CC0  2  AA           	tax
000CC1  2               
000CC1  2               	; extract the vera bitmap address in vera format (12:5 bits)
000CC1  2  BD 2C 17     	lda player0 + PLAYER::vera_bitmaps, x
000CC4  2  85 03        	sta r0H
000CC6  2  BD 2D 17     	lda player0 + PLAYER::vera_bitmaps + 1, x
000CC9  2  85 02        	sta r0L
000CCB  2               
000CCB  2  AC 18 17     	ldy player0 + PLAYER::sprite
000CCE  2  20 D8 09     	jsr Sprite::set_bitmap
000CD1  2  60           	rts
000CD2  2               
000CD2  2               ;************************************************
000CD2  2               ; increase player X position
000CD2  2               ;	modify r0
000CD2  2               ;
000CD2  2               position_x_inc:
000CD2  2               	; move the absolute position levelx + 1
000CD2  2  AD 25 17     	lda player0 + PLAYER::levelx
000CD5  2  AE 26 17     	ldx player0 + PLAYER::levelx + 1
000CD8  2  C9 E0        	cmp #<(LEVEL_WIDTH - 32)
000CDA  2  D0 04        	bne @incLOW1
000CDC  2  E0 01        	cpx #>(LEVEL_WIDTH - 32)
000CDE  2  F0 48        	beq @no_move						; we are at the level limit
000CE0  2               @incLOW1:
000CE0  2  1A           	inc
000CE1  2  8D 25 17     	sta player0 + PLAYER::levelx
000CE4  2  D0 04        	bne @inc_screen_x
000CE6  2               @incHi:
000CE6  2  E8           	inx
000CE7  2  8E 26 17     	stx player0 + PLAYER::levelx + 1
000CEA  2               
000CEA  2               @inc_screen_x:
000CEA  2               	; distance from layer border to sprite absolute position
000CEA  2  38           	sec
000CEB  2  AD 25 17     	lda player0 + PLAYER::levelx
000CEE  2  ED 37 9F     	sbc VERA_L1_hscrolllo
000CF1  2  85 02        	sta r0L
000CF3  2  AD 26 17     	lda player0 + PLAYER::levelx + 1
000CF6  2  ED 38 9F     	sbc VERA_L1_hscrollhi
000CF9  2  85 03        	sta r0H
000CFB  2               
000CFB  2  D0 17        	bne @move_sprite_upper
000CFD  2  A6 03        	ldx r0H
000CFF  2  A5 02        	lda r0L
000D01  2  C9 E0        	cmp #<(SCREEN_WIDTH	- 96)
000D03  2  90 19        	bcc @move_sprite
000D05  2               
000D05  2               @move_layers:
000D05  2               	; keep the sprite onscreen 224, for level 224->416
000D05  2  A0 BF A2 00  	VSCROLL_INC Layers::HSCROLL,(32*16-320 - 1)	; 32 tiles * 16 pixels per tiles - 320 screen pixels
000D09  2  20 85 0B     
000D0C  2  F0 06        	beq @move_sprite_upper
000D0E  2  A2 00        	ldx #Layers::HSCROLL
000D10  2  20 E4 0B     	jsr Layers::scroll_l0
000D13  2  60           	rts
000D14  2               
000D14  2               @move_sprite_upper:
000D14  2  AD 21 17     	lda player0 + PLAYER::px
000D17  2  AE 22 17     	ldx player0 + PLAYER::px + 1
000D1A  2  1A           	inc
000D1B  2  D0 01        	bne @move_sprite
000D1D  2  E8           	inx
000D1E  2               
000D1E  2               @move_sprite:
000D1E  2  8D 21 17     	sta player0 + PLAYER::px
000D21  2  8E 22 17     	stx player0 + PLAYER::px + 1
000D24  2  20 A9 0C     	jsr Player::position_set
000D27  2  60           	rts
000D28  2               
000D28  2               @no_move:
000D28  2  60           	rts
000D29  2               
000D29  2               ;************************************************
000D29  2               ; decrease player position X unless at 0
000D29  2               ;
000D29  2               position_x_dec:
000D29  2               	; move the absolute position levelx + 1
000D29  2  AD 25 17     	lda player0 + PLAYER::levelx
000D2C  2  D0 05        	bne @decLOW
000D2E  2  AE 26 17     	ldx player0 + PLAYER::levelx + 1
000D31  2  F0 49        	beq @no_move						; we are at Y == 0
000D33  2               @decLOW:
000D33  2  3A           	dec
000D34  2  8D 25 17     	sta player0 + PLAYER::levelx
000D37  2  C9 FF        	cmp #$ff
000D39  2  D0 04        	bne @dec_screen_x
000D3B  2               @decHi:
000D3B  2  CA           	dex
000D3C  2  8E 26 17     	stx player0 + PLAYER::levelx + 1
000D3F  2               
000D3F  2               @dec_screen_x:
000D3F  2               	; distance from layer border to sprite absolute position
000D3F  2  38           	sec
000D40  2  AD 25 17     	lda player0 + PLAYER::levelx
000D43  2  ED 37 9F     	sbc VERA_L1_hscrolllo
000D46  2  85 02        	sta r0L
000D48  2  AD 26 17     	lda player0 + PLAYER::levelx + 1
000D4B  2  ED 38 9F     	sbc VERA_L1_hscrollhi
000D4E  2  85 03        	sta r0H
000D50  2               
000D50  2  D0 15        	bne @move_sprite_lower				; > 256, we are far off from the border, so move the sprite
000D52  2               
000D52  2  A5 02        	lda r0L
000D54  2  30 11        	bmi @move_sprite_lower					; > 127, move the sprites
000D56  2  C9 40        	cmp #64
000D58  2  B0 0D        	bcs @move_sprite_lower					; if > 64, move the sprites
000D5A  2               
000D5A  2               @move_layers:
000D5A  2               	; keep the sprite onscreen 224, for level 224->416
000D5A  2  A2 00        	ldx #Layers::HSCROLL
000D5C  2  20 C2 0B     	jsr Layers::scroll_dec
000D5F  2  F0 06        	beq @move_sprite_lower
000D61  2  A2 00        	ldx #Layers::HSCROLL
000D63  2  20 E4 0B     	jsr Layers::scroll_l0
000D66  2  60           	rts
000D67  2               
000D67  2               @move_sprite_lower:
000D67  2  AD 21 17     	lda player0 + PLAYER::px
000D6A  2  AE 22 17     	ldx player0 + PLAYER::px + 1
000D6D  2  3A           	dec
000D6E  2  C9 FF        	cmp #$ff
000D70  2  D0 01        	bne @move_sprite
000D72  2  CA           	dex
000D73  2               
000D73  2               @move_sprite:
000D73  2  8D 21 17     	sta player0 + PLAYER::px
000D76  2  8E 22 17     	stx player0 + PLAYER::px + 1
000D79  2  20 A9 0C     	jsr Player::position_set
000D7C  2               
000D7C  2               @no_move:
000D7C  2  60           	rts
000D7D  2               
000D7D  2               ;************************************************
000D7D  2               ; increase player Y position
000D7D  2               ;
000D7D  2               position_y_inc:
000D7D  2               	; move the absolute position levelx + 1
000D7D  2  AD 27 17     	lda player0 + PLAYER::levely
000D80  2  AE 28 17     	ldx player0 + PLAYER::levely + 1
000D83  2  C9 E0        	cmp #<(LEVEL_HEIGHT - 32)
000D85  2  D0 04        	bne @incLOW1
000D87  2  E0 01        	cpx #>(LEVEL_HEIGHT - 32)
000D89  2  F0 4E        	beq @no_move						; we are at the level limit
000D8B  2               @incLOW1:
000D8B  2  1A           	inc
000D8C  2  8D 27 17     	sta player0 + PLAYER::levely
000D8F  2  D0 04        	bne @inc_screen_y
000D91  2               @incHi:
000D91  2  E8           	inx
000D92  2  8E 28 17     	stx player0 + PLAYER::levely + 1
000D95  2               
000D95  2               @inc_screen_y:
000D95  2               	; distance from layer border to sprite absolute position
000D95  2  38           	sec
000D96  2  AD 27 17     	lda player0 + PLAYER::levely
000D99  2  ED 39 9F     	sbc VERA_L1_vscrolllo
000D9C  2  85 02        	sta r0L
000D9E  2  AD 28 17     	lda player0 + PLAYER::levely + 1
000DA1  2  ED 3A 9F     	sbc VERA_L1_vscrollhi
000DA4  2  85 03        	sta r0H
000DA6  2               
000DA6  2  D0 1D        	bne @move_sprite_upper
000DA8  2  A6 03        	ldx r0H
000DAA  2  A5 02        	lda r0L
000DAC  2  C9 B0        	cmp #<(SCREEN_HEIGHT - 64)
000DAE  2  90 1F        	bcc @move_sprite
000DB0  2               
000DB0  2               @move_layers:
000DB0  2               	; keep the sprite onscreen 224, for level 224->416
000DB0  2  A9 0F 85 02  	VSCROLL_INC Layers::VSCROLL,(32*16-240 - 1)	; 32 tiles * 16 pixels per tiles - 240 screen pixels
000DB4  2  A9 01 85 03  
000DB8  2  A2 02 20 A0  
000DBD  2  F0 06        	beq @move_sprite_upper
000DBF  2  A2 02        	ldx #Layers::VSCROLL
000DC1  2  20 E4 0B     	jsr Layers::scroll_l0
000DC4  2  60           	rts
000DC5  2               
000DC5  2               @move_sprite_upper:
000DC5  2  AD 23 17     	lda player0 + PLAYER::py
000DC8  2  AE 24 17     	ldx player0 + PLAYER::py + 1
000DCB  2  1A           	inc
000DCC  2  D0 01        	bne @move_sprite
000DCE  2  E8           	inx
000DCF  2               
000DCF  2               @move_sprite:
000DCF  2  8D 23 17     	sta player0 + PLAYER::py
000DD2  2  8E 24 17     	stx player0 + PLAYER::py + 1
000DD5  2  20 A9 0C     	jsr Player::position_set
000DD8  2  60           	rts
000DD9  2               
000DD9  2               @no_move:
000DD9  2  60           	rts
000DDA  2               
000DDA  2               ;;
000DDA  2  AD 23 17     	lda player0 + PLAYER::py
000DDD  2  C9 D0        	cmp #(SCREEN_HEIGHT-32)
000DDF  2  F0 09        	beq @moveleftP0
000DE1  2  1A           	inc
000DE2  2  8D 23 17     	sta player0 + PLAYER::py
000DE5  2  D0 03        	bne @moveleftP0
000DE7  2  EE 24 17     	inc player0 + PLAYER::py + 1
000DEA  2               @moveleftP0:
000DEA  2  20 A9 0C     	jsr Player::position_set
000DED  2  60           	rts
000DEE  2               
000DEE  2               ;************************************************
000DEE  2               ; decrease player position X unless at 0
000DEE  2               ;
000DEE  2               position_y_dec:
000DEE  2               	; move the absolute position levelx + 1
000DEE  2  AD 27 17     	lda player0 + PLAYER::levely
000DF1  2  D0 05        	bne @decLOW
000DF3  2  AE 28 17     	ldx player0 + PLAYER::levely + 1
000DF6  2  F0 49        	beq @no_move						; we are at Y == 0
000DF8  2               @decLOW:
000DF8  2  3A           	dec
000DF9  2  8D 27 17     	sta player0 + PLAYER::levely
000DFC  2  C9 FF        	cmp #$ff
000DFE  2  D0 04        	bne @dec_screen_y
000E00  2               @decHi:
000E00  2  CA           	dex
000E01  2  8E 28 17     	stx player0 + PLAYER::levely + 1
000E04  2               
000E04  2               @dec_screen_y:
000E04  2               	; distance from layer border to sprite absolute position
000E04  2  38           	sec
000E05  2  AD 27 17     	lda player0 + PLAYER::levely
000E08  2  ED 39 9F     	sbc VERA_L1_vscrolllo
000E0B  2  85 02        	sta r0L
000E0D  2  AD 28 17     	lda player0 + PLAYER::levely + 1
000E10  2  ED 3A 9F     	sbc VERA_L1_vscrollhi
000E13  2  85 03        	sta r0H
000E15  2               
000E15  2  D0 15        	bne @move_sprite_lower				; > 256, we are far off from the border, so move the sprite
000E17  2               
000E17  2  A5 02        	lda r0L
000E19  2  30 11        	bmi @move_sprite_lower					; > 127, move the sprites
000E1B  2  C9 20        	cmp #32
000E1D  2  B0 0D        	bcs @move_sprite_lower					; if > 32, move the sprites
000E1F  2               
000E1F  2               @move_layers:
000E1F  2               	; keep the sprite onscreen 224, for level 224->416
000E1F  2  A2 02        	ldx #Layers::VSCROLL
000E21  2  20 C2 0B     	jsr Layers::scroll_dec
000E24  2  F0 06        	beq @move_sprite_lower
000E26  2  A2 02        	ldx #Layers::VSCROLL
000E28  2  20 E4 0B     	jsr Layers::scroll_l0
000E2B  2  60           	rts
000E2C  2               
000E2C  2               @move_sprite_lower:
000E2C  2  AD 23 17     	lda player0 + PLAYER::py
000E2F  2  AE 24 17     	ldx player0 + PLAYER::py + 1
000E32  2  3A           	dec
000E33  2  C9 FF        	cmp #$ff
000E35  2  D0 01        	bne @move_sprite
000E37  2  CA           	dex
000E38  2               
000E38  2               @move_sprite:
000E38  2  8D 23 17     	sta player0 + PLAYER::py
000E3B  2  8E 24 17     	stx player0 + PLAYER::py + 1
000E3E  2  20 A9 0C     	jsr Player::position_set
000E41  2               
000E41  2               @no_move:
000E41  2  60           	rts
000E42  2               
000E42  2               ;************************************************
000E42  2               ; hide the current sprite
000E42  2               ;
000E42  2               hide1:
000E42  2  DB           	stp
000E43  2  18           	clc
000E44  2  AD 1F 17     	lda player0 + PLAYER::spriteAnim
000E47  2  6D 1E 17     	adc player0 + PLAYER::spriteID
000E4A  2  A8           	tay		; sprite index
000E4B  2  A2 00        	ldx #SPRITE_ZDEPTH_DISABLED
000E4D  2  20 EA 09     	jsr Sprite::display			; turn current sprite off
000E50  2  60           	rts
000E51  2               
000E51  2               ;************************************************
000E51  2               ; Animate the player if needed
000E51  2               ;
000E51  2               animate:
000E51  2  AD 19 17     	lda player0 + PLAYER::status
000E54  2  C9 00        	cmp #STATUS_WALKING_IDLE
000E56  2  F0 3A        	beq @end
000E58  2  C9 04        	cmp #STATUS_FALLING
000E5A  2  F0 36        	beq @end
000E5C  2  C9 03        	cmp #STATUS_CLIMBING_IDLE
000E5E  2  F0 32        	beq @end
000E60  2               
000E60  2  CE 1D 17     	dec player0 + PLAYER::animation_tick
000E63  2  D0 2D        	bne @end
000E65  2               
000E65  2  A9 0A        	lda #10
000E67  2  8D 1D 17     	sta player0 + PLAYER::animation_tick	; reset animation tick counter
000E6A  2               
000E6A  2  18           	clc
000E6B  2  AD 1F 17     	lda player0 + PLAYER::spriteAnim
000E6E  2  6D 20 17     	adc player0 + PLAYER::spriteAnimDirection
000E71  2  F0 06        	beq @set_sprite_anim_increase					; reached 0
000E73  2  C9 03        	cmp #3
000E75  2  F0 0B        	beq @set_sprite_anim_decrease
000E77  2  80 10        	bra @set_sprite_on
000E79  2               @set_sprite_anim_increase:
000E79  2  A9 01        	lda #01
000E7B  2  8D 20 17     	sta player0 + PLAYER::spriteAnimDirection
000E7E  2  A9 00        	lda #0
000E80  2  80 07        	bra @set_sprite_on
000E82  2               @set_sprite_anim_decrease:
000E82  2  A9 FF        	lda #$ff
000E84  2  8D 20 17     	sta player0 + PLAYER::spriteAnimDirection
000E87  2  A9 02        	lda #2
000E89  2               @set_sprite_on:
000E89  2  8D 1F 17     	sta player0 + PLAYER::spriteAnim	; turn next sprite on
000E8C  2  20 B8 0C     	jsr Player::set_bitmap
000E8F  2  20 A9 0C     	jsr Player::position_set
000E92  2               @end:
000E92  2  60           	rts
000E93  2               
000E93  2               ;************************************************
000E93  2               ; position of the player on the layer1 tilemap
000E93  2               ;	modified : r1
000E93  2               ;	output : r0
000E93  2               ;
000E93  2               get_tilemap_position:
000E93  2  18           	clc
000E94  2  AD 27 17     	lda player0 + PLAYER::levely		; sprite screen position
000E97  2  85 02        	sta r0L
000E99  2  AD 28 17     	lda player0 + PLAYER::levely + 1
000E9C  2  85 03        	sta r0H							; r0 = sprite absolute position Y in the level
000E9E  2               
000E9E  2  A5 02        	lda r0L
000EA0  2  29 F0        	and #%11110000
000EA2  2  85 02        	sta r0L
000EA4  2  A5 03        	lda r0H
000EA6  2  85 03        	sta r0H
000EA8  2  A5 02        	lda r0L
000EAA  2  0A           	asl
000EAB  2  26 03        	rol r0H
000EAD  2  85 02        	sta r0L 						; r0 = first tile of the tilemap in the row
000EAF  2               									; spriteY / 16 (convert to tile Y) * 32 (number of tiles per row in the tile map)
000EAF  2               
000EAF  2  AD 25 17     	lda player0 + PLAYER::levelx		; sprite screen position
000EB2  2  85 04        	sta r1L
000EB4  2  AD 26 17     	lda player0 + PLAYER::levelx + 1
000EB7  2  85 05        	sta r1H							; r1 = sprite absolute position X in the level
000EB9  2               
000EB9  2  4A           	lsr
000EBA  2  66 04        	ror r1L
000EBC  2  4A           	lsr
000EBD  2  66 04        	ror r1L
000EBF  2  4A           	lsr
000EC0  2  66 04        	ror r1L
000EC2  2  4A           	lsr
000EC3  2  66 04        	ror r1L
000EC5  2  85 05        	sta r1H 					; r1 = tile X in the row
000EC7  2               								; sprite X /16 (convert to tile X)
000EC7  2               
000EC7  2  18           	clc
000EC8  2  A5 02        	lda r0L
000ECA  2  65 04        	adc r1L
000ECC  2  85 02        	sta r0L
000ECE  2  A5 03        	lda r0H
000ED0  2  65 05        	adc r1H
000ED2  2  85 03        	sta r0H						; r0 = tile position in the tilemap
000ED4  2               
000ED4  2  18           	clc
000ED5  2  A5 03        	lda r0H
000ED7  2  69 A0        	adc #>HIMEM
000ED9  2  85 03        	sta r0H						; r0 = tile position in the memory tilemap
000EDB  2  60           	rts
000EDC  2               
000EDC  2               ;************************************************
000EDC  2               ; force player status to be idle
000EDC  2               ;
000EDC  2               set_idle:
000EDC  2  AD 19 17     	lda player0 + PLAYER::status
000EDF  2  C9 01        	cmp #STATUS_WALKING
000EE1  2  F0 06        	beq @set_idle_walking
000EE3  2  C9 02        	cmp #STATUS_CLIMBING
000EE5  2  F0 08        	beq @set_idle_climbing
000EE7  2  60           	rts							; keep the current value
000EE8  2               @set_idle_jump:
000EE8  2  60           	rts
000EE9  2               @set_idle_walking:
000EE9  2  A9 00 8D 19  	m_status STATUS_WALKING_IDLE
000EED  2  17           
000EEE  2  60           	rts
000EEF  2               @set_idle_climbing:
000EEF  2  A9 03 8D 19  	m_status STATUS_CLIMBING_IDLE
000EF3  2  17           
000EF4  2  60           	rts
000EF5  2               
000EF5  2               ;************************************************
000EF5  2               ; check if the player sits on a solid tile
000EF5  2               ;
000EF5  2               physics:
000EF5  2  20 93 0E     	jsr get_tilemap_position
000EF8  2  A5 02 8D 2A  	SAVE_r0 player0 + PLAYER::tilemap	; cache the tilemap @
000EFC  2  17 A5 03 8D  
000F00  2  2B 17        
000F02  2               
000F02  2  AD 19 17     	lda player0 + PLAYER::status
000F05  2  C9 02        	cmp #STATUS_CLIMBING
000F07  2  F0 0B        	beq @return1
000F09  2  C9 03        	cmp #STATUS_CLIMBING_IDLE
000F0B  2  F0 07        	beq @return1
000F0D  2  C9 05        	cmp #STATUS_JUMPING
000F0F  2  D0 04        	bne @fall
000F11  2  4C B9 0F     	jmp @jump
000F14  2               @return1:
000F14  2  60           	rts
000F15  2               
000F15  2               	;
000F15  2               	; deal with gravity driven falling
000F15  2               	;
000F15  2               @fall:
000F15  2               .ifdef DEBUG
000F15  2               	CHECK_DEBUG
000F15  2               .endif
000F15  2  20 9A 10     	jsr check_collision_down
000F18  2  F0 03        	beq @check_on_slope				; no solid tile below the player, still check if the player is ON a slope
000F1A  2  4C AC 0F     	jmp @sit_on_solid				; solid tile below the player that is not a slope
000F1D  2               
000F1D  2               @check_on_slope:
000F1D  2  20 1B 11     	jsr check_player_on_slop
000F20  2  F0 23        	beq @no_collision_down			; not ON a slope, and not ABOVE a solid tile => fall
000F22  2               
000F22  2               @on_slope:
000F22  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
000F24  2  F0 0B        	beq @slope_left
000F26  2               @slope_right:
000F26  2  AD 25 17     	lda player0 + PLAYER::levelx	; X position defines how far down Y can go
000F29  2  29 0F        	and #%00001111
000F2B  2  49 0F        	eor #%00001111					; X = 0 => Y can go up to 15
000F2D  2  85 30        	sta $30
000F2F  2  80 09        	bra @slope_y
000F31  2               @slope_left:
000F31  2  AD 25 17     	lda player0 + PLAYER::levelx	; X position defines how far down Y can go
000F34  2  29 0F        	and #%00001111
000F36  2  85 30        	sta $30
000F38  2  80 00        	bra @slope_y
000F3A  2               @slope_y:
000F3A  2  AD 27 17     	lda player0 + PLAYER::levely
000F3D  2  29 0F        	and #%00001111
000F3F  2  C5 30        	cmp $30
000F41  2  30 02        	bmi @no_collision_down
000F43  2  80 67        	bra @sit_on_solid
000F45  2               
000F45  2               @no_collision_down:
000F45  2               	; if the player is already falling, increase t
000F45  2  AD 19 17     	lda player0 + PLAYER::status
000F48  2  C9 04        	cmp #STATUS_FALLING
000F4A  2  F0 0D        	beq @increase_ticks
000F4C  2               
000F4C  2               	; let the player fall
000F4C  2  A9 04        	lda #STATUS_FALLING
000F4E  2  8D 19 17     	sta player0 + PLAYER::status
000F51  2  A9 08        	lda #FALL_LO_TICKS
000F53  2  8D 1A 17     	sta player0 + PLAYER::falling_ticks	; reset t
000F56  2  9C 1B 17     	stz player0 + PLAYER::falling_ticks + 1
000F59  2               @increase_ticks:
000F59  2  CE 1A 17     	dec player0 + PLAYER::falling_ticks	; increase HI every 10 refresh
000F5C  2  D0 08        	bne @drive_fall
000F5E  2  A9 08        	lda #FALL_LO_TICKS
000F60  2  8D 1A 17     	sta player0 + PLAYER::falling_ticks	; reset t
000F63  2  EE 1B 17     	inc player0 + PLAYER::falling_ticks + 1
000F66  2               
000F66  2               @drive_fall:
000F66  2  AD 1B 17     	lda player0 + PLAYER::falling_ticks + 1
000F69  2  F0 3C        	beq @fall_once
000F6B  2  85 14        	sta r9L
000F6D  2               @loop_fall:
000F6D  2  20 7D 0D     	jsr position_y_inc
000F70  2  20 93 0E     	jsr get_tilemap_position
000F73  2  A5 02 8D 2A  	SAVE_r0 player0 + PLAYER::tilemap
000F77  2  17 A5 03 8D  
000F7B  2  2B 17        
000F7D  2               
000F7D  2               	; test reached solid ground
000F7D  2  20 9A 10     	jsr check_collision_down
000F80  2  D0 2A        	bne @sit_on_solid
000F82  2               
000F82  2               @loop_fall_no_collision:
000F82  2  C6 14        	dec r9L
000F84  2  D0 E7        	bne @loop_fall						; take t in count for gravity
000F86  2               
000F86  2               @apply_delta_x:
000F86  2  AD 1C 17     	lda player0 + PLAYER::delta_x		; apply delatx
000F89  2  F0 2D        	beq @return
000F8B  2  30 0D        	bmi @fall_left
000F8D  2               @fall_right:
000F8D  2  20 88 10     	jsr check_collision_right
000F90  2  F0 04        	beq @no_fcollision_right
000F92  2               @fcollision_right:
000F92  2  9C 1C 17     	stz player0 + PLAYER::delta_x		; cancel deltaX to transform to vertical movement
000F95  2  60           	rts
000F96  2               @no_fcollision_right:
000F96  2  20 D2 0C     	jsr position_x_inc
000F99  2  60           	rts
000F9A  2               @fall_left:
000F9A  2  20 91 10     	jsr check_collision_left
000F9D  2  F0 04        	beq @no_fcollision_left
000F9F  2               @fcollision_left:
000F9F  2  9C 1C 17     	stz player0 + PLAYER::delta_x		; cancel deltaX to transform to vertical movement
000FA2  2  60           	rts
000FA3  2               @no_fcollision_left:
000FA3  2  20 29 0D     	jsr position_x_dec
000FA6  2  60           	rts
000FA7  2               
000FA7  2               @fall_once:
000FA7  2  20 7D 0D     	jsr position_y_inc
000FAA  2  80 DA        	bra @apply_delta_x
000FAC  2               
000FAC  2               @sit_on_solid:
000FAC  2               	; change the status if falling
000FAC  2  AD 19 17     	lda player0 + PLAYER::status
000FAF  2  C9 04        	cmp #STATUS_FALLING
000FB1  2  D0 05        	bne @return
000FB3  2  A9 00        	lda #STATUS_WALKING_IDLE
000FB5  2  8D 19 17     	sta player0 + PLAYER::status
000FB8  2               @return:
000FB8  2  60           	rts
000FB9  2               
000FB9  2               	;
000FB9  2               	; deal with gravity driven jumping
000FB9  2               	;
000FB9  2               @jump:
000FB9  2               @decrease_ticks:
000FB9  2  CE 1A 17     	dec player0 + PLAYER::falling_ticks	; decrease  HI every 10 refresh
000FBC  2  D0 0A        	bne @drive_jump
000FBE  2  CE 1B 17     	dec player0 + PLAYER::falling_ticks	+ 1
000FC1  2  F0 4B        	beq @apex							; reached the apex of the jump
000FC3  2               
000FC3  2  A9 0A        	lda #JUMP_LO_TICKS
000FC5  2  8D 1A 17     	sta player0 + PLAYER::falling_ticks	; reset t
000FC8  2               
000FC8  2               @drive_jump:
000FC8  2  AD 1B 17     	lda player0 + PLAYER::falling_ticks + 1
000FCB  2  85 14        	sta r9L
000FCD  2               @loop_jump:
000FCD  2  20 EE 0D     	jsr position_y_dec
000FD0  2  20 93 0E     	jsr get_tilemap_position
000FD3  2  A5 02 8D 2A  	SAVE_r0 player0 + PLAYER::tilemap
000FD7  2  17 A5 03 8D  
000FDB  2  2B 17        
000FDD  2               
000FDD  2  AD 27 17     	lda player0 + PLAYER::levely
000FE0  2  29 0F        	and #%00001111
000FE2  2  D0 05        	bne @no_collision_up				; if player is not on a multiple of 16 (tile size)
000FE4  2               
000FE4  2               	; test hit a ceiling
000FE4  2  20 CF 10     	jsr check_collision_up
000FE7  2  D0 04        	bne @collision_up
000FE9  2               @no_collision_up:
000FE9  2  C6 14        	dec r9L
000FEB  2  D0 E0        	bne @loop_jump						; loop to take t in count for gravity
000FED  2               
000FED  2               @collision_up:
000FED  2  AD 1C 17     	lda player0 + PLAYER::delta_x		; deal with deltax
000FF0  2  F0 C6        	beq @return
000FF2  2  30 0D        	bmi @jump_left
000FF4  2               @jump_right:
000FF4  2  20 88 10     	jsr check_collision_right
000FF7  2  F0 04        	beq @no_collision_right
000FF9  2               @collision_right:
000FF9  2  9C 1C 17     	stz player0 + PLAYER::delta_x		; cancel deltaX to transform to vertical movement
000FFC  2  60           	rts
000FFD  2               @no_collision_right:
000FFD  2  20 D2 0C     	jsr position_x_inc
001000  2  60           	rts
001001  2               @jump_left:
001001  2  20 91 10     	jsr check_collision_left
001004  2  F0 04        	beq @no_collision_left
001006  2               @collision_left:
001006  2  9C 1C 17     	stz player0 + PLAYER::delta_x		; cancel deltaX to transform to vertical movement
001009  2  60           	rts
00100A  2               @no_collision_left:
00100A  2  20 29 0D     	jsr position_x_dec
00100D  2  60           	rts
00100E  2               
00100E  2               @apex:
00100E  2  A9 06 8D 19  	m_status STATUS_JUMPING_IDLE
001012  2  17           
001013  2  60           	rts
001014  2               
001014  2               ;************************************************
001014  2               ;	compute the number of tiles covered by the boundingbox
001014  2               ;	return: r1L : number of tiles height
001014  2               ;			X = r1H : number of tiles width
001014  2               ;			Y = r2L : index of the first tile to test
001014  2               ;
001014  2               bbox_coverage:
001014  2               	; X = how many column of tiles to test
001014  2  AD 25 17     	lda player0 + PLAYER::levelx
001017  2  29 0F        	and #%00001111
001019  2  C9 08        	cmp #8
00101B  2  F0 08        	beq @one_tile
00101D  2  30 0C        	bmi @two_tiles_straight				; if X < 8, test as if int
00101F  2               @two_tiles_right:
00101F  2  A2 02        	ldx #02								; test 2 column ( y % 16 <> 0)
001021  2  A0 01        	ldy #01								; starting on row +1
001023  2  80 0A        	bra @test_lines
001025  2               @one_tile:
001025  2  A2 01        	ldx #01								; test 1 column ( y % 16  == 8)
001027  2  A0 01        	ldy #01								; starting on row +1
001029  2  80 04        	bra @test_lines
00102B  2               @two_tiles_straight:
00102B  2  A2 02        	ldx #02								; test 2 columns ( y % 16 == 0)
00102D  2  A0 00        	ldy #00								; test on row  0 ( x % 16 != 0)
00102F  2               
00102F  2               @test_lines:
00102F  2               	; X = how many lines of tiles to test
00102F  2  AD 27 17     	lda player0 + PLAYER::levely
001032  2  29 0F        	and #%00001111
001034  2  D0 09        	bne @yfloat				; if player is not on a multiple of 16 (tile size)
001036  2               @yint:
001036  2  A9 02        	lda #02					; test 2 lines ( y % 16 == 0)
001038  2  85 04        	sta r1L
00103A  2  86 05        	stx r1H
00103C  2  84 06        	sty r2L
00103E  2  60           	rts
00103F  2               @yfloat:
00103F  2  A9 03        	lda #03					; test 3 rows ( y % 16 <> 0)
001041  2  85 04        	sta r1L
001043  2  86 05        	stx r1H
001045  2  84 06        	sty r2L
001047  2  60           	rts
001048  2               
001048  2               ;************************************************
001048  2               ; check collision on the height
001048  2               ;	A = vaule of the collision
001048  2               ;	ZERO = no collision
001048  2               ;
001048  2               check_collision_height:
001048  2               	; only test if we are 'centered'
001048  2  AD 25 17     	lda player0 + PLAYER::levelx
00104B  2  29 0F        	and #%00001111
00104D  2  C9 08        	cmp #08
00104F  2  D0 34        	bne @no_collision
001051  2               
001051  2  AD 2A 17     	lda player0 + PLAYER::tilemap
001054  2  85 02        	sta r0L
001056  2  AD 2B 17     	lda player0 + PLAYER::tilemap + 1
001059  2  85 03        	sta r0H
00105B  2               
00105B  2  20 14 10     	jsr bbox_coverage
00105E  2  A6 04        	ldx r1L				; tiles height
001060  2  98           	tya
001061  2  18           	clc
001062  2  6D F5 0B     	adc test_right_left
001065  2  A8           	tay
001066  2               
001066  2               @test_line:
001066  2  B1 02        	lda (r0L),y
001068  2  F0 11        	beq @test_next_line
00106A  2               
00106A  2               	; some tiles are not real collision
00106A  2  84 30        	sty $30
00106C  2  A8           	tay
00106D  2  B9 11 16     	lda tiles_attributes,y
001070  2  29 02        	and #TILE_ATTR::SOLID_WALL
001072  2  F0 05        	beq @test_next_line1
001074  2  A4 30        	ldy $30
001076  2  B1 02        	lda (r0L),y
001078  2  60           	rts
001079  2               
001079  2               @test_next_line1:
001079  2  A4 30        	ldy $30
00107B  2               
00107B  2               @test_next_line:
00107B  2  CA           	dex
00107C  2  F0 07        	beq @no_collision
00107E  2  98           	tya
00107F  2  18           	clc
001080  2  69 20        	adc #LEVEL_TILES_WIDTH			; test the tile on the right of the player (hip position)
001082  2  A8           	tay
001083  2  80 E1        	bra @test_line					; LADDERS can be traversed
001085  2               
001085  2               @no_collision:						; force a no collision
001085  2  A9 00        	lda #00
001087  2               @return:
001087  2  60           	rts
001088  2               
001088  2               ;************************************************
001088  2               ; check collision on the right
001088  2               ;	return: A = value of the collision
001088  2               ;			ZERO = no collision
001088  2               ;
001088  2               check_collision_right:
001088  2  A9 01        	lda #$01
00108A  2  8D F5 0B     	sta test_right_left
00108D  2  20 48 10     	jsr check_collision_height
001090  2  60           	rts
001091  2               
001091  2               ;************************************************
001091  2               ; check collision on the left
001091  2               ;
001091  2               check_collision_left:
001091  2  A9 FF        	lda #$ff
001093  2  8D F5 0B     	sta test_right_left
001096  2  20 48 10     	jsr check_collision_height
001099  2  60           	rts
00109A  2               
00109A  2               ;************************************************
00109A  2               ; check collision down
00109A  2               ;	collision surface to test is 16 pixels around the mid X
00109A  2               ; 	output : Z = no collision
00109A  2               ;
00109A  2               check_collision_down:
00109A  2  AD 27 17     	lda player0 + PLAYER::levely	; if the player is inbetween 2 tiles there can be no collision
00109D  2  29 0F        	and #%00001111
00109F  2  F0 03        	beq @real_test
0010A1  2  A9 00        	lda #00
0010A3  2  60           	rts
0010A4  2               @real_test:
0010A4  2  AD 2A 17     	lda player0 + PLAYER::tilemap
0010A7  2  85 02        	sta r0L
0010A9  2  AD 2B 17     	lda player0 + PLAYER::tilemap + 1
0010AC  2  85 03        	sta r0H
0010AE  2               
0010AE  2  20 14 10     	jsr bbox_coverage
0010B1  2  98           	tya
0010B2  2  18           	clc
0010B3  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)	; check below the player
0010B5  2  A8           	tay
0010B6  2               
0010B6  2               @test_colum:
0010B6  2  B1 02        	lda (r0L),y
0010B8  2  F0 0C        	beq @next_colum							; empty tile, test the next one
0010BA  2               
0010BA  2  84 30        	sty $30
0010BC  2  A8           	tay
0010BD  2  B9 11 16     	lda tiles_attributes,y
0010C0  2  29 01        	and #TILE_ATTR::SOLID_GROUND
0010C2  2  D0 08        	bne @return1							; considere slopes as empty
0010C4  2  A4 30        	ldy $30
0010C6  2               
0010C6  2               @next_colum:
0010C6  2  CA           	dex
0010C7  2  F0 05        	beq @return
0010C9  2  C8           	iny
0010CA  2  80 EA        	bra @test_colum
0010CC  2               @return1:
0010CC  2  A9 01        	lda #01
0010CE  2               @return:
0010CE  2  60           	rts
0010CF  2               
0010CF  2               ;************************************************
0010CF  2               ; check collision up
0010CF  2               ;	collision surface to test is 16 pixels around the mid X
0010CF  2               ;	input :
0010CF  2               ;		r0 : @ of current tile the top-left corner of the player sprite
0010CF  2               ; 	output : Z = no collision
0010CF  2               ;
0010CF  2               check_collision_up:
0010CF  2  38           	sec
0010D0  2  AD 2A 17     	lda player0 + PLAYER::tilemap
0010D3  2  E9 20        	sbc #LEVEL_TILES_WIDTH
0010D5  2  85 02        	sta r0L
0010D7  2  AD 2B 17     	lda player0 + PLAYER::tilemap + 1
0010DA  2  E9 00        	sbc #0
0010DC  2  85 03        	sta r0H
0010DE  2               
0010DE  2               	; X = how many column of tiles to test
0010DE  2  AD 25 17     	lda player0 + PLAYER::levelx
0010E1  2  29 0F        	and #%00001111
0010E3  2  F0 0A        	beq @xint				; if player is not on a multiple of 16 (tile size)
0010E5  2               @xfloat:
0010E5  2  C9 08        	cmp #8
0010E7  2  30 06        	bmi @xint
0010E9  2  A2 01        	ldx #1					; test 1 column ( y % 16 <> 0)
0010EB  2  A0 01        	ldy #1					; starting at colum + 1
0010ED  2  80 13        	bra @test_colum
0010EF  2               @xint:
0010EF  2  A2 02        	ldx #2					; test 2 columns ( y % 16 == 0)
0010F1  2  A0 00        	ldy #0					; starting at colum
0010F3  2  80 00        	bra @test_y
0010F5  2               
0010F5  2               @test_y:
0010F5  2               	; Y = how tile rows to test
0010F5  2  AD 27 17     	lda player0 + PLAYER::levely
0010F8  2  29 0F        	and #%00001111
0010FA  2  F0 06        	beq @yint				; if player is not on a multiple of 16 (tile size)
0010FC  2               @yfloat:
0010FC  2  98           	tya
0010FD  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)	; test on (row -1) +1 ( x % 16 != 0) + column
0010FF  2  A8           	tay
001100  2  80 00        	bra @test_colum
001102  2               @yint:
001102  2               
001102  2               @test_colum:
001102  2  B1 02        	lda (r0L),y							; left side
001104  2  F0 0C        	beq @next_column
001106  2               
001106  2  84 30        	sty $30
001108  2  A8           	tay
001109  2  B9 11 16     	lda tiles_attributes,y
00110C  2  29 04        	and #TILE_ATTR::SOLID_CEILING
00110E  2  D0 08        	bne @return1
001110  2  A4 30        	ldy $30
001112  2               
001112  2               @next_column:
001112  2  CA           	dex
001113  2  F0 05        	beq @return
001115  2  C8           	iny
001116  2  80 EA        	bra @test_colum
001118  2               @return1:
001118  2  A9 01        	lda #01
00111A  2               @return:
00111A  2  60           	rts
00111B  2               
00111B  2               ;************************************************
00111B  2               ; check if the player feet is exactly on a slope tile
00111B  2               ;	modify: player_on_slop
00111B  2               ;	return: Z = slop
00111B  2               ;			Y = feet position tested (vs r0)
00111B  2               ;
00111B  2               check_player_on_slop:
00111B  2  9C F3 0B     	stz player_on_slop				; no slope
00111E  2               
00111E  2  20 14 10     	jsr bbox_coverage
001121  2               
001121  2  18           	clc
001122  2  98           	tya
001123  2  A6 04        	ldx r1L
001125  2  CA           	dex
001126  2               :
001126  2  69 20        	adc #LEVEL_TILES_WIDTH
001128  2  CA           	dex
001129  2  D0 FB        	bne :-
00112B  2  A8           	tay								; position of the feet tiles
00112C  2               
00112C  2  AD 25 17     	lda player0 + PLAYER::levelx
00112F  2  29 0F        	and #%00001111
001131  2  C9 08        	cmp #08
001133  2  10 01        	bpl :+
001135  2  C8           	iny
001136  2               :
001136  2               
001136  2               	; check if player feet is ON a slop
001136  2  B1 02        	lda (r0),y						; test ON feet level
001138  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
00113A  2  F0 04        	beq @on_slope
00113C  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
00113E  2  D0 06        	bne @no_slope
001140  2               @on_slope:
001140  2  B1 02        	lda (r0),y						; test ON feet level
001142  2  8D F3 0B     	sta player_on_slop
001145  2  60           	rts
001146  2               
001146  2               @no_slope:
001146  2  A9 00        	lda #0
001148  2  8D F3 0B     	sta player_on_slop
00114B  2  60           	rts
00114C  2               
00114C  2               ;************************************************
00114C  2               ; check if the player feet is ABOVE a slope tile
00114C  2               ;	input: 	Y = feet position tested (vs r0)
00114C  2               ;	modify: player_on_slop
00114C  2               ;	return: Z = slop
00114C  2               ;
00114C  2               is_player_above_slop:
00114C  2  9C F3 0B     	stz player_on_slop				; no slope
00114F  2               
00114F  2  98           	tya
001150  2  18           	clc
001151  2  69 20        	adc #LEVEL_TILES_WIDTH
001153  2  A8           	tay								; test BELOW feet level
001154  2  B1 02        	lda (r0),y
001156  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
001158  2  F0 0A        	beq @above_slope
00115A  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
00115C  2  F0 06        	beq @above_slope
00115E  2               @no_slope:
00115E  2  A9 00        	lda #0
001160  2  8D F3 0B     	sta player_on_slop
001163  2  60           	rts
001164  2               @above_slope:
001164  2  8D F3 0B     	sta player_on_slop
001167  2  60           	rts
001168  2               
001168  2               ;************************************************
001168  2               ; status to ignore while moving
001168  2               ;
001168  2               ignore_move_request:
001168  2  00           	.byte	00	;	STATUS_WALKING_IDLE
001169  2  00           	.byte	00	;	STATUS_WALKING
00116A  2  02           	.byte	02	;	STATUS_CLIMBING
00116B  2  02           	.byte	02	;	STATUS_CLIMBING_IDLE
00116C  2  01           	.byte	01	;	STATUS_FALLING
00116D  2  01           	.byte	01	;	STATUS_JUMPING
00116E  2  01           	.byte	01	;	STATUS_JUMPING_IDLE
00116F  2               
00116F  2               ;************************************************
00116F  2               ; Try to move player to the right, walk up if facing a slope
00116F  2               ;
00116F  2               move_right:
00116F  2  AC 19 17     	ldy player0 + PLAYER::status
001172  2  B9 68 11     	lda ignore_move_request, y
001175  2  F0 06        	beq @walk_right					; if 0 => can move
001177  2  C9 02        	cmp #02
001179  2  F0 6E        	beq @climb_right				; if 2 => has to climb
00117B  2  80 6B        	bra @return1					; else block the move
00117D  2               
00117D  2               @walk_right:
00117D  2  20 1B 11     	jsr check_player_on_slop
001180  2  D0 0A        	bne @no_collision
001182  2               
001182  2  20 4C 11     	jsr is_player_above_slop
001185  2  D0 05        	bne @no_collision
001187  2               
001187  2  20 88 10     	jsr Player::check_collision_right
00118A  2  D0 5C        	bne @return1					; block is collision on the right  and there is no slope on the right
00118C  2               
00118C  2               @no_collision:
00118C  2  A9 01        	lda #01
00118E  2  8D 1C 17     	sta player0 + PLAYER::delta_x
001191  2               
001191  2               @set_walking_sprite:
001191  2  A9 01        	lda #SPRITE_FLIP_H
001193  2  8D 29 17     	sta player0 + PLAYER::flip
001196  2  AC 18 17     	ldy player0 + PLAYER::sprite
001199  2  20 15 0A     	jsr Sprite::set_flip				; force sprite to look right
00119C  2               
00119C  2  A9 01 8D 19  	m_status STATUS_WALKING
0011A0  2  17           
0011A1  2               
0011A1  2               	;change player sprite
0011A1  2  A9 03        	lda #Player::Sprites::LEFT
0011A3  2  CD 1E 17     	cmp player0 + PLAYER::spriteID
0011A6  2  F0 08        	beq @move_x
0011A8  2               
0011A8  2  A9 03        	lda #Player::Sprites::LEFT
0011AA  2  8D 1E 17     	sta player0 + PLAYER::spriteID
0011AD  2  20 B8 0C     	jsr set_bitmap
0011B0  2               
0011B0  2               @move_x:
0011B0  2  20 D2 0C     	jsr Player::position_x_inc		; move the player in the level, and the screen layers and sprite
0011B3  2               
0011B3  2               	; if sitting on a slop
0011B3  2  AD F3 0B     	lda player_on_slop
0011B6  2  F0 2D        	beq @set_position
0011B8  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
0011BA  2  F0 26        	beq @move_y_up
0011BC  2               @try_move_y_dow:
0011BC  2  AD 27 17     	lda player0 + PLAYER::levely
0011BF  2  29 0F        	and #%00001111
0011C1  2  D0 1A        	bne @move_y_down
0011C3  2  AD 2A 17     	lda player0 + PLAYER::tilemap
0011C6  2  85 02        	sta r0L
0011C8  2  AD 2B 17     	lda player0 + PLAYER::tilemap+1
0011CB  2  85 03        	sta r0H
0011CD  2  A5 06        	lda r2L
0011CF  2  18           	clc
0011D0  2  69 41        	adc #(LEVEL_TILES_WIDTH * 2 + 1)	; check on the 2nd block
0011D2  2  A8           	tay
0011D3  2  B1 02        	lda (r0), y							; check if the tile below as an attribute SOLID_GROUND
0011D5  2  A8           	tay
0011D6  2  B9 11 16     	lda tiles_attributes,y
0011D9  2  29 01        	and #TILE_ATTR::SOLID_GROUND
0011DB  2  D0 61        	bne @return							; do not change Y if the tile below the player is a solid one
0011DD  2               @move_y_down:
0011DD  2  20 7D 0D     	jsr position_y_inc
0011E0  2  80 03        	bra @set_position
0011E2  2               @move_y_up:
0011E2  2  20 EE 0D     	jsr position_y_dec
0011E5  2               
0011E5  2               @set_position:
0011E5  2  20 A9 0C     	jsr position_set
0011E8  2               @return1:
0011E8  2  60           	rts
0011E9  2               
0011E9  2               @climb_right:
0011E9  2  20 88 10     	jsr Player::check_collision_right
0011EC  2  F0 05        	beq @climb_right_1
0011EE  2  C9 04        	cmp #TILE_SOLID_LADER
0011F0  2  F0 01        	beq @climb_right_1
0011F2  2  60           	rts
0011F3  2               @climb_right_1:
0011F3  2  20 14 10     	jsr bbox_coverage
0011F6  2               @get_tile:
0011F6  2  B1 02        	lda (r0),y
0011F8  2  F0 0E        	beq @no_grab					; no tile on right
0011FA  2  85 31        	sta $31
0011FC  2  84 30        	sty $30
0011FE  2  A8           	tay
0011FF  2  B9 11 16     	lda tiles_attributes,y
001202  2  29 08        	and #TILE_ATTR::GRABBING
001204  2  D0 08        	bne @climb_right_2				; tile on right with a GRAB attribute
001206  2  A4 30        	ldy $30
001208  2               @no_grab:							; test the tile on the right on next line
001208  2  C8           	iny
001209  2  CA           	dex
00120A  2  D0 EA        	bne @get_tile
00120C  2  80 1E        	bra @climb_right_drop			; no grab tile on the right of the player
00120E  2               @climb_right_2:
00120E  2  A5 31        	lda $31							; tile index with grab attribute
001210  2  C9 05        	cmp #TILE_LEDGE
001212  2  D0 04        	bne @set_climb_sprite
001214  2               @set_hang_sprite:
001214  2  A9 09        	lda #Player::Sprites::HANG
001216  2  80 02        	bra @next
001218  2               @set_climb_sprite:
001218  2  A9 06        	lda #Player::Sprites::CLIMB
00121A  2               @next:
00121A  2  8D 1E 17     	sta player0 + PLAYER::spriteID
00121D  2  20 B8 0C     	jsr set_bitmap
001220  2  A9 02 8D 19  	m_status STATUS_CLIMBING
001224  2  17           
001225  2  20 D2 0C     	jsr Player::position_x_inc		; move the player sprite, if the
001228  2  20 A9 0C     	jsr position_set
00122B  2  60           	rts
00122C  2               @climb_right_drop:
00122C  2  A9 01 8D 19  	m_status STATUS_WALKING
001230  2  17           
001231  2  A9 03 8D 1E  	SET_SPRITE Player::Sprites::LEFT, 1
001235  2  17 A9 01 8D  
001239  2  1F 17 20 B8  
00123E  2               
00123E  2               @return:
00123E  2  60           	rts
00123F  2               
00123F  2               ;************************************************
00123F  2               ; try to move the player to the left
00123F  2               ;
00123F  2               move_left:
00123F  2  AC 19 17     	ldy player0 + PLAYER::status
001242  2  B9 68 11     	lda ignore_move_request, y
001245  2  F0 06        	beq @walk_left					; if 0 => can move
001247  2  C9 02        	cmp #02
001249  2  F0 6E        	beq @climb_left				; if 2 => has to climb
00124B  2  80 6B        	bra @return					; else block the move
00124D  2               
00124D  2               @walk_left:
00124D  2  20 1B 11     	jsr check_player_on_slop
001250  2  D0 0A        	bne @no_collision				; ignore right collision left if on a slope
001252  2               
001252  2  20 4C 11     	jsr is_player_above_slop
001255  2  D0 05        	bne @no_collision
001257  2               
001257  2  20 91 10     	jsr Player::check_collision_left
00125A  2  D0 5C        	bne @return						; block is collision on the right  and there is no slope on the right
00125C  2               
00125C  2               @no_collision:
00125C  2  A9 FF        	lda #$ff
00125E  2  8D 1C 17     	sta player0 + PLAYER::delta_x
001261  2               
001261  2               @set_walking_sprite:
001261  2  A9 00        	lda #SPRITE_FLIP_NONE
001263  2  8D 29 17     	sta player0 + PLAYER::flip
001266  2  AC 18 17     	ldy player0 + PLAYER::sprite
001269  2  20 15 0A     	jsr Sprite::set_flip				; force sprite to loop right
00126C  2               
00126C  2  A9 01 8D 19  	m_status STATUS_WALKING
001270  2  17           
001271  2               
001271  2  A9 03        	lda #Player::Sprites::LEFT
001273  2  CD 1E 17     	cmp player0 + PLAYER::spriteID
001276  2  F0 08        	beq @move_x
001278  2               
001278  2               	;change player sprite
001278  2  A9 03        	lda #Player::Sprites::LEFT
00127A  2  8D 1E 17     	sta player0 + PLAYER::spriteID
00127D  2  20 B8 0C     	jsr set_bitmap
001280  2               
001280  2               @move_x:
001280  2  20 29 0D     	jsr Player::position_x_dec
001283  2               
001283  2  AD F3 0B     	lda player_on_slop				; if walking a slop also increase Y
001286  2  F0 2D        	beq @set_position
001288  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
00128A  2  F0 26        	beq @move_y_up
00128C  2               @try_move_y_dow:
00128C  2  AD 27 17     	lda player0 + PLAYER::levely
00128F  2  29 0F        	and #%00001111
001291  2  D0 1A        	bne @move_y_down
001293  2  AD 2A 17     	lda player0 + PLAYER::tilemap
001296  2  85 02        	sta r0L
001298  2  AD 2B 17     	lda player0 + PLAYER::tilemap+1
00129B  2  85 03        	sta r0H
00129D  2  A5 06        	lda r2L
00129F  2  18           	clc
0012A0  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)
0012A2  2  A8           	tay
0012A3  2  B1 02        	lda (r0), y							; check if the tile below as an attribute TILE_SOLID_GROUND
0012A5  2  A8           	tay
0012A6  2  B9 11 16     	lda tiles_attributes,y
0012A9  2  29 01        	and #TILE_ATTR::SOLID_GROUND
0012AB  2  D0 0B        	bne @return							; do not change Y if the tile below the player is a solid one
0012AD  2               @move_y_down:
0012AD  2  20 7D 0D     	jsr position_y_inc
0012B0  2  80 03        	bra @set_position
0012B2  2               @move_y_up:
0012B2  2  20 EE 0D     	jsr position_y_dec
0012B5  2               
0012B5  2               @set_position:
0012B5  2  20 A9 0C     	jsr position_set
0012B8  2               
0012B8  2               @return:
0012B8  2  60           	rts
0012B9  2               
0012B9  2               @climb_left:
0012B9  2  20 91 10     	jsr Player::check_collision_left
0012BC  2  F0 01        	beq @climb_left_1
0012BE  2  60           	rts								; collision on left, block the move
0012BF  2               @climb_left_1:
0012BF  2  20 14 10     	jsr bbox_coverage				; what tiles is the player covering
0012C2  2               @get_tile:
0012C2  2  B1 02        	lda (r0),y
0012C4  2  F0 0E        	beq @no_grab					; no tile on right
0012C6  2  85 31        	sta $31
0012C8  2  84 30        	sty $30
0012CA  2  A8           	tay
0012CB  2  B9 11 16     	lda tiles_attributes,y
0012CE  2  29 08        	and #TILE_ATTR::GRABBING
0012D0  2  D0 08        	bne @climb_left_2				; tile on left with a GRAB attribute
0012D2  2  A4 30        	ldy $30
0012D4  2               @no_grab:							; test the tile on the left on next line
0012D4  2  C8           	iny
0012D5  2  CA           	dex
0012D6  2  D0 EA        	bne @get_tile
0012D8  2  80 1E        	bra @climb_left_drop			; no grab tile on the right of the player
0012DA  2               @climb_left_2:
0012DA  2  A5 31        	lda $31							; tile index with grab attribute
0012DC  2  C9 05        	cmp #TILE_LEDGE
0012DE  2  D0 04        	bne @set_climb_sprite
0012E0  2               @set_hang_sprite:
0012E0  2  A9 09        	lda #Player::Sprites::HANG
0012E2  2  80 02        	bra @next
0012E4  2               @set_climb_sprite:
0012E4  2  A9 06        	lda #Player::Sprites::CLIMB
0012E6  2               @next:
0012E6  2  8D 1E 17     	sta player0 + PLAYER::spriteID
0012E9  2  20 B8 0C     	jsr set_bitmap
0012EC  2  A9 02 8D 19  	m_status STATUS_CLIMBING
0012F0  2  17           
0012F1  2  20 29 0D     	jsr Player::position_x_dec		; move the player sprite, if the
0012F4  2  20 A9 0C     	jsr position_set
0012F7  2  60           	rts
0012F8  2               @climb_left_drop:					; no ladder to stick to
0012F8  2  A9 01 8D 19  	m_status STATUS_WALKING
0012FC  2  17           
0012FD  2  A9 03 8D 1E  	SET_SPRITE Player::Sprites::LEFT, 1
001301  2  17 A9 01 8D  
001305  2  1F 17 20 B8  
00130A  2  60           	rts
00130B  2               
00130B  2               ;************************************************
00130B  2               ; try to move the player down (crouch, hide, move down a ladder)
00130B  2               ;
00130B  2               move_down:
00130B  2  AD 19 17     	lda player0 + PLAYER::status
00130E  2  C9 04        	cmp #STATUS_FALLING
001310  2  D0 01        	bne @try_move_down						; cannot move when falling
001312  2  60           	rts
001313  2               
001313  2               @try_move_down:
001313  2               	; custom collision down
001313  2  AD 2A 17     	lda player0 + PLAYER::tilemap
001316  2  85 02        	sta r0L
001318  2  AD 2B 17     	lda player0 + PLAYER::tilemap + 1
00131B  2  85 03        	sta r0H
00131D  2               
00131D  2  20 14 10     	jsr bbox_coverage
001320  2  8E F4 0B     	stx ladders						; width of the player in tiles = number of ladders to find below
001323  2  98           	tya
001324  2  18           	clc
001325  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)	; check below the player
001327  2  A8           	tay
001328  2               
001328  2               @test_colum:
001328  2  B1 02        	lda (r0L),y
00132A  2  C9 04        	cmp #TILE_SOLID_LADER
00132C  2  D0 05        	bne @check_solid_ground
00132E  2               @ladder_down:
00132E  2  CE F4 0B     	dec ladders
001331  2  80 0C        	bra @next_column
001333  2               @check_solid_ground:
001333  2  84 30        	sty $30
001335  2  A8           	tay
001336  2  B9 11 16     	lda tiles_attributes,y
001339  2  29 01        	and #TILE_ATTR::SOLID_GROUND
00133B  2  D0 45        	bne @cannot_move_down
00133D  2  A4 30        	ldy $30
00133F  2               @next_column:
00133F  2  CA           	dex
001340  2  F0 03        	beq @end
001342  2  C8           	iny
001343  2  80 E3        	bra @test_colum
001345  2               @end:
001345  2               
001345  2  AD F4 0B     	lda ladders
001348  2  F0 1C        	beq @move_down						; correct number of ladder tiles below the player
00134A  2               
00134A  2               	; if there player is covering ANY ladders (accros the boundingbox)
00134A  2  A4 06        	ldy r2L
00134C  2               @check_line:							; already climbing down is player grabbing no ladder
00134C  2  A6 05        	ldx r1H
00134E  2               @check_row:
00134E  2  B1 02        	lda (r0L),y
001350  2  C9 04        	cmp #TILE_SOLID_LADER
001352  2  F0 12        	beq @move_down
001354  2  C8           	iny
001355  2  CA           	dex
001356  2  D0 F6        	bne @check_row
001358  2  C6 04        	dec r1L
00135A  2  F0 26        	beq @cannot_move_down
00135C  2               
00135C  2  98           	tya
00135D  2  18           	clc
00135E  2  69 20        	adc #LEVEL_TILES_WIDTH
001360  2  38           	sec
001361  2  E5 05        	sbc r1H
001363  2  A8           	tay
001364  2  80 E6        	bra @check_line
001366  2               
001366  2               @move_down:
001366  2  20 7D 0D     	jsr Player::position_y_inc		; move down the ladder
001369  2  20 A9 0C     	jsr position_set
00136C  2               
00136C  2  A9 02 8D 19  	m_status STATUS_CLIMBING
001370  2  17           
001371  2               
001371  2  A9 06        	lda #Player::Sprites::CLIMB
001373  2  CD 1E 17     	cmp player0 + PLAYER::spriteID
001376  2  D0 01        	bne @change_sprite
001378  2  60           	rts
001379  2               
001379  2               @change_sprite:
001379  2               	;change player sprite
001379  2  A9 06        	lda #Player::Sprites::CLIMB
00137B  2  8D 1E 17     	sta player0 + PLAYER::spriteID
00137E  2  20 B8 0C     	jsr set_bitmap
001381  2  60           	rts
001382  2               
001382  2               @cannot_move_down:
001382  2  A9 00        	lda #STATUS_WALKING_IDLE
001384  2  8D 19 17     	sta player0 + PLAYER::status
001387  2  A9 01        	lda #01
001389  2  8D 1F 17     	sta player0 + PLAYER::spriteAnim
00138C  2  20 B8 0C     	jsr set_bitmap
00138F  2  9C 1C 17     	stz player0 + PLAYER::delta_x
001392  2  60           	rts
001393  2               
001393  2               ;************************************************
001393  2               ; try to move the player up (move up a ladder)
001393  2               ;	only climb a ladder if the 16 pixels mid-X are fully enclosed in the ladder
001393  2               ;	modify: r0, r1, r2
001393  2               ;
001393  2               move_up:
001393  2  AD 19 17     	lda player0 + PLAYER::status
001396  2  C9 04        	cmp #STATUS_FALLING
001398  2  D0 01        	bne @try_move_up				; cannot move when falling
00139A  2  60           	rts
00139B  2               @try_move_up:
00139B  2               	; custom collision up
00139B  2  20 14 10     	jsr bbox_coverage
00139E  2  8E F4 0B     	stx ladders						; width of the player in tiles = number of ladders to find below
0013A1  2               
0013A1  2               	; check the situation ABOVE the player
0013A1  2  38           	sec
0013A2  2  AD 2A 17     	lda player0 + PLAYER::tilemap
0013A5  2  E9 20        	sbc #LEVEL_TILES_WIDTH
0013A7  2  85 02        	sta r0L
0013A9  2  AD 2B 17     	lda player0 + PLAYER::tilemap+1
0013AC  2  E9 00        	sbc #0
0013AE  2  85 03        	sta r0H
0013B0  2               
0013B0  2               	; if there the right numbers of ladder tiles above the player
0013B0  2               @test_colum:
0013B0  2  B1 02        	lda (r0L),y
0013B2  2  C9 04        	cmp #TILE_SOLID_LADER
0013B4  2  D0 05        	bne @check_solid_ceiling
0013B6  2  CE F4 0B     	dec ladders
0013B9  2  80 0C        	bra @next_column
0013BB  2               @check_solid_ceiling:
0013BB  2  84 30        	sty $30
0013BD  2  A8           	tay
0013BE  2  B9 11 16     	lda tiles_attributes,y
0013C1  2  29 04        	and #TILE_ATTR::SOLID_CEILING
0013C3  2  D0 4F        	bne @cannot_move_up
0013C5  2  A4 30        	ldy $30
0013C7  2               @next_column:
0013C7  2  CA           	dex
0013C8  2  F0 03        	beq @end
0013CA  2  C8           	iny
0013CB  2  80 E3        	bra @test_colum
0013CD  2               @end:
0013CD  2               
0013CD  2  AD F4 0B     	lda ladders
0013D0  2  F0 26        	beq @climb_down						; correct number of ladder tiles above the player
0013D2  2               
0013D2  2               	; if there player is covering ANY LADER (accros the boundingbox)
0013D2  2  AD 2A 17     	lda player0 + PLAYER::tilemap
0013D5  2  85 02        	sta r0L
0013D7  2  AD 2B 17     	lda player0 + PLAYER::tilemap+1
0013DA  2  85 03        	sta r0H
0013DC  2               
0013DC  2  A4 06        	ldy r2L
0013DE  2               @check_line:							; already climbing up is player grabbing no ladder
0013DE  2  A6 05        	ldx r1H
0013E0  2               @check_row:
0013E0  2  B1 02        	lda (r0L),y
0013E2  2  C9 04        	cmp #TILE_SOLID_LADER
0013E4  2  F0 12        	beq @climb_down
0013E6  2  C8           	iny
0013E7  2  CA           	dex
0013E8  2  D0 F6        	bne @check_row
0013EA  2  C6 04        	dec r1L
0013EC  2  F0 26        	beq @cannot_move_up
0013EE  2               
0013EE  2  98           	tya
0013EF  2  18           	clc
0013F0  2  69 20        	adc #LEVEL_TILES_WIDTH
0013F2  2  38           	sec
0013F3  2  E5 05        	sbc r1H
0013F5  2  A8           	tay
0013F6  2  80 E6        	bra @check_line
0013F8  2               
0013F8  2               @climb_down:
0013F8  2  20 EE 0D     	jsr Player::position_y_dec		; move up the ladder
0013FB  2  20 A9 0C     	jsr position_set
0013FE  2               
0013FE  2  A9 02 8D 19  	m_status STATUS_CLIMBING
001402  2  17           
001403  2               
001403  2  A9 06        	lda #Player::Sprites::CLIMB
001405  2  CD 1E 17     	cmp player0 + PLAYER::spriteID
001408  2  D0 01        	bne @set_sprite
00140A  2  60           	rts
00140B  2               @set_sprite:						;change player sprite
00140B  2  A9 06        	lda #Player::Sprites::CLIMB
00140D  2  8D 1E 17     	sta player0 + PLAYER::spriteID
001410  2  20 B8 0C     	jsr set_bitmap
001413  2  60           	rts
001414  2               
001414  2               @cannot_move_up:
001414  2  A9 00        	lda #STATUS_WALKING_IDLE
001416  2  8D 19 17     	sta player0 + PLAYER::status
001419  2  60           	rts
00141A  2               
00141A  2               ;************************************************
00141A  2               ; jump
00141A  2               ;	A = delta X value
00141A  2               ;
00141A  2               jump:
00141A  2  AA           	tax
00141B  2  AC 19 17         ldy player0 + PLAYER::status
00141E  2  B9 68 11     	lda ignore_move_request,y
001421  2  D0 17        	bne @return
001423  2  8E 1C 17     	stx player0 + PLAYER::delta_x
001426  2               
001426  2               	; ensure there is no ceiling over the player
001426  2  20 CF 10     	jsr check_collision_up
001429  2  D0 0F        	bne @return
00142B  2               
00142B  2  A9 0A        	lda #JUMP_LO_TICKS
00142D  2  8D 1A 17     	sta player0 + PLAYER::falling_ticks	; decrease  HI every 10 refresh
001430  2  A9 02        	lda #JUMP_HI_TICKS
001432  2  8D 1B 17     	sta player0 + PLAYER::falling_ticks	+ 1
001435  2               
001435  2  A9 05 8D 19  	m_status STATUS_JUMPING
001439  2  17           
00143A  2               @return:
00143A  2  60           	rts
00143B  2               
00143B  2               .endscope
00143B  2               
00143B  1               
00143B  1               ;-----------------------------------------------------------------------------
00143B  1               ;/////////////////////////////////////////////////////////////////////////////
00143B  1               ; main code
00143B  1               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
00143B  1               ;-----------------------------------------------------------------------------
00143B  1               
00143B  1  00 00        objects: .word 0
00143D  1               
00143D  1               start:
00143D  1               	; 320x240
00143D  1  A9 40        	lda #64
00143F  1  8D 2A 9F     	sta veradchscale
001442  1  8D 2B 9F     	sta veradcvscale
001445  1               
001445  1               	; activate layer0
001445  1  A9 71        	lda #%01110001
001447  1               ;	and #(255-VERA_LAYER0)
001447  1               ;	ora #(VERA_LAYER1)             ; Read Video Register
001447  1  8D 29 9F     	sta veradcvideo             ; Store new value to Video Register
00144A  1               
00144A  1               	;---------------------------------
00144A  1               	; load tiles file into vram
00144A  1               	;---------------------------------
00144A  1  A9 01 A2 08  	VLOAD_FILE fstile, (fstileend-fstile), VRAM_tiles
00144E  1  A0 00 20 BA  
001452  1  FF A9 09 A2  
00146B  1               
00146B  1               	;---------------------------------
00146B  1               	; load tilemaps into vram
00146B  1               	;---------------------------------
00146B  1               setlayer0:
00146B  1  AD 2D 9F 29  	VCONFIG_TILES 0,VERA_CONFIG_32x32
00146F  1  0F 09 00 8D  
001473  1  2D 9F        
001475  1  AD 2D 9F 29  	VCONFIG_DEPTH 0,VERA_CONFIG_8BPP
001479  1  0F 09 03 8D  
00147D  1  2D 9F        
00147F  1  A9 00 8D 2E  	VMAPBASE 0, VRAM_layer0_map
001483  1  9F           
001484  1  AD 2F 9F 29  	VTILEBASE 0, VRAM_tiles
001488  1  03 09 08 8D  
00148C  1  2F 9F        
00148E  1  AD 2F 9F 29  	VTILEMODE 0,VERA_TILE_16x16
001492  1  FC 09 03 8D  
001496  1  2F 9F        
001498  1  A9 01 A2 08  	VLOAD_FILE fsbackground, (fsbackground_end-fsbackground), VRAM_layer0_map
00149C  1  A0 00 20 BA  
0014A0  1  FF A9 0B A2  
0014B9  1               
0014B9  1               setlayer1:
0014B9  1  AD 34 9F 29  	VCONFIG_TILES 1,VERA_CONFIG_32x32
0014BD  1  0F 09 00 8D  
0014C1  1  34 9F        
0014C3  1  AD 34 9F 29  	VCONFIG_DEPTH 1,VERA_CONFIG_8BPP
0014C7  1  0F 09 03 8D  
0014CB  1  34 9F        
0014CD  1  A9 04 8D 35  	VMAPBASE 1, VRAM_layer1_map
0014D1  1  9F           
0014D2  1  AD 36 9F 29  	VTILEBASE 1, VRAM_tiles
0014D6  1  03 09 08 8D  
0014DA  1  36 9F        
0014DC  1  AD 36 9F 29  	VTILEMODE 1,VERA_TILE_16x16
0014E0  1  FC 09 03 8D  
0014E4  1  36 9F        
0014E6  1  A9 01 A2 08  	VLOAD_FILE fslevel, (fslevel_end-fslevel), VRAM_layer1_map
0014EA  1  A0 00 20 BA  
0014EE  1  FF A9 09 A2  
001507  1               
001507  1               	;---------------------------------
001507  1               	; load collisionmap into ram
001507  1               	;---------------------------------
001507  1  A9 00        	lda #0
001509  1  85 00        	sta $00
00150B  1  A9 01 A2 08  	LOAD_FILE fscollision, (fscollision_end-fscollision), HIMEM
00150F  1  A0 00 20 BA  
001513  1  FF A9 0D A2  
00152C  1               
00152C  1               	;---------------------------------
00152C  1               	; load sprite 0,1,2 into vram
00152C  1               	;---------------------------------
00152C  1               load_sprites:
00152C  1               	; prepare VERA sprites
00152C  1  20 39 09     	jsr Sprite::init_addr_table
00152F  1               
00152F  1  A9 00 85 02  	LOAD_r0 (VRAM_tiles + tiles * tile_size)	; base for the sprites
001533  1  A9 3B 85 03  
001537  1  20 F6 0B     	jsr Player::init
00153A  1               
00153A  1               	;---------------------------------
00153A  1               	; load objects list into ram
00153A  1               	;---------------------------------
00153A  1  20 38 0A     	jsr Objects::init
00153D  1               
00153D  1               setirq:
00153D  1                  ; backup default RAM IRQ vector
00153D  1  AD 14 03        lda IRQVec
001540  1  8D 0E 16        sta default_irq_vector
001543  1  AD 15 03        lda IRQVec+1
001546  1  8D 0F 16        sta default_irq_vector+1
001549  1               
001549  1                  ; overwrite RAM IRQ vector with custom handler address
001549  1  78              sei ; disable IRQ while vector is changing
00154A  1  A9 5E           lda #<custom_irq_handler
00154C  1  8D 14 03        sta IRQVec
00154F  1  A9 15           lda #>custom_irq_handler
001551  1  8D 15 03        sta IRQVec+1
001554  1  A9 01           lda #VERA_VSYNC_BIT ; make VERA only generate VSYNC IRQs
001556  1  8D 26 9F        sta veraien
001559  1  58              cli ; enable IRQ now that vector is properly set
00155A  1               
00155A  1               mainloop:
00155A  1  CB           	wai
00155B  1               	; do nothing in main loop, just let ISR do everything
00155B  1  80 FD        	bra mainloop
00155D  1               
00155D  1  60           	rts
00155E  1               
00155E  1               ;-----------------------------------------------------------------------------
00155E  1               ;/////////////////////////////////////////////////////////////////////////////
00155E  1               ; deal with IRQ"s
00155E  1               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
00155E  1               ;-----------------------------------------------------------------------------
00155E  1               custom_irq_handler:
00155E  1  AD 27 9F        lda veraisr
001561  1  29 01           and #VERA_VSYNC_BIT
001563  1  F0 2D           beq @continue 	; non-VSYNC IRQ, no tick update
001565  1               
001565  1               	;---------------------------------
001565  1               	; animate sprite
001565  1               	;---------------------------------
001565  1  20 51 0E     	jsr Player::animate
001568  1               
001568  1               	;---------------------------------
001568  1               	; player physics
001568  1               	;---------------------------------
001568  1  20 F5 0E     	jsr Player::physics
00156B  1               
00156B  1               	;---------------------------------
00156B  1               	; check keyboard
00156B  1               	;---------------------------------
00156B  1               @check_keyboard:
00156B  1  A9 00        	lda #0
00156D  1  20 56 FF     	jsr joystick_get
001570  1  8D 17 16     	sta joystick
001573  1               
001573  1               ;  .A, byte 0:      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
001573  1               ;              NES  | A | B |SEL|STA|UP |DN |LT |RT |
001573  1               ;              SNES | B | Y |SEL|STA|UP |DN |LT |RT |
001573  1               ;
001573  1               ;  .X, byte 1:      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
001573  1               ;              NES  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | X |
001573  1               ;              SNES | A | X | L | R | 1 | 1 | 1 | 1 |
001573  1               ;  .Y, byte 2:
001573  1               ;              $00 = joystick present
001573  1               ;              $FF = joystick not present
001573  1  89 81        	bit #(JOY_RIGHT|JOY_B)
001575  1  F0 1E        	beq @jump_right
001577  1  89 82        	bit #(JOY_LEFT|JOY_B)
001579  1  F0 21        	beq @jump_left
00157B  1  89 01        	bit #JOY_RIGHT
00157D  1  F0 29        	beq @joystick_right
00157F  1  89 02        	bit #JOY_LEFT
001581  1  F0 20        	beq @joystick_left
001583  1  89 04        	bit #JOY_DOWN
001585  1  F0 2B        	beq @movedown
001587  1  89 08        	bit #JOY_UP
001589  1  F0 22        	beq @moveup
00158B  1  89 80        	bit #JOY_B
00158D  1  F0 28        	beq @jump
00158F  1               
00158F  1  20 DC 0E     	jsr Player::set_idle
001592  1               
001592  1               @continue:
001592  1                  ; continue to default IRQ handler
001592  1  6C 0E 16        jmp (default_irq_vector)
001595  1                  ; RTI will happen after jump
001595  1               
001595  1               @jump_right:
001595  1  A9 01        	lda #$01					; jump right
001597  1  20 1A 14     	jsr Player::jump
00159A  1  80 F6        	bra @continue
00159C  1               
00159C  1               @jump_left:
00159C  1  A9 FF        	lda #$ff					; jump left
00159E  1  20 1A 14     	jsr Player::jump
0015A1  1  80 EF        	bra @continue
0015A3  1               
0015A3  1               @joystick_left:
0015A3  1  20 3F 12     	jsr Player::move_left
0015A6  1  80 EA        	bra @continue
0015A8  1               
0015A8  1               @joystick_right:
0015A8  1  20 6F 11     	jsr Player::move_right
0015AB  1  80 E5        	bra @continue
0015AD  1               
0015AD  1               @moveup:
0015AD  1  20 93 13     	jsr Player::move_up
0015B0  1  80 E0        	bra @continue
0015B2  1               
0015B2  1               @movedown:
0015B2  1  20 0B 13     	jsr Player::move_down
0015B5  1  80 DB        	bra @continue
0015B7  1               
0015B7  1               @jump:
0015B7  1  A9 00        	lda #0				; jump up
0015B9  1  20 1A 14     	jsr Player::jump
0015BC  1  80 D4        	bra @continue
0015BE  1               
0015BE  1               .segment "DATA"
0015BE  1               .include "tilemap.inc"
0015BE  2               map:
0015BE  2  20 20        	.byte 32,32
0015C0  2  6C 65 76 65  fslevel: .literal "level.bin"
0015C4  2  6C 2E 62 69  
0015C8  2  6E           
0015C9  2               fslevel_end:
0015C9  2  73 63 65 6E  fsbackground: .literal "scenery.bin"
0015CD  2  65 72 79 2E  
0015D1  2  62 69 6E     
0015D4  2               fsbackground_end:
0015D4  2  63 6F 6C 6C  fscollision: .literal "collision.bin"
0015D8  2  69 73 69 6F  
0015DC  2  6E 2E 62 69  
0015E1  2               fscollision_end:
0015E1  2  6F 62 6A 65  fsobjects: .literal "objects.bin"
0015E5  2  63 74 73 2E  
0015E9  2  62 69 6E     
0015EC  2               fsobjects_end:
0015EC  2  73 70 72 69  fssprites1: .literal "sprites1.bin"
0015F0  2  74 65 73 31  
0015F4  2  2E 62 69 6E  
0015F8  2               fssprites1_end:
0015F8  2               tileset:
0015F8  2  10 10        	.byte 16,16
0015FA  2               tiles = 43
0015FA  2               tile_size = 256
0015FA  2  74 69 6C 65  fstile: .literal "tiles.bin"
0015FE  2  73 2E 62 69  
001602  2  6E           
001603  2               fstileend:
001603  2               
001603  1               .include "sprite.inc"
001603  2  73 70 72 69  fssprite:	.literal "sprites.bin"
001607  2  74 65 73 2E  
00160B  2  62 69 6E     
00160E  2               fsspriteend:
00160E  2               sprites = 12
00160E  2               sprite_size = 1024
00160E  2               
00160E  1               
00160E  1  00 00        default_irq_vector: .addr 0
001610  1  00           trigger_debug: .byte 0
001611  1               tiles_attributes:
001611  1  00           	.byte %00000000	;	TILE_NO_COLLISION
001612  1  07           	.byte %00000111	;	TILE_SOLID_GROUND
001613  1  04           	.byte %00000100	;	TILE_SOLD_SLOP_LEFT
001614  1  04           	.byte %00000100	;	TILE_SOLD_SLOP_RIGHT
001615  1  09           	.byte %00001001	;	TILE_SOLID_LADER
001616  1  09           	.byte %00001001	;	TILE_LEDGE
001617  1               
001617  1               .segment "BSS"
001617  1  xx           	joystick: .res 1
001618  1  xx xx xx xx  	sprites_table: .res 256		; VERA memory of each of the 256 sprites
00161C  1  xx xx xx xx  
001620  1  xx xx xx xx  
001718  1  xx xx xx xx  	player0: .tag PLAYER
00171C  1  xx xx xx xx  
001720  1  xx xx xx xx  
001718  1               
