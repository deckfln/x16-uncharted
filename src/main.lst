ca65 V2.19 - Git e4f01a2
Main file   : main.asm
Current file: main.asm

000000r 1               .org $080D
00080D  1               .segment "STARTUP"
00080D  1               .segment "INIT"
00080D  1               .segment "ONCE"
00080D  1               .segment "CODE"
00080D  1               
00080D  1  4C C0 21        jmp start
000810  1               
000810  1               .macro LOAD_r0 addr16
000810  1               	lda #<addr16
000810  1               	sta r0L
000810  1               	lda #>addr16
000810  1               	sta r0H
000810  1               .endmacro
000810  1               .macro SAVE_r0 addr16
000810  1               	lda r0L
000810  1               	sta addr16
000810  1               	lda r0H
000810  1               	sta addr16 + 1
000810  1               .endmacro
000810  1               .macro LOAD_r1 addr16
000810  1               	lda #<addr16
000810  1               	sta r1L
000810  1               	lda #>addr16
000810  1               	sta r1H
000810  1               .endmacro
000810  1               .macro LOAD_r3 addr16
000810  1               	lda #<addr16
000810  1               	sta r3L
000810  1               	lda #>addr16
000810  1               	sta r3H
000810  1               .endmacro
000810  1               
000810  1               .include "x16.inc"
000810  2               .ifndef X16_INC
000810  2               X16_INC = 1
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Commodore 64 API
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               ; Channel I/O
000810  2               SETMSG		= $FF90 ; set verbosity
000810  2               READST		= $FFB7 ; return status byte
000810  2               SETLFS		= $FFBA ; set LA, FA and SA
000810  2               SETNAM		= $FFBD ; set filename
000810  2               OPEN		= $FFC0 ; open a channel
000810  2               CLOSE		= $FFC3 ; close a channel
000810  2               CHKIN		= $FFC6 ; set channel for character input
000810  2               CHKOUT		= $FFC9 ; set channel for character output
000810  2               CLRCHN		= $FFCC ; restore character I/O to screen/keyboard
000810  2               BASIN		= $FFCF ; get character
000810  2               BSOUT		= $FFD2 ; write character
000810  2               LOAD		= $FFD5 ; load a file into memory
000810  2               SAVE		= $FFD8 ; save a file from memory
000810  2               CLALL		= $FFE7 ; close all channels
000810  2               
000810  2               ; Commodore Peripheral Bus
000810  2               TALK		= $FFB4 ; send TALK command
000810  2               LISTEN		= $FFB1 ; send LISTEN command
000810  2               UNLSN		= $FFAE ; send UNLISTEN command
000810  2               UNTLK		= $FFAB ; send UNTALK command
000810  2               IECOUT		= $FFA8 ; send byte to serial bus
000810  2               IECIN		= $FFA5 ; read byte from serial bus
000810  2               SETTMO		= $FFA2 ; set timeout
000810  2               TKSA		= $FF96 ; send TALK secondary address
000810  2               SECOND		= $FF93 ; send LISTEN secondary address
000810  2               
000810  2               ; Memory
000810  2               MEMBOT		= $FF9C ; read/write address of start of usable RAM
000810  2               MEMTOP		= $FF99 ; read/write address of end of usable RAM
000810  2               
000810  2               ; Time
000810  2               RDTIM		= $FFDE ; read system clock
000810  2               SETTIM		= $FFDB ; write system clock
000810  2               UDTIM		= $FFEA ; advance clock
000810  2               
000810  2               ; Other:
000810  2               STOP		= $FFE1 ; test for STOP key
000810  2               GETIN		= $FFE4 ; get character from keyboard
000810  2               SCREEN		= $FFED ; get the screen resolution
000810  2               PLOT		= $FFF0 ; read/write cursor position
000810  2               IOBASE		= $FFF3 ; return start of I/O area
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Commodore 128 API
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               CLOSE_ALL		= $FF4A ; close all files on a device
000810  2               LKUPLA		= $FF8D ; search tables for given LA
000810  2               LKUPSA		= $FF8A ; search tables for given SA
000810  2               DLCHR		= $FF62 ; activate a text mode font in the video hardware [not yet implemented]
000810  2               PFKEY		= $FF65 ; program a function key [not yet implemented]
000810  2               FETCH		= $FF74 ; LDA (fetvec),Y from any bank
000810  2               STASH		= $FF77 ; STA (stavec),Y to any bank
000810  2               CMPARE		= $FF7A ; CMP (cmpvec),Y to any bank
000810  2               PRIMM		= $FF7D ; print string following the callerâ€™s code
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Commander X16 API
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               ; Clock
000810  2               clock_set_date_time		= $FF4D ; set date and time
000810  2               clock_get_date_time		= $FF50 ; get date and time
000810  2               
000810  2               ; Mouse
000810  2               mouse_config			= $FF68 ; configure mouse pointer
000810  2               mouse_get				= $FF6B ; get state of mouse
000810  2               
000810  2               ; Joystick
000810  2               joystick_scan			= $FF53 ; query joysticks
000810  2               joystick_get			= $FF56 ; get state of one joystick
000810  2               
000810  2               ; Sprites
000810  2               sprite_set_image		= $FEF0 ; set the image of a sprite
000810  2               sprite_set_position		= $FEF3 ; set the position of a sprite
000810  2               
000810  2               ; Framebuffer
000810  2               FB_init					= $FEF6 ; enable graphics mode
000810  2               FB_get_info				= $FEF9 ; get screen size and color depth
000810  2               FB_set_palette			= $FEFC ; set (parts of) the palette
000810  2               FB_cursor_position		= $FEFF ; position the direct;access cursor
000810  2               FB_cursor_next_line		= $FF02 ; move direct;access cursor to next line
000810  2               FB_get_pixel			= $FF05 ; read one pixel, update cursor
000810  2               FB_get_pixels			= $FF08 ; copy pixels into RAM, update cursor
000810  2               FB_set_pixel			= $FF0B ; set one pixel, update cursor
000810  2               FB_set_pixels			= $FF0E ; copy pixels from RAM, update cursor
000810  2               FB_set_8_pixels			= $FF11 ; set 8 pixels from bit mask (transparent), update cursor
000810  2               FB_set_8_pixels_opaque	= $FF14 ; set 8 pixels from bit mask (opaque), update cursor
000810  2               FB_fill_pixels			= $FF17 ; fill pixels with constant color, update cursor
000810  2               FB_filter_pixels		= $FF1A ; apply transform to pixels, update cursor
000810  2               FB_move_pixels			= $FF1D ; copy horizontally consecutive pixels to a different position
000810  2               
000810  2               ; Graphics
000810  2               GRAPH_init				= $FF20 ; initialize graphics
000810  2               GRAPH_clear				= $FF23 ; clear screen
000810  2               GRAPH_set_window		= $FF26 ; set clipping region
000810  2               GRAPH_set_colors		= $FF29 ; set stroke, fill and background colors
000810  2               GRAPH_draw_line			= $FF2C ; draw a line
000810  2               GRAPH_draw_rect			= $FF2F ; draw a rectangle (optionally filled)
000810  2               GRAPH_move_rect			= $FF32 ; move pixels
000810  2               GRAPH_draw_oval			= $FF35 ; draw an oval or circle
000810  2               GRAPH_draw_image		= $FF38 ; draw a rectangular image
000810  2               GRAPH_set_font			= $FF3B ; set the current font
000810  2               GRAPH_get_char_size		= $FF3E ; get size and baseline of a character
000810  2               GRAPH_put_char			= $FF41 ; print a character
000810  2               
000810  2               ; Console
000810  2               CONSOLE_init					= $FEDB ; initialize console mode
000810  2               CONSOLE_put_char				= $FEDE ; print character to console
000810  2               CONSOLE_put_image				= $FED8 ; draw image as if it was a character
000810  2               CONSOLE_get_char				= $FEE1 ; get character from console
000810  2               CONSOLE_set_paging_message		= $FED5 ; set paging message or disable paging
000810  2               
000810  2               ; Other
000810  2               memory_fill				= $FEE4 ; fill memory region with a byte value
000810  2               memory_copy				= $FEE7 ; copy memory region
000810  2               memory_crc				= $FEEA ; calculate CRC16 of memory region
000810  2               memory_decompress		= $FEED ; decompress LZSA2 block
000810  2               entropy_get				= $FECF ; Get 24 random bits
000810  2               monitor					= $FF44 ; enter machine language monitor
000810  2               restore_basic			= $FF47 ; enter BASIC
000810  2               screen_set_mode			= $FF5F ; set screen mode
000810  2               screen_set_charset		= $FF62 ; activate 8x8 text mode charset
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; VRAM Addresses
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               VRAM_composer		= $F0000
000810  2               VRAM_hscale			= VRAM_composer+1
000810  2               VRAM_vscale			= VRAM_composer+2
000810  2               VRAM_palette		= $F1000
000810  2               VRAM_layer0			= $F2000
000810  2               VRAM_layer1			= $F3000
000810  2               VRAM_sprreg			= $F4000
000810  2               VRAM_sprattr		= $F5000
000810  2               VRAM_audio			= $F6000
000810  2               VRAM_spi			= $F7000
000810  2               VRAM_uart			= $F8000
000810  2               
000810  2               VROM_petscii				= $1F000
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; IRQs
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               IRQVec		= $0314
000810  2               BRKVec		= $0316
000810  2               NMIVec		= $0318
000810  2               
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Virtual registers
000810  2               ; ------------------------------------------------------------
000810  2               r0			= $02
000810  2               r0L			= $02
000810  2               r0H			= $03
000810  2               r1			= $04
000810  2               r1L			= $04
000810  2               r1H			= $05
000810  2               r2			= $06
000810  2               r2L			= $06
000810  2               r2H			= $07
000810  2               r3			= $08
000810  2               r3L			= $08
000810  2               r3H			= $09
000810  2               r4			= $0a
000810  2               r4L			= $0a
000810  2               r4H			= $0b
000810  2               r5			= $0c
000810  2               r5L			= $0c
000810  2               r5H			= $0d
000810  2               r6			= $0e
000810  2               r6L			= $0e
000810  2               r6H			= $0f
000810  2               r7			= $10
000810  2               r7L			= $10
000810  2               r7H			= $11
000810  2               r8			= $12
000810  2               r8L			= $12
000810  2               r8H			= $13
000810  2               r9			= $14
000810  2               r9L			= $14
000810  2               r9H			= $15
000810  2               r10			= $16
000810  2               r10L		= $16
000810  2               r10H		= $17
000810  2               r11			= $18
000810  2               r11L		= $18
000810  2               r11H		= $19
000810  2               r12			= $1a
000810  2               r12L		= $1a
000810  2               r12H		= $1b
000810  2               r13			= $1c
000810  2               r13L		= $1c
000810  2               r13H		= $1d
000810  2               r14			= $1e
000810  2               r14L		= $1e
000810  2               r14H		= $1f
000810  2               r15			= $20
000810  2               r15L		= $20
000810  2               r15H		= $21
000810  2               
000810  2               
000810  2               .endif
000810  2               
000810  1               .include "vera.inc"
000810  2               ; License: Public Domain
000810  2               .ifndef VERA_INC
000810  2               VERA_INC = 1
000810  2               
000810  2               verareg =$9f20
000810  2               
000810  2               veralo  		= verareg+$0
000810  2               veramid 		= verareg+$1
000810  2               verahi  		= verareg+$2
000810  2               veradat 		= verareg+$3
000810  2               veradat2		= verareg+$4
000810  2               veractl 		= verareg+$5
000810  2               veraien 		= verareg+$6
000810  2               veraisr 		= verareg+$7
000810  2               verairqlo 		= verareg+$8
000810  2               
000810  2               ; DCSEl = 0
000810  2               veradcvideo		= verareg+$9
000810  2               
000810  2               VERA_VGA		= %00000001
000810  2               VERA_LAYER0		= %00010000
000810  2               VERA_LAYER1		= %00100000
000810  2               VERA_SPRITE		= %01000000
000810  2               
000810  2               veradchscale	= verareg+$a
000810  2               veradcvscale	= verareg+$b
000810  2               veradcborder	= verareg+$c
000810  2               
000810  2               ; DCSEl = 1
000810  2               veradchstart	= verareg+$9
000810  2               veradchstop		= verareg+$a
000810  2               veradcvstart	= verareg+$b
000810  2               veradcvstop		= verareg+$c
000810  2               
000810  2               ; L0
000810  2               veral0config	= verareg+$d
000810  2               veral0mapbase	= verareg+$e
000810  2               veral0tilebase	= verareg+$f
000810  2               VERA_L0_hscrolllo	= verareg+$10
000810  2               VERA_L0_hscrollhi	= verareg+$11
000810  2               VERA_L0_vscrolllo	= verareg+$12
000810  2               VERA_L0_vscrollhi	= verareg+$13
000810  2               
000810  2               ; L1
000810  2               veral1config	= verareg+$14
000810  2               veral1mapbase	= verareg+$15
000810  2               veral1tilebase	= verareg+$16
000810  2               VERA_L1_hscrolllo	= verareg+$17
000810  2               VERA_L1_hscrollhi	= verareg+$18
000810  2               VERA_L1_vscrolllo	= verareg+$19
000810  2               VERA_L1_vscrollhi	= verareg+$1a
000810  2               
000810  2               VERA_CONFIG_CLEAR_TILES=%00001111
000810  2               VERA_CONFIG_32x32 = 	%00000000
000810  2               VERA_CONFIG_32x64 = 	%00010000
000810  2               VERA_CONFIG_32x128 = 	%00100000
000810  2               VERA_CONFIG_32x256 = 	%00110000
000810  2               VERA_CONFIG_64x32 = 	%01000000
000810  2               VERA_CONFIG_128x32 = 	%10000000
000810  2               VERA_CONFIG_256x32 = 	%11000000
000810  2               VERA_CONFIG_64x64 = 	%01010000
000810  2               VERA_CONFIG_64x128 = 	%01100000
000810  2               VERA_CONFIG_64x256 = 	%01110000
000810  2               VERA_CONFIG_128x64 = 	%10010000
000810  2               VERA_CONFIG_128x128 = 	%10100000
000810  2               VERA_CONFIG_128x256 = 	%10110000
000810  2               VERA_CONFIG_256x64 = 	%11010000
000810  2               VERA_CONFIG_256x128 = 	%11100000
000810  2               VERA_CONFIG_256x256 = 	%11110000
000810  2               
000810  2               VERA_CONFIG_CLEAR_DEPTH=%00001111
000810  2               VERA_CONFIG_1BPP	=	%00000000
000810  2               VERA_CONFIG_2BPP	=	%00000001
000810  2               VERA_CONFIG_4BPP	=	%00000010
000810  2               VERA_CONFIG_8BPP	=	%00000011
000810  2               
000810  2               VERA_CLEAR_TILE_SIZE= %11111100
000810  2               VERA_TILE_8x8 		= %00000000
000810  2               VERA_TILE_8x16 		= %00000010
000810  2               VERA_TILE_16x8 		= %00000001
000810  2               VERA_TILE_16x16 	= %00000011
000810  2               
000810  2               VERA_TILEBASE_CLEAR_ADR = %00000011
000810  2               
000810  2               ; audio
000810  2               veraaudioctl	= verareg+$1b
000810  2               veraaudiorate	= verareg+$1c
000810  2               veraaudiodata	= verareg+$1d
000810  2               veraspidata		= verareg+$1e
000810  2               veraspictl		= verareg+$1f
000810  2               
000810  2               vram_sprd  = $1fc00
000810  2               
000810  2               AUTO_INC_0 		= $000000
000810  2               AUTO_INC_1 		= $100000
000810  2               AUTO_INC_2 		= $200000
000810  2               AUTO_INC_4 		= $300000
000810  2               AUTO_INC_8 		= $400000
000810  2               AUTO_INC_16		= $500000
000810  2               AUTO_INC_32		= $600000
000810  2               AUTO_INC_64		= $700000
000810  2               AUTO_INC_128	= $800000
000810  2               AUTO_INC_256	= $900000
000810  2               AUTO_INC_512	= $A00000
000810  2               AUTO_INC_40		= $B00000
000810  2               AUTO_INC_80		= $C00000
000810  2               AUTO_INC_160	= $C00000
000810  2               AUTO_INC_320	= $E00000
000810  2               AUTO_INC_640	= $F00000
000810  2               
000810  2               SPRITE_SIZE_8	= $0
000810  2               SPRITE_SIZE_16	= $1
000810  2               SPRITE_SIZE_32	= $2
000810  2               SPRITE_SIZE_64	= $3
000810  2               
000810  2               SPRITE_ZDEPTH_DISABLED = %00000000
000810  2               SPRITE_ZDEPTH_BGto0 = %00000100
000810  2               SPRITE_ZDEPTH_0to1 = %00001000
000810  2               SPRITE_ZDEPTH_TOP = %00001100
000810  2               
000810  2               SPRITE_FLIP_CLEAR = %11111100
000810  2               SPRITE_FLIP_NONE = %00000000
000810  2               SPRITE_FLIP_H = %00000001
000810  2               SPRITE_FLIP_V = %00000010
000810  2               
000810  2               veral0mode = %00010000
000810  2               VERA_VSYNC_BIT         = $01
000810  2               VERA_LINE_BIT        = $04
000810  2               VERA_SPRCOL_BIT        = $04
000810  2               
000810  2               .macro vset addr
000810  2               	lda #0
000810  2               	sta veractl
000810  2               	lda #<(addr >> 16) | $10
000810  2               	sta verahi
000810  2               	lda #<(addr >> 8)
000810  2               	sta veramid
000810  2               	lda #<(addr)
000810  2               	sta veralo
000810  2               .endmacro
000810  2               
000810  2               .macro vset2 addr
000810  2               	lda #1
000810  2               	sta veractl
000810  2               	lda #<(addr >> 16) | $10
000810  2               	sta verahi
000810  2               	lda #<(addr >> 8)
000810  2               	sta veramid
000810  2               	lda #<(addr)
000810  2               	sta veralo
000810  2               .endmacro
000810  2               
000810  2               .macro vstore addr
000810  2               	pha
000810  2               	vset addr
000810  2               	pla
000810  2               	sta veradat
000810  2               .endmacro
000810  2               
000810  2               .macro vstore2 addr
000810  2               	pha
000810  2               	vset addr
000810  2               	pla
000810  2               	sta veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro vload addr
000810  2               	vset addr
000810  2               	lda veradat
000810  2               .endmacro
000810  2               
000810  2               .macro vload2 addr
000810  2               	vset addr
000810  2               	lda veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro sprset offset
000810  2               	lda #<(vram_sprd >> 16) | $10
000810  2               	sta verahi
000810  2               	txa
000810  2               	lsr
000810  2               	lsr
000810  2               	lsr
000810  2               	lsr
000810  2               	lsr
000810  2               	clc
000810  2               	adc #<((vram_sprd + offset) >> 8)
000810  2               	sta veramid
000810  2               	txa
000810  2               	asl
000810  2               	asl
000810  2               	asl
000810  2               	clc
000810  2               	adc #<(vram_sprd + offset)
000810  2               	sta veralo
000810  2               .endmacro
000810  2               
000810  2               .macro sprload offset
000810  2               	sprset offset
000810  2               	lda veradat
000810  2               .endmacro
000810  2               
000810  2               .macro sprload2 offset
000810  2               	sprset offset
000810  2               	lda veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro sprstore offset
000810  2               	pha
000810  2               	sprset offset
000810  2               	pla
000810  2               	sta veradat
000810  2               .endmacro
000810  2               
000810  2               .macro sprstore2 offset
000810  2               	pha
000810  2               	sprset offset
000810  2               	pla
000810  2               	sta veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro video_init
000810  2               	lda #0
000810  2               	sta veractl ; set ADDR1 active
000810  2               	sta veramid
000810  2               	lda #$1F    ; $F0000 increment 1
000810  2               	sta verahi
000810  2               	lda #$00
000810  2               	sta veralo
000810  2               	lda #1
000810  2               	sta veradat ; VGA output
000810  2               .endmacro
000810  2               
000810  2               ; set the tilebase for the layer
000810  2               .macro VTILEBASE layer,addr
000810  2                   lda veral0tilebase + layer * 7                  ; set memory for tilebase
000810  2               	and #VERA_TILEBASE_CLEAR_ADR
000810  2               	ora #(addr >> 9)
000810  2               	sta veral0tilebase + layer * 7
000810  2               .endmacro
000810  2               
000810  2               ; define size of tiles for layer
000810  2               .macro VTILEMODE layer, mode
000810  2               	lda veral0tilebase + layer * 7
000810  2               	and #VERA_CLEAR_TILE_SIZE
000810  2               	ora #mode
000810  2               	sta veral0tilebase + layer * 7
000810  2               .endmacro
000810  2               
000810  2               
000810  2               ; define number of tiles in the map
000810  2               .macro VCONFIG_TILES layer,mode
000810  2               	lda veral0config + layer * 7
000810  2               	and #VERA_CONFIG_CLEAR_TILES
000810  2               	ora #mode
000810  2               	sta veral0config + layer * 7
000810  2               .endmacro
000810  2               
000810  2               ; define number of colors for the map
000810  2               .macro VCONFIG_DEPTH layer,mode
000810  2               	lda veral0config + layer * 7
000810  2               	and #VERA_CONFIG_CLEAR_DEPTH
000810  2               	ora #mode
000810  2               	sta veral0config + layer * 7
000810  2               .endmacro
000810  2               
000810  2               ; set the mapbase for the layer
000810  2               .macro VMAPBASE layer,addr
000810  2                   lda #(addr >> 9)         ; store 2 last bits
000810  2                   sta veral0mapbase + layer * 7                   ; Store to Map Base Pointer
000810  2               .endmacro
000810  2               
000810  2               .endif
000810  2               
000810  1               
000810  1               ; VRAM Addresses
000810  1               VRAM_layer0_map   = $00000
000810  1               VRAM_layer1_map   = $00800
000810  1               VRAM_tiles        = $01000
000810  1               
000810  1               LOWMEM = $0400
000810  1               HIMEM = $a000
000810  1               
000810  1               SCREEN_WIDTH = 320
000810  1               SCREEN_HEIGHT = 240
000810  1               LEVEL_TILES_WIDTH = 32
000810  1               LEVEL_WIDTH = LEVEL_TILES_WIDTH*16
000810  1               LEVEL_HEIGHT = 32*16
000810  1               
000810  1               .enum
000810  1               	TILE_NO_COLLISION
000810  1               	TILE_SOLID_GROUND
000810  1               	TILE_SOLD_SLOP_LEFT
000810  1               	TILE_SOLD_SLOP_RIGHT
000810  1               	TILE_SOLID_LADER
000810  1               	TILE_LEDGE
000810  1               .endenum
000810  1               
000810  1               .macro SET_DEBUG
000810  1               	inc trigger_debug
000810  1               .endmacro
000810  1               
000810  1               .macro CHECK_DEBUG
000810  1               	pha
000810  1               	lda trigger_debug
000810  1               	beq @no_debug
000810  1               	dec trigger_debug
000810  1               	stp
000810  1               @no_debug:
000810  1               	pla
000810  1               .endmacro
000810  1               
000810  1               ;---------------------------------
000810  1               ; joystick management
000810  1               ;---------------------------------
000810  1               
000810  1               JOY_RIGHT 	= %00000001
000810  1               JOY_LEFT 	= %00000010
000810  1               JOY_DOWN 	= %00000100
000810  1               JOY_UP 		= %00001000
000810  1               JOY_START	= %00010000
000810  1               JOY_SEL		= %00100000
000810  1               JOY_Y		= %01000000
000810  1               JOY_B		= %10000000
000810  1               
000810  1               JOY_A		= %10000000
000810  1               
000810  1               .macro VCOPY from, to, blocks
000810  1               	LOAD_r0 from
000810  1               	LOAD_r1 (to & $00ffff)
000810  1               	ldy #(to >> 16)
000810  1               	ldx #(blocks)
000810  1               	jsr Vera::vcopy
000810  1               .endmacro
000810  1               
000810  1               ;-----------------------------------------------------------------------------
000810  1               ;/////////////////////////////////////////////////////////////////////////////
000810  1               ; START Vera code
000810  1               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000810  1               ;-----------------------------------------------------------------------------
000810  1               
000810  1  00 00        current_load: .word 0		; end of the last memory load
000812  1               
000812  1               .macro LOAD_FILE filename, length, ram
000812  1               	lda #1
000812  1               	ldx #8
000812  1               	ldy #0
000812  1               	jsr SETLFS
000812  1               	lda #length
000812  1               	ldx #<filename
000812  1               	ldy #>filename
000812  1               	jsr SETNAM
000812  1               	lda #0
000812  1               	ldx #<ram
000812  1               	ldy #>ram
000812  1               	jsr LOAD
000812  1               	stx current_load
000812  1               	sty current_load + 1
000812  1               .endmacro
000812  1               
000812  1               .macro LOAD_FILE_NEXT filename, length
000812  1               	lda #1
000812  1               	ldx #8
000812  1               	ldy #0
000812  1               	jsr SETLFS
000812  1               	lda #length
000812  1               	ldx #<filename
000812  1               	ldy #>filename
000812  1               	jsr SETNAM
000812  1               	lda #0
000812  1               	ldx current_load
000812  1               	ldy current_load + 1
000812  1               	jsr LOAD
000812  1               	stx current_load
000812  1               	sty current_load + 1
000812  1               .endmacro
000812  1               
000812  1               .scope Vera
000812  1               
000812  1  00 00        vram_load: .word 0		; end of the last memory load
000814  1               
000814  1               .macro VLOAD_FILE filename, length, vram
000814  1               	lda #1
000814  1               	ldx #8
000814  1               	ldy #0
000814  1               	jsr SETLFS
000814  1               	lda #length
000814  1               	ldx #<filename
000814  1               	ldy #>filename
000814  1               	jsr SETNAM
000814  1               	lda #(^vram + 2)
000814  1               	ldx #<vram
000814  1               	ldy #>vram
000814  1               	jsr LOAD
000814  1               	stx Vera::vram_load
000814  1               	sty Vera::vram_load + 1
000814  1               .endmacro
000814  1               
000814  1               .macro VLOAD_FILE_NEXT filename, length
000814  1               	lda #1
000814  1               	ldx #8
000814  1               	ldy #0
000814  1               	jsr SETLFS
000814  1               	lda #length
000814  1               	ldx #<filename
000814  1               	ldy #>filename
000814  1               	jsr SETNAM
000814  1               	lda #(^Vera::vram_load + 2)
000814  1               	ldx Vera::vram_load
000814  1               	ldy Vera::vram_load + 1
000814  1               	jsr LOAD
000814  1               	stx Vera::vram_load
000814  1               	sty Vera::vram_load + 1
000814  1               .endmacro
000814  1               
000814  1               ;
000814  1               ; copy from rom to vram
000814  1               ;	r0 : from
000814  1               ;	r1 : to (first 16 bites)
000814  1               ;   	y : vera bank (0, 1)
000814  1               ;	X: blocks
000814  1               ;
000814  1               vcopy:
000814  1  A9 00        	lda #0
000816  1  8D 25 9F     	sta veractl
000819  1  98           	tya
00081A  1  09 10        	ora #$10
00081C  1  8D 22 9F     	sta verahi
00081F  1  A5 05        	lda r1H
000821  1  8D 21 9F     	sta veramid
000824  1  A5 04        	lda r1L
000826  1  8D 20 9F     	sta veralo
000829  1               
000829  1               @loop:
000829  1  A0 00            ldy #0
00082B  1               @loop1tile:
00082B  1  B1 02        	lda (r0),y                         	; read from tiles data
00082D  1  8D 23 9F         sta veradat                      	; Write to VRAM with +1 Autoincrement
000830  1  C8               iny
000831  1  D0 F8            bne @loop1tile
000833  1               
000833  1  E6 03        	inc r0H
000835  1  CA           	dex
000836  1  D0 F1        	bne @loop
000838  1  60           	rts
000839  1               .endscope
000839  1               
000839  1               .include "tiles.asm"
000839  2               ;-----------------------------------------------------------------------------
000839  2               ;/////////////////////////////////////////////////////////////////////////////
000839  2               ; START Tiles code
000839  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000839  2               ;-----------------------------------------------------------------------------
000839  2               
000839  2               .enum TILE_ATTR
000839  2               	SOLID_GROUND = 1
000839  2               	SOLID_WALL = 2
000839  2               	SOLID_CEILING = 4
000839  2               	GRABBING = 8			; player can grab the tile (ladder, ledge, rope)
000839  2               .endenum
000839  2               
000839  2               
000839  2               .scope Tiles
000839  2               
000839  2               ;animated_tiles_map
000839  2               ;   nb_animated_tiles
000839  2               ;   tile[0]
000839  2               ;        tick,
000839  2               ;        nb_frames
000839  2               ;        current_frame
000839  2               ;        @frame[0][0]
000839  2               ;        nb_tiles
000839  2               ;        @addr_tiles_list[0]
000839  2               ;   tile[1]
000839  2               ;   ....
000839  2               ;   tile[nb_animated_tiles-1]
000839  2               ;   frame[t0][0]: duration, tile_index
000839  2               ;   frame[t0][1]
000839  2               ;   .....
000839  2               ;   frame[t0][ tile[0].nb_frames - 1 ]
000839  2               ;   frame[t1][0]: duration, tile_index
000839  2               ;   frame[t1][1]
000839  2               ;   .....
000839  2               ;   frame[t1][ tile[1].nb_frames - 1 ]
000839  2               ;   .....
000839  2               ;   frame[tnb_animated_tiles-1][0]
000839  2               ;   .....
000839  2               ;   frame[tnb_animated_tiles-1][ tile[nb_animated_tiles-1].nb_frames - 1 ]
000839  2               ;   addr_tiles_list[0] : tile[0].nb_tiles word
000839  2               ;   addr_tiles_list[1] : tile[1].nb_tiles word
000839  2               ;   addr_tiles_list[nb_animated_times -1] : tile[1].nb_tiles word
000839  2               
000839  2               .struct ANIMATED_TILES
000839  2                   nb_animated_tiles   .byte
000839  2               
000839  2                   .struct ANIMATED_TILE
000839  2                       tick            .byte   ; number of 18ms frames until next animation
000839  2                       nb_frames       .byte
000839  2                       current_frame   .byte
000839  2                       addr_frames  .addr   ; offset of the list of animation
000839  2                       nb_tiles        .byte   ; numner of tiles on the tilemap
000839  2                       addr_tiles_list      .addr   ; offset of the list of tiles on the tilemap
000839  2                   .endstruct
000839  2               .endstruct
000839  2               
000839  2               .struct FRAME
000839  2                   duration    .byte
000839  2                   tile_index  .byte
000839  2               .endstruct
000839  2               
000839  2               animated_tiles_map = HIMEM + $400
000839  2               animated_tiles = HIMEM + $400 + 1
000839  2               
000839  2  74 69 6C 65  fsanimated_tiles: .literal "tilesani.bin"
00083D  2  73 61 6E 69  
000841  2  2E 62 69 6E  
000845  2               fsanimated_tiles_end:
000845  2               
000845  2               ;-----------------------------------------
000845  2               ; load static tiles
000845  2               ;
000845  2               load_static:
000845  2  A9 01 A2 08  	VLOAD_FILE fstile, (fstileend-fstile), ::VRAM_tiles
000849  2  A0 00 20 BA  
00084D  2  FF A9 09 A2  
000866  2  AD 2F 9F 29  	VTILEBASE 0, ::VRAM_tiles
00086A  2  03 09 08 8D  
00086E  2  2F 9F        
000870  2  AD 36 9F 29  	VTILEBASE 1, ::VRAM_tiles
000874  2  03 09 08 8D  
000878  2  36 9F        
00087A  2  AD 2F 9F 29  	VTILEMODE 0,VERA_TILE_16x16
00087E  2  FC 09 03 8D  
000882  2  2F 9F        
000884  2  AD 36 9F 29  	VTILEMODE 1,VERA_TILE_16x16
000888  2  FC 09 03 8D  
00088C  2  36 9F        
00088E  2  60               rts
00088F  2               
00088F  2               ;-----------------------------------------
00088F  2               ; load and fix the animated tiles data
00088F  2               ;
00088F  2               load_anim:
00088F  2  A9 00        	lda #0
000891  2  85 00        	sta $00
000893  2  A9 01 A2 08  	LOAD_FILE fsanimated_tiles, (fsanimated_tiles_end-fsanimated_tiles), animated_tiles_map
000897  2  A0 00 20 BA  
00089B  2  FF A9 0C A2  
0008B4  2               
0008B4  2                   ; convert offsets in the data structure to memory addr
0008B4  2  AC 00 A4         ldy animated_tiles_map + ANIMATED_TILES::nb_animated_tiles
0008B7  2  A2 00            ldx #0
0008B9  2               
0008B9  2               @next_tile:
0008B9  2  18               clc
0008BA  2  BD 04 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames, x
0008BD  2  69 00            adc #<animated_tiles_map
0008BF  2  9D 04 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames, x
0008C2  2  BD 05 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames + 1, x
0008C5  2  69 A4            adc #>animated_tiles_map
0008C7  2  9D 05 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames + 1, x
0008CA  2               
0008CA  2  18               clc
0008CB  2  BD 07 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list, x
0008CE  2  69 00            adc #<animated_tiles_map
0008D0  2  9D 07 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list, x
0008D3  2  BD 08 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list + 1, x
0008D6  2  69 A4            adc #>animated_tiles_map
0008D8  2  9D 08 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list + 1, x
0008DB  2               
0008DB  2  88               dey
0008DC  2  F0 07            beq @convert_tileslist_addr
0008DE  2               
0008DE  2  8A               txa
0008DF  2  18               clc
0008E0  2  69 08            adc #.sizeof(ANIMATED_TILES::ANIMATED_TILE)
0008E2  2  AA               tax
0008E3  2  80 D4            bra @next_tile
0008E5  2               
0008E5  2               @convert_tileslist_addr:
0008E5  2                   ; convert tilemap offset into vera offset
0008E5  2                   ; convert offsets in the data structure to memory addr
0008E5  2  AC 00 A4         ldy animated_tiles_map + ANIMATED_TILES::nb_animated_tiles
0008E8  2  A2 00            ldx #0
0008EA  2               @next_tile1:
0008EA  2                   ; setup the listf of memory offset in vera memory
0008EA  2  BD 07 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list, x
0008ED  2  85 02            sta r0L
0008EF  2  BD 08 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list + 1, x
0008F2  2  85 03            sta r0H
0008F4  2               
0008F4  2  5A               phy
0008F5  2  DA               phx
0008F6  2  BD 06 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::nb_tiles, x
0008F9  2  AA               tax
0008FA  2  A0 00            ldy #00
0008FC  2               
0008FC  2               @loop_tiles:
0008FC  2  18               clc
0008FD  2  B1 02            lda (r0),y
0008FF  2  69 00            adc #<VRAM_layer1_map
000901  2  91 02            sta (r0),y
000903  2  C8               iny
000904  2               
000904  2  B1 02            lda (r0),y
000906  2  69 08            adc #>VRAM_layer1_map
000908  2  91 02            sta (r0),y
00090A  2  C8               iny
00090B  2               
00090B  2  CA               dex
00090C  2  D0 EE            bne @loop_tiles
00090E  2  FA               plx
00090F  2  7A               ply
000910  2               
000910  2  88               dey
000911  2  F0 07            beq @init
000913  2               
000913  2  8A               txa
000914  2  18               clc
000915  2  69 08            adc #.sizeof(ANIMATED_TILES::ANIMATED_TILE)
000917  2  AA               tax
000918  2  80 D0            bra @next_tile1
00091A  2               
00091A  2               @init:
00091A  2                   ; init the timers
00091A  2  AC 00 A4         ldy animated_tiles_map + ANIMATED_TILES::nb_animated_tiles
00091D  2  A2 00            ldx #0
00091F  2               
00091F  2               @next_tile2:
00091F  2                   ; setup the list of frames
00091F  2  BD 04 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames, x
000922  2  85 02            sta r0L
000924  2  BD 05 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames + 1, x
000927  2  85 03            sta r0H
000929  2               
000929  2                   ; save new frame duration in the timer
000929  2  B2 02            lda (r0)
00092B  2  9D 01 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::tick, x
00092E  2               
00092E  2  88               dey
00092F  2  F0 07            beq @return
000931  2               
000931  2  8A               txa
000932  2  18               clc
000933  2  69 08            adc #.sizeof(ANIMATED_TILES::ANIMATED_TILE)
000935  2  AA               tax
000936  2  80 E7            bra @next_tile2
000938  2               
000938  2               @return:
000938  2  60               rts
000939  2               
000939  2               ;-----------------------------------------
000939  2               ; parse the animated tiles to update
000939  2               ;
000939  2               animate:
000939  2  AC 00 A4         ldy animated_tiles_map + ANIMATED_TILES::nb_animated_tiles
00093C  2  A2 00            ldx #0
00093E  2               
00093E  2               @next_tile:
00093E  2  DE 01 A4         dec animated_tiles + ANIMATED_TILES::ANIMATED_TILE::tick, x
000941  2  D0 03            bne :+
000943  2  20 51 09         jsr next_frame
000946  2               :
000946  2  88               dey
000947  2  F0 07            beq @return
000949  2               
000949  2  8A               txa
00094A  2  18               clc
00094B  2  69 08            adc #.sizeof(ANIMATED_TILES::ANIMATED_TILE)
00094D  2  AA               tax
00094E  2  80 EE            bra @next_tile
000950  2               
000950  2               @return:
000950  2  60               rts
000951  2               
000951  2               ;-----------------------------------------
000951  2               ; move to the next frame of an animated tile
000951  2               ; update tiles on the tilemap
000951  2               ; input X : offset of the anim_tile structure
000951  2               ;
000951  2               next_frame:
000951  2  BD 03 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::current_frame, x
000954  2  1A               inc
000955  2  DD 02 A4         cmp animated_tiles + ANIMATED_TILES::ANIMATED_TILE::nb_frames, x
000958  2  D0 02            bne :+
00095A  2  A9 00            lda #00         ; roll back to 0
00095C  2               :
00095C  2  9D 03 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::current_frame, x
00095F  2  DA               phx
000960  2  5A               phy
000961  2               
000961  2  0A               asl         ; the are 2 bytes per frame, so multiply the index by 2
000962  2  A8               tay         ; Y = current animation frame
000963  2               
000963  2                   ; setup the list of frames
000963  2  BD 04 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames, x
000966  2  85 02            sta r0L
000968  2  BD 05 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames + 1, x
00096B  2  85 03            sta r0H
00096D  2               
00096D  2  B1 02            lda (r0), y         ; save new frame duration in the timer
00096F  2  9D 01 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::tick, x
000972  2  C8               iny
000973  2  B1 02            lda (r0), y
000975  2  85 30            sta $30                 ; X = index of the new tile to store in VERA memory
000977  2               
000977  2                   ; setup the listf of memory offset in vera memory
000977  2  BD 07 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list, x
00097A  2  85 02            sta r0L
00097C  2  BD 08 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list + 1, x
00097F  2  85 03            sta r0H
000981  2               
000981  2                   ; push all tiles in vera memory
000981  2  BD 06 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::nb_tiles, x
000984  2  0A               asl         ; number of tiles in the list * 2 (these are addr)
000985  2  3A               dec         ; start at the end
000986  2  A8               tay
000987  2               
000987  2  A6 30            ldx $30
000989  2               
000989  2               @next_tile_index:
000989  2                   ; set the vera memory (as we start from the end of the list, vera gigh is first)
000989  2               
000989  2  A9 00        	lda #0
00098B  2  8D 25 9F     	sta veractl
00098E  2  A9 02          	lda #(^VRAM_layer1_map + 2)
000990  2  8D 22 9F     	sta verahi
000993  2  B1 02            lda (r0), y
000995  2  8D 21 9F     	sta veramid	                ; vera = $1fc00 + sprite index (X) * 8
000998  2  88               dey
000999  2  B1 02            lda (r0), y
00099B  2  8D 20 9F     	sta veralo
00099E  2  88               dey
00099F  2  8E 23 9F         stx veradat
0009A2  2               
0009A2  2  10 E5            bpl @next_tile_index
0009A4  2               
0009A4  2  7A               ply
0009A5  2  FA               plx
0009A6  2  60               rts
0009A7  2               .endscope
0009A7  2               
0009A7  1               .include "sprites.asm"
0009A7  2               ;-----------------------------------------------------------------------------
0009A7  2               ;/////////////////////////////////////////////////////////////////////////////
0009A7  2               ; START Sprite code
0009A7  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
0009A7  2               ;-----------------------------------------------------------------------------
0009A7  2               
0009A7  2               .struct VSPRITE
0009A7  2               	address125 .byte
0009A7  2               	mode_xxx_address1613 .byte
0009A7  2               	x70 .byte
0009A7  2               	x98 .byte
0009A7  2               	y70 .byte
0009A7  2               	y98 .byte
0009A7  2               	collision_zdepth_vflip_hflip .byte
0009A7  2               	height_width_offset .byte
0009A7  2               .endstruct
0009A7  2               
0009A7  2               .scope Sprite
0009A7  2               
0009A7  2               SPRITES_ZP = $0070	; memory reserved for Sprites
0009A7  2               sprites_table = $0400	; VERA memory of each of the 256 sprites
0009A7  2               
0009A7  2               ;-----------------------------------------
0009A7  2               ; sprites components collections
0009A7  2               MAX_SPRITES = 32
0009A7  2               
0009A7  2  xx xx xx xx  sprites_xL: .res MAX_SPRITES
0009AB  2  xx xx xx xx  
0009AF  2  xx xx xx xx  
0009C7  2  xx xx xx xx  sprites_xH: .res MAX_SPRITES
0009CB  2  xx xx xx xx  
0009CF  2  xx xx xx xx  
0009E7  2  xx xx xx xx  sprites_yL: .res MAX_SPRITES
0009EB  2  xx xx xx xx  
0009EF  2  xx xx xx xx  
000A07  2  xx xx xx xx  sprites_yH: .res MAX_SPRITES
000A0B  2  xx xx xx xx  
000A0F  2  xx xx xx xx  
000A27  2  xx xx xx xx  sprites_x1L: .res MAX_SPRITES
000A2B  2  xx xx xx xx  
000A2F  2  xx xx xx xx  
000A47  2  xx xx xx xx  sprites_x1H: .res MAX_SPRITES
000A4B  2  xx xx xx xx  
000A4F  2  xx xx xx xx  
000A67  2  xx xx xx xx  sprites_y1L: .res MAX_SPRITES
000A6B  2  xx xx xx xx  
000A6F  2  xx xx xx xx  
000A87  2  xx xx xx xx  sprites_y1H: .res MAX_SPRITES
000A8B  2  xx xx xx xx  
000A8F  2  xx xx xx xx  
000AA7  2  xx xx xx xx  sprites_aabb_x: .res MAX_SPRITES	; collision box INSIDE the sprite top-left corner
000AAB  2  xx xx xx xx  
000AAF  2  xx xx xx xx  
000AC7  2  xx xx xx xx  sprites_aabb_y: .res MAX_SPRITES
000ACB  2  xx xx xx xx  
000ACF  2  xx xx xx xx  
000AE7  2  xx xx xx xx  sprites_aabb_w: .res MAX_SPRITES	; collision box INSIDE the sprite height/width
000AEB  2  xx xx xx xx  
000AEF  2  xx xx xx xx  
000B07  2  xx xx xx xx  sprites_aabb_h: .res MAX_SPRITES
000B0B  2  xx xx xx xx  
000B0F  2  xx xx xx xx  
000B27  2  xx xx xx xx  sprites_collision_callback: .res (MAX_SPRITES * 2)
000B2B  2  xx xx xx xx  
000B2F  2  xx xx xx xx  
000B67  2               
000B67  2  xx xx xx xx  sprites: .res 256		; store VRAM 12:5 address of each of the 128 sprites
000B6B  2  xx xx xx xx  
000B6F  2  xx xx xx xx  
000C67  2  01           nb_sprites: .byte 1		; 1 reserved for the player
000C68  2  00 00        collisions: .word 0		; L = collision happened, H = collision mask
000C6A  2               
000C6A  2               ;************************************************
000C6A  2               ;  init sprites manager
000C6A  2               ; create a table with the VERA @addr for each sprite
000C6A  2               ;
000C6A  2               init_addr_table:
000C6A  2               	; clear the sprites components
000C6A  2  A6 20        	ldx MAX_SPRITES
000C6C  2  CA           	dex
000C6D  2               :
000C6D  2  9E A7 09     	stz sprites_xL,x
000C70  2  9E C7 09     	stz sprites_xH,x
000C73  2  9E E7 09     	stz sprites_yL,x
000C76  2  9E 07 0A     	stz sprites_yH,x
000C79  2  9E E7 0A     	stz sprites_aabb_w,x
000C7C  2  9E 07 0B     	stz sprites_aabb_h,x
000C7F  2  9E A7 0A     	stz sprites_aabb_x,x
000C82  2  9E C7 0A     	stz sprites_aabb_y,x
000C85  2  CA           	dex
000C86  2  10 E5        	bpl :-
000C88  2               
000C88  2               	; activate sprite colisions
000C88  2               	;lda veraien
000C88  2               	;ora #VERA_SPRCOL_BIT
000C88  2               	;sta veraien
000C88  2               
000C88  2               	; all sprites are availble but ZERO (reserved player)
000C88  2  A2 FF        	ldx #$ff
000C8A  2               :
000C8A  2  9E 67 0B     	stz sprites,X
000C8D  2  CA           	dex
000C8E  2  D0 FA        	bne :-
000C90  2  A9 01        	lda #01
000C92  2  8D 67 0B     	sta sprites
000C95  2               
000C95  2               	; start of the sprites in VERA memory
000C95  2  A9 00        	lda #<vram_sprd
000C97  2  85 02        	sta r0L
000C99  2  A9 FC        	lda #>vram_sprd
000C9B  2  85 03        	sta r0H
000C9D  2               
000C9D  2  A2 80        	ldx #128
000C9F  2  A0 00        	ldy #0
000CA1  2                @loop:
000CA1  2  A5 03        	lda r0H
000CA3  2  99 00 04     	sta sprites_table,y
000CA6  2  C8           	iny
000CA7  2  A5 02        	lda r0L
000CA9  2  99 00 04     	sta sprites_table,y
000CAC  2  C8           	iny
000CAD  2               
000CAD  2  18           	clc
000CAE  2  A5 02        	lda r0L
000CB0  2  69 08        	adc #8
000CB2  2  85 02        	sta r0L
000CB4  2  A5 03        	lda r0H
000CB6  2  69 00        	adc #0
000CB8  2  85 03        	sta r0H	; move to next sprite
000CBA  2               
000CBA  2  CA           	dex
000CBB  2  D0 E4        	bne @loop
000CBD  2               
000CBD  2  60           	rts
000CBE  2               
000CBE  2               ;************************************************
000CBE  2               ; get a new available vera sprite
000CBE  2               ;	output: X = index of the vera sprite
000CBE  2               ;			0 = no sprite available
000CBE  2               ;
000CBE  2               new:
000CBE  2  A2 01        	ldx #$01
000CC0  2               :
000CC0  2  BD 67 0B     	lda sprites,x
000CC3  2  F0 03        	beq @return
000CC5  2  E8           	inx
000CC6  2  D0 F8        	bne :-
000CC8  2               @return:
000CC8  2  A9 01        	lda #01
000CCA  2  9D 67 0B     	sta sprites,x
000CCD  2               
000CCD  2               	; count activated sprites
000CCD  2  EC 67 0C     	cpx nb_sprites
000CD0  2  90 03        	bcc :+
000CD2  2               
000CD2  2  EE 67 0C     	inc nb_sprites
000CD5  2               :
000CD5  2  60           	rts
000CD6  2               
000CD6  2               ;
000CD6  2               ; the the VERA memory pointer to sprite Y + attribute X
000CD6  2               ;	Y = sprite index
000CD6  2               ;	X = attribute offset
000CD6  2               ;
000CD6  2               vram:
000CD6  2  DA           	phx			; save X on the stack
000CD7  2               
000CD7  2  98           	tya			; index of the sprite
000CD8  2  0A           	asl
000CD9  2  A8           	tay			; index of the address of the sprite (y*2)
000CDA  2               
000CDA  2  A9 00        	lda #0
000CDC  2  8D 25 9F     	sta veractl
000CDF  2  A9 11        	lda #<(vram_sprd >> 16) | $10
000CE1  2  8D 22 9F     	sta verahi
000CE4  2  B9 00 04     	lda sprites_table, y
000CE7  2  8D 21 9F     	sta veramid
000CEA  2  C8           	iny
000CEB  2  BA           	tsx
000CEC  2  BD 01 01     	lda $0101,x	; reload X from the stack
000CEF  2  79 00 04     	adc sprites_table, y
000CF2  2  8D 20 9F     	sta veralo	; vera = $1fc00 + sprite index (X) * 8
000CF5  2  FA           	plx
000CF6  2  60           	rts
000CF7  2               
000CF7  2               ;************************************************
000CF7  2               ; configure the sprite
000CF7  2               ;	input: 	A = sprite collision mask
000CF7  2               ;			Y = sprite index
000CF7  2               ;		   	X = sprite size :
000CF7  2               ;		   	r0 = vram @ of the sprite data
000CF7  2               ;
000CF7  2  07 0F 1F 3F  sprites_size: .byte 7, 15, 31, 63	; count byte 0 as a byte, so width is not "8" pixel nut "0" + "7" pixels
000CFB  2               
000CFB  2               load:
000CFB  2  86 70        	stx SPRITES_ZP
000CFD  2  85 72        	sta SPRITES_ZP + 2
000CFF  2  84 73        	sty SPRITES_ZP + 3
000D01  2  20 74 0D     	jsr set_bitmap
000D04  2               
000D04  2  9C 23 9F     	stz veradat					; x = 0
000D07  2  9C 23 9F     	stz veradat
000D0A  2  9C 23 9F     	stz veradat					; y = 0
000D0D  2  9C 23 9F     	stz veradat
000D10  2  A5 72        	lda SPRITES_ZP + 2			; load collision mask
000D12  2  09 00        	ora #%00000000				; collision mask + sprite = disabled + vflip=none + hflip=none
000D14  2  8D 23 9F     	sta veradat
000D17  2  A5 70        	lda SPRITES_ZP				; 32x32 sprite
000D19  2  8D 23 9F     	sta veradat
000D1C  2               
000D1C  2  4A           	lsr
000D1D  2  4A           	lsr
000D1E  2  4A           	lsr
000D1F  2  4A           	lsr
000D20  2  85 70        	sta SPRITES_ZP				; focus on sprite_height, sprite_width
000D22  2               
000D22  2  A4 73        	ldy SPRITES_ZP + 3			; sprite index
000D24  2               
000D24  2  29 03        	and #%00000011				; sprite_width
000D26  2  AA           	tax
000D27  2  BD F7 0C     	lda sprites_size,x
000D2A  2  99 E7 0A     	sta sprites_aabb_w, y		; store width in pixels in the sprite attribute
000D2D  2  A9 00        	lda #00
000D2F  2  99 A7 0A     	sta sprites_aabb_x, y		; default collision box starts (0,0)
000D32  2               
000D32  2  A5 70        	lda SPRITES_ZP
000D34  2  4A           	lsr
000D35  2  4A           	lsr							; sprite_height
000D36  2  AA           	tax
000D37  2  BD F7 0C     	lda sprites_size,x
000D3A  2  99 07 0B     	sta sprites_aabb_h, y		; store height in pixels in the sprite attribute
000D3D  2  A9 00        	lda #00
000D3F  2  99 C7 0A     	sta sprites_aabb_y, y		; default collision box starts (0,0)
000D42  2               
000D42  2  60           	rts
000D43  2               
000D43  2               ;************************************************
000D43  2               ; set the collision box of the sprite
000D43  2               ;	input y = sprite index
000D43  2               ;		r0L = top-left corner X
000D43  2               ;		r0H = top-left corner Y
000D43  2               ;		r1L = width
000D43  2               ;		r1H = height
000D43  2               ;
000D43  2               set_aabb:
000D43  2  A5 02        	lda r0L
000D45  2  99 A7 0A     	sta sprites_aabb_x,y
000D48  2  A5 03        	lda r0H
000D4A  2  99 C7 0A     	sta sprites_aabb_y,y
000D4D  2  A5 04        	lda r1L
000D4F  2  99 E7 0A     	sta sprites_aabb_w,y
000D52  2  A5 05        	lda r1H
000D54  2  99 07 0B     	sta sprites_aabb_h,y
000D57  2  60           	rts
000D58  2               
000D58  2               ;************************************************
000D58  2               ; configure full veram memory (16:0) into optimized one (12:5)
000D58  2               ;	input: r0 = vram @ of the sprite data
000D58  2               ;	output: r1
000D58  2               ;
000D58  2               vram_to_16_5:
000D58  2               	; load full VERA memory (12:0) into R0
000D58  2  A5 02        	lda r0L
000D5A  2  85 04        	sta r1L
000D5C  2  A5 03        	lda r0H
000D5E  2  85 05        	sta r1H
000D60  2               
000D60  2               	; convert full addr to vera mode (bit shiting >> 5)
000D60  2  A5 05        	lda r1H
000D62  2  4A           	lsr
000D63  2  66 04        	ror r1L
000D65  2  4A           	lsr
000D66  2  66 04        	ror r1L
000D68  2  4A           	lsr
000D69  2  66 04        	ror r1L
000D6B  2  4A           	lsr
000D6C  2  66 04        	ror r1L						; bit shift 4x 16 bits vera memory
000D6E  2  4A           	lsr
000D6F  2  66 04        	ror r1L						; bit shift 4x 16 bits vera memory
000D71  2  85 05        	sta r1H
000D73  2  60           	rts
000D74  2               
000D74  2               ;************************************************
000D74  2               ; change the address of the bitmap for the sprite
000D74  2               ;	Y = sprite index
000D74  2               ;	r0 = vera memory (12:5)
000D74  2               ;
000D74  2               set_bitmap:
000D74  2  A2 00        	ldx #VSPRITE::address125
000D76  2  20 D6 0C     	jsr vram			; set very pointer to the address of the bitmap
000D79  2               
000D79  2  A5 02        	lda r0L
000D7B  2  8D 23 9F     	sta veradat
000D7E  2  A5 03        	lda r0H
000D80  2  09 80        	ora #$80						; M = 8 bits
000D82  2  8D 23 9F     	sta veradat
000D85  2               
000D85  2  60           	rts
000D86  2               
000D86  2               ;************************************************
000D86  2               ; change the display byte for a sprite
000D86  2               ;	Y = sprite index
000D86  2               ;	X = display value to set
000D86  2               ;
000D86  2               display:
000D86  2  86 02        	stx r0L		; save X for later
000D88  2  84 03        	sty r0H
000D8A  2               
000D8A  2               	; set vram memory on the X sprite
000D8A  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000D8C  2  20 D6 0C     	jsr vram
000D8F  2  AD 23 9F     	lda veradat
000D92  2  29 F3        	and #(<~SPRITE_ZDEPTH_TOP)
000D94  2  05 02        	ora r0L
000D96  2  85 02        	sta r0L
000D98  2               
000D98  2  A4 03        	ldy r0H
000D9A  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000D9C  2  20 D6 0C     	jsr vram
000D9F  2               
000D9F  2  A5 02        	lda r0L
000DA1  2  8D 23 9F     	sta veradat
000DA4  2  60           	rts
000DA5  2               
000DA5  2               ;************************************************
000DA5  2               ; define position of sprite and recompute bounding box
000DA5  2               ;	Y = sprite index
000DA5  2               ;	r0 = addr of word X & word Y
000DA5  2               ;
000DA5  2               position:
000DA5  2               	; set vram memory on the X sprite
000DA5  2  84 70        	sty SPRITES_ZP
000DA7  2  A2 02        	ldx #VSPRITE::x70
000DA9  2  20 D6 0C     	jsr vram
000DAC  2  A6 70        	ldx SPRITES_ZP
000DAE  2               
000DAE  2  A0 00        	ldy #00
000DB0  2  BD A7 0A     	lda sprites_aabb_x, x	; X offset of the collision box
000DB3  2  F0 19        	beq @no_xoffset
000DB5  2               @xoffset:
000DB5  2  38           	sec
000DB6  2  B1 02        	lda (r0L),y
000DB8  2  9D A7 09     	sta sprites_xL, x
000DBB  2  FD A7 0A     	sbc sprites_aabb_x, x
000DBE  2  8D 23 9F     	sta veradat
000DC1  2  C8           	iny
000DC2  2  B1 02        	lda (r0L),y
000DC4  2  9D C7 09     	sta sprites_xH, x
000DC7  2  E9 00        	sbc #00
000DC9  2  8D 23 9F     	sta veradat				; X - xoffset => vera X
000DCC  2  80 11        	bra @after_xoffset
000DCE  2               @no_xoffset:
000DCE  2  B1 02        	lda (r0L),y
000DD0  2  8D 23 9F     	sta veradat
000DD3  2  9D A7 09     	sta sprites_xL, x
000DD6  2  C8           	iny
000DD7  2  B1 02        	lda (r0L),y
000DD9  2  8D 23 9F     	sta veradat
000DDC  2  9D C7 09     	sta sprites_xH, x		; X => vera X
000DDF  2               @after_xoffset:
000DDF  2               
000DDF  2  18           	clc
000DE0  2  BD A7 09     	lda sprites_xL, x
000DE3  2  7D E7 0A     	adc sprites_aabb_w, x
000DE6  2  9D 27 0A     	sta sprites_x1L, x
000DE9  2  BD C7 09     	lda sprites_xH, x
000DEC  2  69 00        	adc #0
000DEE  2  9D 47 0A     	sta sprites_x1H, x		;X1 = x + aabb.w
000DF1  2               
000DF1  2  BD C7 0A     	lda sprites_aabb_y, x	; Y offset of the collision box
000DF4  2  F0 19        	beq @no_yoffset
000DF6  2               @yoffset:
000DF6  2  38           	sec
000DF7  2  B1 02        	lda (r0L),y
000DF9  2  9D E7 09     	sta sprites_yL, x
000DFC  2  FD C7 0A     	sbc sprites_aabb_y, x
000DFF  2  8D 23 9F     	sta veradat
000E02  2  C8           	iny
000E03  2  B1 02        	lda (r0L),y
000E05  2  9D 07 0A     	sta sprites_yH, x
000E08  2  E9 00        	sbc #0
000E0A  2  8D 23 9F     	sta veradat				; Y - yoffset  => vera Y high
000E0D  2  80 12        	bra @after_yoffset
000E0F  2               @no_yoffset:
000E0F  2  C8           	iny
000E10  2  B1 02        	lda (r0L),y
000E12  2  8D 23 9F     	sta veradat
000E15  2  9D E7 09     	sta sprites_yL, x
000E18  2  C8           	iny
000E19  2  B1 02        	lda (r0L),y
000E1B  2  8D 23 9F     	sta veradat
000E1E  2  9D 07 0A     	sta sprites_yH, x		; y => vera Y
000E21  2               @after_yoffset:
000E21  2  18           	clc
000E22  2  BD E7 09     	lda sprites_yL, x
000E25  2  7D 07 0B     	adc sprites_aabb_h, x
000E28  2  9D 67 0A     	sta sprites_y1L, x
000E2B  2  BD 07 0A     	lda sprites_yH, x
000E2E  2  69 00        	adc #00
000E30  2               
000E30  2  9D 87 0A     	sta sprites_y1H, x		; Y1 = y + aabb.y + aabb.h
000E33  2               
000E33  2  60           	rts
000E34  2               
000E34  2               ;************************************************
000E34  2               ; Change the flipping of a sprite
000E34  2               ;	Y = sprite index
000E34  2               ;	A = value to set
000E34  2               ;
000E34  2               set_flip:
000E34  2  85 70        	sta SPRITES_ZP
000E36  2  84 71        	sty SPRITES_ZP + 1
000E38  2               
000E38  2               	; set vram memory on the X sprite
000E38  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000E3A  2  20 D6 0C     	jsr vram
000E3D  2               
000E3D  2  AD 23 9F     	lda veradat				;get current value
000E40  2  29 FC        	and #SPRITE_FLIP_CLEAR
000E42  2  05 70        	ora SPRITES_ZP			; change only the flip value
000E44  2  85 70        	sta SPRITES_ZP
000E46  2               
000E46  2  A4 71        	ldy SPRITES_ZP + 1
000E48  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000E4A  2  20 D6 0C     	jsr vram
000E4D  2  A5 70        	lda SPRITES_ZP
000E4F  2  8D 23 9F     	sta veradat
000E52  2  60           	rts
000E53  2               
000E53  2               ;************************************************
000E53  2               ; increase collision box by 1
000E53  2               ;	X = sprite index
000E53  2               ;
000E53  2               aabb_x_inc:
000E53  2  FE A7 09     	inc sprites_xL, x
000E56  2  D0 03        	bne :+
000E58  2  FE C7 09     	inc sprites_xH, x
000E5B  2               :
000E5B  2  FE 27 0A     	inc sprites_x1L, x
000E5E  2  D0 03        	bne :+
000E60  2  FE 47 0A     	inc sprites_x1H, x
000E63  2               :
000E63  2  60           	rts
000E64  2               
000E64  2               ;************************************************
000E64  2               ; decrease collision box by 1
000E64  2               ;	X = sprite index
000E64  2               ;
000E64  2               aabb_x_dec:
000E64  2  DE A7 09     	dec sprites_xL, x
000E67  2  BD A7 09     	lda sprites_xL, x
000E6A  2  C9 FF        	cmp #$ff
000E6C  2  D0 03        	bne :+
000E6E  2  DE C7 09     	dec sprites_xH, x
000E71  2               :
000E71  2  DE 27 0A     	dec sprites_x1L, x
000E74  2  BD 27 0A     	lda sprites_x1L, x
000E77  2  C9 FF        	cmp #$ff
000E79  2  D0 03        	bne :+
000E7B  2  DE 47 0A     	dec sprites_x1H, x
000E7E  2               :
000E7E  2  60           	rts
000E7F  2               
000E7F  2               ;************************************************
000E7F  2               ; increase collision box by 1
000E7F  2               ;	X = sprite index
000E7F  2               ;
000E7F  2               aabb_y_inc:
000E7F  2  FE E7 09     	inc sprites_yL, x
000E82  2  D0 03        	bne :+
000E84  2  FE 07 0A     	inc sprites_yH, x
000E87  2               :
000E87  2  FE 67 0A     	inc sprites_y1L, x
000E8A  2  D0 03        	bne :+
000E8C  2  FE 87 0A     	inc sprites_y1H, x
000E8F  2               :
000E8F  2  60           	rts
000E90  2               
000E90  2               ;************************************************
000E90  2               ; decrease collision box by 1
000E90  2               ;	X = sprite index
000E90  2               ;
000E90  2               aabb_y_dec:
000E90  2  DE E7 09     	dec sprites_yL, x
000E93  2  BD E7 09     	lda sprites_yL, x
000E96  2  C9 FF        	cmp #$ff
000E98  2  D0 03        	bne :+
000E9A  2  DE 07 0A     	dec sprites_yH, x
000E9D  2               :
000E9D  2  DE 67 0A     	dec sprites_y1L, x
000EA0  2  BD 67 0A     	lda sprites_y1L, x
000EA3  2  C9 FF        	cmp #$ff
000EA5  2  D0 03        	bne :+
000EA7  2  DE 87 0A     	dec sprites_y1H, x
000EAA  2               :
000EAA  2  60           	rts
000EAB  2               
000EAB  2               ;************************************************
000EAB  2               ; register sprites collision
000EAB  2               ; input: A = collision mask
000EAB  2               ;
000EAB  2               register_collision:
000EAB  2  EE 68 0C     	inc collisions
000EAE  2  8D 69 0C     	sta collisions + 1
000EB1  2  60           	rts
000EB2  2               
000EB2  2               ;************************************************
000EB2  2               ; Axis Aligned Bounding Box collision between 2 sprites
000EB2  2               ; input: X = index of sprite 1
000EB2  2               ;		 Y = index of sprite 2
000EB2  2               ; return: Z = no collision
000EB2  2               ;
000EB2  2               aabb_collision:
000EB2  2  BD C7 09     	lda sprites_xH, x
000EB5  2  D9 47 0A     	cmp sprites_x1H, y
000EB8  2  90 0C        	bcc :+				; if hi is less than, no need to test lo
000EBA  2  D0 49        	bne @false
000EBC  2               
000EBC  2  BD A7 09     	lda sprites_xL, x
000EBF  2  D9 27 0A     	cmp sprites_x1L, y
000EC2  2  90 02        	bcc :+
000EC4  2  D0 3F        	bne @false
000EC6  2               :						; s(x).left_x <= s(y).right_x
000EC6  2               
000EC6  2  B9 C7 09     	lda sprites_xH, y
000EC9  2  DD 47 0A     	cmp sprites_x1H, x
000ECC  2  90 0C        	bcc :+
000ECE  2  D0 35        	bne @false
000ED0  2               
000ED0  2  B9 A7 09     	lda sprites_xL, y
000ED3  2  DD 27 0A     	cmp sprites_x1L, x
000ED6  2  90 02        	bcc :+
000ED8  2  D0 2B        	bne @false
000EDA  2               :						; AND s(y).left_x <= s(x).right_x
000EDA  2               
000EDA  2  BD 07 0A     	lda sprites_yH, x
000EDD  2  D9 87 0A     	cmp sprites_y1H, y
000EE0  2  90 0C        	bcc :+
000EE2  2  D0 21        	bne @false
000EE4  2               
000EE4  2  BD E7 09     	lda sprites_yL, x
000EE7  2  D9 67 0A     	cmp sprites_y1L, y
000EEA  2  90 02        	bcc :+
000EEC  2  D0 17        	bne @false
000EEE  2               :						; AND s(x).bottom_y <= s(y).top_y
000EEE  2               
000EEE  2  B9 07 0A     	lda sprites_yH, y
000EF1  2  DD 87 0A     	cmp sprites_y1H, x
000EF4  2  90 0C        	bcc :+
000EF6  2  D0 0D        	bne @false
000EF8  2               
000EF8  2  B9 E7 09     	lda sprites_yL, y
000EFB  2  DD 67 0A     	cmp sprites_y1L, x
000EFE  2  90 02        	bcc :+
000F00  2  D0 03        	bne @false
000F02  2               :						; AND s(y).bottom_y <= s(x).top_y
000F02  2               
000F02  2               @true:
000F02  2  A9 01        	lda #01
000F04  2  60           	rts
000F05  2               @false:
000F05  2  A9 00        	lda #00
000F07  2  60           	rts
000F08  2               
000F08  2               ;************************************************
000F08  2               ; after a collision IRQ, test all sprites to find colliding ones
000F08  2               ; return: a = no collision
000F08  2               ;
000F08  2               find_colliding:
000F08  2  AD 67 0C     	lda nb_sprites
000F0B  2  3A           	dec
000F0C  2  85 70        	sta SPRITES_ZP
000F0E  2  3A           	dec
000F0F  2  85 71        	sta SPRITES_ZP + 1
000F11  2               
000F11  2               @inner_loop:
000F11  2  A6 70        	ldx SPRITES_ZP
000F13  2  A4 71        	ldy SPRITES_ZP + 1
000F15  2  20 B2 0E     	jsr aabb_collision
000F18  2  D0 15        	bne @found
000F1A  2               
000F1A  2  C6 71        	dec SPRITES_ZP + 1
000F1C  2  30 02        	bmi @try_next
000F1E  2  80 F1        	bra @inner_loop
000F20  2               
000F20  2               @try_next:
000F20  2  A5 70        	lda SPRITES_ZP
000F22  2  3A           	dec
000F23  2  F0 07        	beq @not_found
000F25  2  85 70        	sta SPRITES_ZP			; start comparison end - 1
000F27  2  3A           	dec						; compare with start - 1 unless < 0
000F28  2  85 71        	sta SPRITES_ZP + 1
000F2A  2  80 E5        	bra @inner_loop
000F2C  2               
000F2C  2               @not_found:
000F2C  2  A9 00        	lda #00
000F2E  2  60           	rts
000F2F  2               @found:
000F2F  2  A9 01        	lda #01
000F31  2  60           	rts
000F32  2               
000F32  2               ;************************************************
000F32  2               ; manage collisions after a collision IRQ
000F32  2               ;
000F32  2               check_irq_collision:
000F32  2  AD 68 0C     	lda collisions
000F35  2  F0 06        	beq @return
000F37  2               
000F37  2  9C 68 0C     	stz collisions		; clear the collision flag
000F3A  2               
000F3A  2  20 08 0F     	jsr find_colliding
000F3D  2               
000F3D  2               @return:
000F3D  2  60           	rts
000F3E  2               
000F3E  2               ;************************************************
000F3E  2               ; check if sprite X collides with any of the others
000F3E  2               ; input : X = sprite index to test
000F3E  2               ; return: a = index of sprite in collision or $FF if no collision
000F3E  2               ;
000F3E  2               check_collision:
000F3E  2  86 70        	stx SPRITES_ZP
000F40  2  AD 67 0C     	lda nb_sprites
000F43  2  3A           	dec
000F44  2  F0 11        	beq @no_collision		; if there is only 1 sprite, no_collision
000F46  2  A8           	tay						; start with the last sprite
000F47  2               @loop:
000F47  2  C4 70        	cpy SPRITES_ZP
000F49  2  F0 05        	beq @next				; ignore the input sprite
000F4B  2  20 B2 0E     	jsr aabb_collision
000F4E  2  D0 05        	bne @collision
000F50  2               @next:
000F50  2  88           	dey
000F51  2  30 04        	bmi @no_collision		; 0 has to be taked care off
000F53  2  80 F2        	bra @loop
000F55  2               
000F55  2               @collision:
000F55  2  98           	tya						; store index of the colliding sprite
000F56  2  60           	rts
000F57  2               
000F57  2               @no_collision:
000F57  2  A9 FF        	lda #$ff
000F59  2  60           	rts
000F5A  2               
000F5A  2               ;************************************************
000F5A  2               ; simulate a sprite movement and check collision
000F5A  2               ;	input A = vertical (1) / horizontal (2)
000F5A  2               ;			  plus (4) / minus (8)
000F5A  2               ;		  X = sprite index
000F5A  2               ; 	return: a = index of colliding sprite, $ff if no collision
000F5A  2               ;
000F5A  2               precheck_collision:
000F5A  2  85 72        	sta SPRITES_ZP + 2
000F5C  2  86 73        	stx SPRITES_ZP + 3
000F5E  2               
000F5E  2  89 01        	bit #01
000F60  2  D0 5D        	bne @vertical
000F62  2  89 08        	bit #08
000F64  2  D0 2D        	bne @horizontal_minus
000F66  2               
000F66  2               @horizontal_plus:
000F66  2               	; save current X, X1 and add the delta
000F66  2  18           	clc
000F67  2  BD A7 09     	lda sprites_xL, x
000F6A  2  85 75        	sta SPRITES_ZP + 5
000F6C  2  69 01        	adc #01
000F6E  2  9D A7 09     	sta sprites_xL, x
000F71  2               
000F71  2  BD C7 09     	lda sprites_xH, x
000F74  2  85 76        	sta SPRITES_ZP + 6
000F76  2  69 00        	adc #00
000F78  2  9D C7 09     	sta sprites_xH, x
000F7B  2               @horizontal_plus_width:
000F7B  2  18           	clc
000F7C  2  BD 27 0A     	lda sprites_x1L, x
000F7F  2  85 77        	sta SPRITES_ZP + 7
000F81  2  69 01        	adc #01
000F83  2  9D 27 0A     	sta sprites_x1L, x
000F86  2               
000F86  2  BD 47 0A     	lda sprites_x1H, x
000F89  2  85 78        	sta SPRITES_ZP + 8
000F8B  2  69 00        	adc #00
000F8D  2  9D 47 0A     	sta sprites_x1H, x
000F90  2  4C 19 10     	jmp @test
000F93  2               
000F93  2               @horizontal_minus:
000F93  2  38           	sec
000F94  2  BD A7 09     	lda sprites_xL, x
000F97  2  85 75        	sta SPRITES_ZP + 5
000F99  2  E9 01        	sbc #01
000F9B  2  9D A7 09     	sta sprites_xL, x
000F9E  2               
000F9E  2  BD C7 09     	lda sprites_xH, x
000FA1  2  85 76        	sta SPRITES_ZP + 6
000FA3  2  E9 00        	sbc #00
000FA5  2  9D C7 09     	sta sprites_xH, x
000FA8  2               @horizontal_minus_width:
000FA8  2  38           	sec
000FA9  2  BD 27 0A     	lda sprites_x1L, x
000FAC  2  85 77        	sta SPRITES_ZP + 7
000FAE  2  E9 01        	sbc #01
000FB0  2  9D 27 0A     	sta sprites_x1L, x
000FB3  2               
000FB3  2  BD 47 0A     	lda sprites_x1H, x
000FB6  2  85 78        	sta SPRITES_ZP + 8
000FB8  2  E9 00        	sbc #00
000FBA  2  9D 47 0A     	sta sprites_x1H, x
000FBD  2  80 5A        	bra @test
000FBF  2               
000FBF  2               @vertical:
000FBF  2  89 08        	bit #08
000FC1  2  D0 2C        	bne @vertical_minus
000FC3  2               @vertical_plus:
000FC3  2               	; save current Y, Y1 and add delta
000FC3  2  18           	clc
000FC4  2  BD E7 09     	lda sprites_yL, x
000FC7  2  85 75        	sta SPRITES_ZP + 5
000FC9  2  69 01        	adc #01
000FCB  2  9D E7 09     	sta sprites_yL, x
000FCE  2               
000FCE  2  BD 07 0A     	lda sprites_yH, x
000FD1  2  85 76        	sta SPRITES_ZP + 6
000FD3  2  69 00        	adc #00
000FD5  2  9D 07 0A     	sta sprites_yH, x
000FD8  2               
000FD8  2  18           	clc
000FD9  2  BD 67 0A     	lda sprites_y1L, x
000FDC  2  85 77        	sta SPRITES_ZP + 7
000FDE  2  69 01        	adc #01
000FE0  2  9D 67 0A     	sta sprites_y1L, x
000FE3  2               
000FE3  2  BD 87 0A     	lda sprites_y1H, x
000FE6  2  85 78        	sta SPRITES_ZP + 8
000FE8  2  69 00        	adc #00
000FEA  2  9D 87 0A     	sta sprites_y1H, x
000FED  2  80 2A        	bra @test
000FEF  2               @vertical_minus:
000FEF  2               	; save current Y, Y1 and add delta
000FEF  2  38           	sec
000FF0  2  BD E7 09     	lda sprites_yL, x
000FF3  2  85 75        	sta SPRITES_ZP + 5
000FF5  2  E9 01        	sbc #01
000FF7  2  9D E7 09     	sta sprites_yL, x
000FFA  2               
000FFA  2  BD 07 0A     	lda sprites_yH, x
000FFD  2  85 76        	sta SPRITES_ZP + 6
000FFF  2  E9 00        	sbc #00
001001  2  9D 07 0A     	sta sprites_yH, x
001004  2               
001004  2  38           	sec
001005  2  BD 67 0A     	lda sprites_y1L, x
001008  2  85 77        	sta SPRITES_ZP + 7
00100A  2  69 01        	adc #01
00100C  2  9D 67 0A     	sta sprites_y1L, x
00100F  2               
00100F  2  BD 87 0A     	lda sprites_y1H, x
001012  2  85 78        	sta SPRITES_ZP + 8
001014  2  E9 00        	sbc #00
001016  2  9D 87 0A     	sta sprites_y1H, x
001019  2               
001019  2               @test:
001019  2  20 3E 0F     	jsr check_collision
00101C  2  85 74        	sta SPRITES_ZP + 4		; save the result
00101E  2               
00101E  2               @restore:
00101E  2               	; and restore the data
00101E  2  A6 73        	ldx SPRITES_ZP + 3
001020  2  A5 72        	lda SPRITES_ZP + 2
001022  2  89 02        	bit #02
001024  2  F0 16        	beq @vertical_restore
001026  2               @horizontal_restore:
001026  2  A5 75        	lda SPRITES_ZP + 5
001028  2  9D A7 09     	sta sprites_xL, x
00102B  2  A5 76        	lda SPRITES_ZP + 6
00102D  2  9D C7 09     	sta sprites_xH, x
001030  2  A5 77        	lda SPRITES_ZP + 7
001032  2  9D 27 0A     	sta sprites_x1L, x
001035  2  A5 78        	lda SPRITES_ZP + 8
001037  2  9D 47 0A     	sta sprites_x1H, x
00103A  2  80 14        	bra @return
00103C  2               
00103C  2               @vertical_restore:
00103C  2  A5 75        	lda SPRITES_ZP + 5
00103E  2  9D E7 09     	sta sprites_yL, x
001041  2  A5 76        	lda SPRITES_ZP + 6
001043  2  9D 07 0A     	sta sprites_yH, x
001046  2  A5 77        	lda SPRITES_ZP + 7
001048  2  9D 67 0A     	sta sprites_y1L, x
00104B  2  A5 78        	lda SPRITES_ZP + 8
00104D  2  9D 87 0A     	sta sprites_y1H, x
001050  2               
001050  2               @return:
001050  2  A5 74        	lda SPRITES_ZP + 4	; result of the collision
001052  2  60           	rts
001053  2               
001053  2               .endscope
001053  2               
001053  1               .include "tilemap.asm"
001053  2               ;-----------------------------------------------------------------------------
001053  2               ;/////////////////////////////////////////////////////////////////////////////
001053  2               ; START Tilemap code
001053  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
001053  2               ;-----------------------------------------------------------------------------
001053  2               
001053  2               .scope Tilemap
001053  2               
001053  2               COLLISION_MAP = HIMEM
001053  2               
001053  2               ;************************************************
001053  2               ; load the layers and the collision map
001053  2               ;
001053  2               load:
001053  2               	; load tilemap into layer 0
001053  2  AD 2D 9F 29  	VCONFIG_TILES 0,VERA_CONFIG_32x32
001057  2  0F 09 00 8D  
00105B  2  2D 9F        
00105D  2  AD 2D 9F 29  	VCONFIG_DEPTH 0,VERA_CONFIG_8BPP
001061  2  0F 09 03 8D  
001065  2  2D 9F        
001067  2  A9 00 8D 2E  	VMAPBASE 0, VRAM_layer0_map
00106B  2  9F           
00106C  2  A9 01 A2 08  	VLOAD_FILE fsbackground, (fsbackground_end-fsbackground), VRAM_layer0_map
001070  2  A0 00 20 BA  
001074  2  FF A9 0B A2  
00108D  2               
00108D  2               	; load tilemap into layer 1
00108D  2  AD 34 9F 29  	VCONFIG_TILES 1,VERA_CONFIG_32x32
001091  2  0F 09 00 8D  
001095  2  34 9F        
001097  2  AD 34 9F 29  	VCONFIG_DEPTH 1,VERA_CONFIG_8BPP
00109B  2  0F 09 03 8D  
00109F  2  34 9F        
0010A1  2  A9 04 8D 35  	VMAPBASE 1, VRAM_layer1_map
0010A5  2  9F           
0010A6  2  A9 01 A2 08  	VLOAD_FILE fslevel, (fslevel_end-fslevel), VRAM_layer1_map
0010AA  2  A0 00 20 BA  
0010AE  2  FF A9 09 A2  
0010C7  2               
0010C7  2               	; load collisionmap into ram
0010C7  2  A9 00        	lda #0
0010C9  2  85 00        	sta $00
0010CB  2  A9 01 A2 08  	LOAD_FILE fscollision, (fscollision_end-fscollision), COLLISION_MAP
0010CF  2  A0 00 20 BA  
0010D3  2  FF A9 0D A2  
0010EC  2               
0010EC  2               
0010EC  2  60               rts
0010ED  2               
0010ED  2               ;************************************************
0010ED  2               ; convert (x,y) position into a collision memory address
0010ED  2               ;	input: r0  = X
0010ED  2               ;            r1 = Y
0010ED  2               ;	output : r0
0010ED  2               ;
0010ED  2               get_collision_addr:
0010ED  2  A5 02        	lda r0L
0010EF  2  29 F0        	and #%11110000
0010F1  2  0A           	asl
0010F2  2  26 03        	rol r0H
0010F4  2  85 02        	sta r0L 					; r0 = first tile of the tilemap in the row
0010F6  2               								; spriteY / 16 (convert to tile Y) * 32 (number of tiles per row in the tile map)
0010F6  2               
0010F6  2  A5 05            lda r1H
0010F8  2  4A           	lsr
0010F9  2  66 04        	ror r1L
0010FB  2  4A           	lsr
0010FC  2  66 04        	ror r1L
0010FE  2  4A           	lsr
0010FF  2  66 04        	ror r1L
001101  2  4A           	lsr
001102  2  66 04        	ror r1L
001104  2  85 05        	sta r1H 					; r1 = tile X in the row
001106  2               								; sprite X /16 (convert to tile X)
001106  2               
001106  2  18           	clc
001107  2  A5 02        	lda r0L
001109  2  65 04        	adc r1L
00110B  2  85 02        	sta r0L
00110D  2  A5 03        	lda r0H
00110F  2  65 05        	adc r1H
001111  2  85 03        	sta r0H						; r0 = tile position in the tilemap
001113  2               
001113  2  18           	clc
001114  2  A5 02        	lda r0L
001116  2  69 00        	adc #<COLLISION_MAP
001118  2  85 02        	sta r0L						; r0 = tile position in the memory tilemap
00111A  2  A5 03        	lda r0H
00111C  2  69 A0        	adc #>COLLISION_MAP
00111E  2  85 03        	sta r0H						; r0 = tile position in the memory tilemap
001120  2  60           	rts
001121  2               
001121  2               .endscope
001121  2               
001121  1               .include "entities.asm"
001121  2               ;-----------------------------------------------------------------------------
001121  2               ;/////////////////////////////////////////////////////////////////////////////
001121  2               ;           start ENTITY code
001121  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
001121  2               ;-----------------------------------------------------------------------------
001121  2               
001121  2               .struct Entity
001121  2               	id			.byte	; id of the entity
001121  2                   spriteID    .byte   ; ID of the vera sprite
001121  2               	status		.byte	; status of the player : IDLE, WALKING, CLIMBING, FALLING
001121  2               	connectedID	.byte	; EntityID connected to that one
001121  2                   levelx      .word   ; level position
001121  2                   levely      .word
001121  2               	falling_ticks .word	; ticks since the player is falling (thing t in gravity)
001121  2               	delta_x		.byte	; when driving by phisics, original delta_x value
001121  2               
001121  2               	bWidth		.byte	; widht in pixel of the entity
001121  2               	bHeight		.byte	; Height in pixel of the entity
001121  2               	bFlags		.byte	; position of the entity was changed
001121  2               	bXOffset	.byte	; signed offset of the top-left corder of the sprite vs the collision box
001121  2               	bYOffset	.byte	;
001121  2               	collision_addr	.addr	; cached @ of the collision equivalent of the center of the player
001121  2               	fnBind		.addr	; virtual function 'bind' (connect 2 entites together)
001121  2               	fnUnbind	.addr	; virtual function 'unbind' (disconnect 2 entities)
001121  2               	fnMoveRight	.addr	; virtual function move_right
001121  2               	fnMoveLeft	.addr	; virtual function move_left
001121  2               .endstruct
001121  2               
001121  2               .enum EntityFlags
001121  2               	physics = 1
001121  2               	moved = 2
001121  2               	colission_map_changed = 4
001121  2               .endenum
001121  2               
001121  2               
001121  2               .scope Entities
001121  2               
001121  2               MAX_ENTITIES = 16
001121  2               ENTITY_ZP = $0065
001121  2               
001121  2               bSaveX = ENTITY_ZP + 3
001121  2               bSide2test = ENTITY_ZP + 4
001121  2               
001121  2               ; pixel size converted to tiles size
001121  2               bTilesWidth = ENTITY_ZP + 5
001121  2               bTilesHeight = ENTITY_ZP + 6
001121  2               
001121  2               bInLoop = ENTITY_ZP + 8
001121  2               bSlopX_delta = $30
001121  2               
001121  2               ; global variable to mark slope for the current entity
001121  2               bPlayerOnSlop = ENTITY_ZP + 7
001121  2               
001121  2               ; number of tiles an entity covers (based on the collision box height and width)
001121  2               bTilesCoveredX = r1L
001121  2               bTilesCoveredY = r1H
001121  2               
001121  2               ; if TRUE do a simple tile based collision (0 = no collision)
001121  2               bBasicCollisionTest = ENTITY_ZP + 9
001121  2               
001121  2               ; pointers to entites
001121  2               indexLO = $0600
001121  2               indexHI = indexLO + MAX_ENTITIES
001121  2               indexUse = indexHI + MAX_ENTITIES
001121  2               
001121  2               ; space to save entities position
001121  2               save_position_xL = indexUse + MAX_ENTITIES
001121  2               save_position_xH = save_position_xL + MAX_ENTITIES
001121  2               save_position_yL = save_position_xH + MAX_ENTITIES
001121  2               save_position_yH = save_position_yL + MAX_ENTITIES
001121  2               
001121  2               ;************************************************
001121  2               ; init the Entities modules
001121  2               ;
001121  2               initModule:
001121  2  64 6E        	stz bBasicCollisionTest
001123  2  A9 00        	lda #00
001125  2  A0 10        	ldy #MAX_ENTITIES
001127  2  A2 00        	ldx #00
001129  2               @loop:
001129  2  9D 00 06     	sta indexLO,x
00112C  2  9D 10 06     	sta indexHI,x
00112F  2  9D 20 06     	sta indexUse,x
001132  2  E8           	inx
001133  2  88           	dey
001134  2  D0 F3        	bne @loop
001136  2  60           	rts
001137  2               
001137  2               ;************************************************
001137  2               ; add an entity
001137  2               ;   input: a = lo-byte of entity address
001137  2               ;		   y = hi-byte
001137  2               ;			x = entityID
001137  2               register:
001137  2               	.ifdef DEBUG
001137  2               	cpx .sizeof(indexLO)
001137  2               	bcs :+
001137  2               	stp				; detect out of bound
001137  2               :
001137  2               	.endif
001137  2  9D 00 06     	sta indexLO,x
00113A  2  98           	tya
00113B  2  9D 10 06     	sta indexHI,x
00113E  2               
00113E  2  A9 01        	lda #01
001140  2  9D 20 06     	sta indexUse,x	; entitie is activate
001143  2  60           	rts
001144  2               
001144  2               ;************************************************
001144  2               ; init all attributes of an entity
001144  2               ;   input: X = entityID
001144  2               ;	output: r3 = entity address
001144  2               ;
001144  2               get_pointer:
001144  2               	.ifdef DEBUG
001144  2               	cpx .sizeof(indexLO)
001144  2               	bcs :+
001144  2               	stp				; detect out of bound
001144  2               :
001144  2               	lda indexUse, x
001144  2               	bne :+
001144  2               	stp				; detect inactive entities
001144  2               :
001144  2               	.endif
001144  2  BD 00 06     	lda indexLO, x
001147  2  85 08        	sta r3
001149  2  BD 10 06     	lda indexHI, x
00114C  2  85 08        	sta r3
00114E  2  60           	rts
00114F  2               
00114F  2               ;************************************************
00114F  2               ; init all attributes of an entity
00114F  2               ;   input: X = entityID
00114F  2               ;
00114F  2               initIndex:
00114F  2               	.ifdef DEBUG
00114F  2               	cpx .sizeof(indexLO)
00114F  2               	bcs :+
00114F  2               	stp				; detect out of bound
00114F  2               :
00114F  2               	lda indexUse, x
00114F  2               	bne :+
00114F  2               	stp				; detect inactive entities
00114F  2               :
00114F  2               	.endif
00114F  2  BD 00 06     	lda indexLO, x
001152  2  85 08        	sta r3
001154  2  BD 10 06     	lda indexHI, x
001157  2  85 08        	sta r3
001159  2               
001159  2               	; pass through
001159  2               
001159  2               ;************************************************
001159  2               ; init all attributes of an entity
001159  2               ;   input: R3 = start of the object
001159  2               ;
001159  2               init:
001159  2               	.ifdef DEBUG
001159  2               	cmp r3H
001159  2               	bne :+
001159  2               	cmp r3L
001159  2               	bne :+
001159  2               
001159  2               	stp				; detect NULL pointer
001159  2               :
001159  2               	.endif
001159  2               
001159  2  A9 00            lda #00
00115B  2  A0 01            ldy #Entity::spriteID
00115D  2  91 08        	sta (r3), y
00115F  2  A0 02            ldy #Entity::status
001161  2  A9 00        	lda #STATUS_WALKING_IDLE
001163  2  91 08        	sta (r3), y
001165  2  A9 FF            lda #$ff
001167  2  A0 03            ldy #Entity::connectedID
001169  2  91 08        	sta (r3), y
00116B  2  A9 00            lda #00
00116D  2  A0 08            ldy #Entity::falling_ticks
00116F  2  91 08        	sta (r3),y
001171  2  C8               iny
001172  2  91 08        	sta (r3),y
001174  2  C8               iny
001175  2  91 08        	sta (r3),y 	; delta_x
001177  2  A0 04            ldy #Entity::levelx
001179  2  91 08        	sta (r3),y
00117B  2  C8               iny
00117C  2  91 08        	sta (r3),y
00117E  2  A0 06            ldy #Entity::levely
001180  2  91 08        	sta (r3),y
001182  2  C8               iny
001183  2  91 08        	sta (r3),y
001185  2  A9 01        	lda #01
001187  2  A0 0D        	ldy #Entity::bFlags
001189  2  A9 07        	lda #(EntityFlags::physics | EntityFlags::moved | EntityFlags::colission_map_changed)
00118B  2  91 08        	sta (r3),y	; force screen position and size to be recomputed
00118D  2               
00118D  2               	; register virtual function bind/unbind
00118D  2  A0 12        	ldy #Entity::fnBind
00118F  2  A9 EC        	lda #<Entities::bind
001191  2  91 08        	sta (r3),y
001193  2  C8           	iny
001194  2  A9 17        	lda #>Entities::bind
001196  2  91 08        	sta (r3),y
001198  2  C8           	iny
001199  2  A9 18        	lda #>Entities::unbind
00119B  2  91 08        	sta (r3),y
00119D  2  C8           	iny
00119E  2  A9 18        	lda #>Entities::unbind
0011A0  2  91 08        	sta (r3),y
0011A2  2  60               rts
0011A3  2               
0011A3  2               ;************************************************
0011A3  2               ; change  position of the sprite (level view) => (screen view)
0011A3  2               ;   input: R3 = start of the object
0011A3  2               ;
0011A3  2               set_position:
0011A3  2  84 65        	sty ENTITY_ZP			; save Y
0011A5  2               
0011A5  2                   ; screenX = levelX - layer1_scroll_x
0011A5  2  A0 04            ldy #Entity::levelx
0011A7  2  38               sec
0011A8  2  B1 08            lda (r3), y
0011AA  2  ED 37 9F         sbc VERA_L1_hscrolllo
0011AD  2  85 04            sta r1L
0011AF  2  C8               iny
0011B0  2  B1 08            lda (r3), y
0011B2  2  ED 38 9F         sbc VERA_L1_hscrolllo + 1
0011B5  2  85 05            sta r1H
0011B7  2               
0011B7  2                   ; screenY = levelY - layer1_scroll_y
0011B7  2  A0 06            ldy #Entity::levely
0011B9  2  38               sec
0011BA  2  B1 08            lda (r3), y
0011BC  2  ED 39 9F         sbc VERA_L1_vscrolllo
0011BF  2  85 06            sta r2L
0011C1  2  C8               iny
0011C2  2  B1 08            lda (r3), y
0011C4  2  ED 3A 9F         sbc VERA_L1_vscrolllo + 1
0011C7  2  85 07            sta r2H
0011C9  2               
0011C9  2                   ; get the sprite ID
0011C9  2  A0 01        	ldy #Entity::spriteID
0011CB  2  B1 08        	lda (r3),y                      ; sprite id
0011CD  2  A8               tay
0011CE  2               
0011CE  2                   ; adresse of the and px, py attributes
0011CE  2  A9 04        	lda #<r1L
0011D0  2  85 02            sta r0L
0011D2  2  A9 00        	lda #>r1L
0011D4  2  85 03            sta r0H
0011D6  2  20 A5 0D     	jsr Sprite::position			; set position of the sprite
0011D9  2               
0011D9  2  A0 0D        	ldy #Entity::bFlags
0011DB  2  B1 08        	lda (r3), y
0011DD  2  29 FD        	and #(255 - EntityFlags::moved)
0011DF  2  91 08        	sta (r3), y  		; clear the refresh flag
0011E1  2               
0011E1  2               @return:
0011E1  2  A4 65        	ldy ENTITY_ZP		; restore Y
0011E3  2  60               rts
0011E4  2               
0011E4  2               ;************************************************
0011E4  2               ; recompute the collision map address of the entity
0011E4  2               ;   input: R3 = start of the object
0011E4  2               ;   output: r0 = address on the collision map
0011E4  2               ;
0011E4  2               get_collision_map:
0011E4  2  A0 0D        	ldy #Entity::bFlags
0011E6  2  B1 08        	lda (r3),y
0011E8  2  89 04        	bit #EntityFlags::colission_map_changed
0011EA  2  D0 0C        	bne @update_addr
0011EC  2               
0011EC  2               	; cache the collision @
0011EC  2  A0 10        	ldy #Entity::collision_addr
0011EE  2  B1 08        	lda (r3),y
0011F0  2  85 02        	sta r0L
0011F2  2  C8           	iny
0011F3  2  B1 08        	lda (r3),y
0011F5  2  85 03        	sta r0H
0011F7  2               
0011F7  2  60           	rts
0011F8  2               
0011F8  2               @update_addr:
0011F8  2  A0 06        	ldy #Entity::levely
0011FA  2  B1 08        	lda (r3),y
0011FC  2  85 02        	sta r0L
0011FE  2  C8           	iny
0011FF  2  B1 08        	lda (r3),y
001201  2  85 03        	sta r0H								; r0 = sprite absolute position Y in the level
001203  2               
001203  2  A0 04        	ldy #Entity::levelx
001205  2  B1 08        	lda (r3),y
001207  2  85 04        	sta r1L
001209  2  C8           	iny
00120A  2  B1 08        	lda (r3),y
00120C  2  85 05        	sta r1H								; r1 = sprite absolute position X in the level
00120E  2               
00120E  2  20 ED 10     	jsr Tilemap::get_collision_addr		; update the collision address
001211  2               
001211  2               	; cache the collision @
001211  2  A0 10        	ldy #Entity::collision_addr
001213  2  A5 02        	lda r0L
001215  2  91 08        	sta (r3),y
001217  2  C8           	iny
001218  2  A5 03        	lda r0H
00121A  2  91 08        	sta (r3),y
00121C  2               
00121C  2  A0 0D        	ldy #Entity::bFlags
00121E  2  B1 08        	lda (r3), y
001220  2  29 FB        	and #(255 - EntityFlags::colission_map_changed)
001222  2  91 08        	sta (r3), y  						; clear the refresh flag
001224  2  60           	rts
001225  2               
001225  2               ;************************************************
001225  2               ; update all entities screen position (when the object was moved, when the layer was moved)
001225  2               ;
001225  2               update:
001225  2  A2 00        	ldx #00
001227  2               
001227  2               @loop:
001227  2  BD 20 06     	lda indexUse,x
00122A  2  F0 23        	beq @next
00122C  2               
00122C  2  BD 10 06     	lda indexHI,x
00122F  2  85 09        	sta r3H
001231  2  BD 00 06     	lda indexLO,x
001234  2  85 08        	sta r3L
001236  2               
001236  2  A0 0D        	ldy #Entity::bFlags
001238  2  B1 08        	lda (r3),y
00123A  2  89 01        	bit #EntityFlags::physics
00123C  2  F0 03        	beq :+			; nothing to do
00123E  2  20 7F 15     	jsr physics
001241  2               
001241  2               :
001241  2  A0 0D        	ldy #Entity::bFlags
001243  2  B1 08        	lda (r3),y
001245  2  89 02        	bit #EntityFlags::moved
001247  2  F0 06        	beq @next			; nothing to do
001249  2  20 A3 11     	jsr Entities::set_position
00124C  2  20 E4 11     	jsr Entities::get_collision_map
00124F  2               @next:
00124F  2  E8           	inx
001250  2  E0 10        	cpx #MAX_ENTITIES
001252  2  D0 D3            bne @loop
001254  2               
001254  2               @return:
001254  2  60               rts
001255  2               
001255  2               ;************************************************
001255  2               ; change screen position of all entities when the layer moves (level view) => (screen view)
001255  2               ;
001255  2               fix_positions:
001255  2  A2 00        	ldx #00
001257  2               
001257  2               @loop:
001257  2  BD 20 06     	lda indexUse,x
00125A  2  F0 10        	beq @next
00125C  2               
00125C  2  BD 10 06     	lda indexHI,x
00125F  2  85 09        	sta r3H
001261  2  BD 00 06     	lda indexLO,x
001264  2  85 08        	sta r3L
001266  2               
001266  2  20 A3 11         jsr Entities::set_position
001269  2  20 E4 11     	jsr Entities::get_collision_map
00126C  2               
00126C  2               @next:
00126C  2  E8           	inx
00126D  2  E0 10        	cpx #MAX_ENTITIES
00126F  2  D0 E6            bne @loop
001271  2               
001271  2               @return:
001271  2  60               rts
001272  2               
001272  2               ;************************************************
001272  2               ; save the current position if restore is needed
001272  2               ;   input: X = entity ID
001272  2               ;
001272  2               save_position:
001272  2  BD 10 06     	lda indexHI,x
001275  2  85 09        	sta r3H
001277  2  BD 00 06     	lda indexLO,x
00127A  2  85 08        	sta r3L
00127C  2               
00127C  2  A0 04        	ldy #Entity::levelx
00127E  2  B1 08        	lda (r3), y
001280  2  9D 30 06     	sta save_position_xL,x
001283  2  C8           	iny
001284  2  B1 08        	lda (r3), y
001286  2  9D 40 06     	sta save_position_xH,x
001289  2  C8           	iny
00128A  2  B1 08        	lda (r3), y
00128C  2  9D 50 06     	sta save_position_yL,x
00128F  2  C8           	iny
001290  2  B1 08        	lda (r3), y
001292  2  9D 60 06     	sta save_position_yH,x
001295  2               
001295  2               	; keep the dirty flags
001295  2  60           	rts
001296  2               
001296  2               ;************************************************
001296  2               ; restore the current position
001296  2               ;   input: X = entity ID
001296  2               ;
001296  2               restore_position:
001296  2  BD 10 06     	lda indexHI,x
001299  2  85 09        	sta r3H
00129B  2  BD 00 06     	lda indexLO,x
00129E  2  85 08        	sta r3L
0012A0  2               
0012A0  2  A0 04        	ldy #Entity::levelx
0012A2  2  BD 30 06     	lda save_position_xL,x
0012A5  2  91 08        	sta (r3), y
0012A7  2  C8           	iny
0012A8  2  BD 40 06     	lda save_position_xH,x
0012AB  2  91 08        	sta (r3), y
0012AD  2  C8           	iny
0012AE  2  BD 50 06     	lda save_position_yL,x
0012B1  2  91 08        	sta (r3), y
0012B3  2  C8           	iny
0012B4  2  BD 60 06     	lda save_position_yH,x
0012B7  2  91 08        	sta (r3), y
0012B9  2               
0012B9  2               	; force to recompute the collision map
0012B9  2  A0 0D        	ldy #Entity::bFlags
0012BB  2  B1 08        	lda (r3), y  						; set the refresh bits
0012BD  2  09 06        	ora #(EntityFlags::moved |EntityFlags::colission_map_changed)
0012BF  2  91 08        	sta (r3), y
0012C1  2               
0012C1  2  60           	rts
0012C2  2               
0012C2  2               ;************************************************
0012C2  2               ; increase entity X position
0012C2  2               ;   input: R3 = start of the object
0012C2  2               ;
0012C2  2               position_x_inc:
0012C2  2               	; move the absolute position levelx + 1
0012C2  2  A0 04        	ldy #Entity::levelx
0012C4  2  B1 08            lda (r3),y
0012C6  2  1A               inc
0012C7  2  91 08            sta (r3),y
0012C9  2  D0 06            bne :+
0012CB  2  C8               iny
0012CC  2  B1 08            lda (r3),y
0012CE  2  1A               inc
0012CF  2  91 08            sta (r3),y
0012D1  2               :
0012D1  2  A0 0D        	ldy #Entity::bFlags
0012D3  2  B1 08        	lda (r3), y  						; set the refresh bits
0012D5  2  09 06        	ora #(EntityFlags::moved | EntityFlags::colission_map_changed)
0012D7  2  91 08        	sta (r3), y
0012D9  2               
0012D9  2  A0 01        	ldy #Entity::spriteID
0012DB  2  B1 08        	lda (r3),y
0012DD  2  AA           	tax
0012DE  2  20 53 0E     	jsr Sprite::aabb_x_inc
0012E1  2  60           	rts
0012E2  2               
0012E2  2               ;************************************************
0012E2  2               ; decrease entity X position
0012E2  2               ;   input: R3 = start of the object
0012E2  2               ;
0012E2  2               position_x_dec:
0012E2  2  A0 04        	ldy #Entity::levelx
0012E4  2  B1 08            lda (r3),y
0012E6  2  3A               dec
0012E7  2  91 08            sta (r3),y
0012E9  2  C9 FF            cmp #$ff
0012EB  2  D0 06            bne :+
0012ED  2  C8               iny
0012EE  2  B1 08            lda (r3),y
0012F0  2  3A               dec
0012F1  2  91 08            sta (r3),y
0012F3  2               :
0012F3  2  A0 0D        	ldy #Entity::bFlags
0012F5  2  B1 08        	lda (r3), y  						; set the refresh bits
0012F7  2  09 06        	ora #(EntityFlags::moved | EntityFlags::colission_map_changed)
0012F9  2  91 08        	sta (r3), y
0012FB  2               
0012FB  2  A0 01        	ldy #Entity::spriteID
0012FD  2  B1 08        	lda (r3),y
0012FF  2  AA           	tax
001300  2  20 64 0E     	jsr Sprite::aabb_x_dec
001303  2               
001303  2  60           	rts
001304  2               
001304  2               ;************************************************
001304  2               ; increase entity Y position
001304  2               ;   input: R3 = start of the object
001304  2               ;
001304  2               position_y_inc:
001304  2               	; move the absolute position levelx + 1
001304  2  A0 06        	ldy #Entity::levely
001306  2  B1 08            lda (r3),y
001308  2  1A               inc
001309  2  91 08            sta (r3),y
00130B  2  D0 06            bne :+
00130D  2  C8               iny
00130E  2  B1 08            lda (r3),y
001310  2  1A               inc
001311  2  91 08            sta (r3),y
001313  2               :
001313  2  A0 0D        	ldy #Entity::bFlags
001315  2  B1 08        	lda (r3), y  						; set the refresh bits
001317  2  09 06        	ora #(EntityFlags::moved | EntityFlags::colission_map_changed)
001319  2  91 08        	sta (r3), y
00131B  2               
00131B  2  A0 01        	ldy #Entity::spriteID
00131D  2  B1 08        	lda (r3),y
00131F  2  AA           	tax
001320  2  20 7F 0E     	jsr Sprite::aabb_y_inc
001323  2               
001323  2  60           	rts
001324  2               
001324  2               ;************************************************
001324  2               ; decrease entity X position
001324  2               ;   input: R3 = start of the object
001324  2               ;
001324  2               position_y_dec:
001324  2  A0 06        	ldy #Entity::levely
001326  2  B1 08            lda (r3),y
001328  2  3A               dec
001329  2  91 08            sta (r3),y
00132B  2  C9 FF            cmp #$ff
00132D  2  D0 06            bne :+
00132F  2  C8               iny
001330  2  B1 08            lda (r3),y
001332  2  3A               dec
001333  2  91 08            sta (r3),y
001335  2               :
001335  2  A0 0D        	ldy #Entity::bFlags
001337  2  B1 08        	lda (r3), y  						; set the refresh bits
001339  2  09 06        	ora #(EntityFlags::moved | EntityFlags::colission_map_changed)
00133B  2  91 08        	sta (r3), y
00133D  2               
00133D  2  A0 01        	ldy #Entity::spriteID
00133F  2  B1 08        	lda (r3),y
001341  2  AA           	tax
001342  2  20 90 0E     	jsr Sprite::aabb_y_dec
001345  2               
001345  2  60           	rts
001346  2               
001346  2               ;************************************************
001346  2               ;	compute the number of tiles covered by the boundingbox
001346  2               ; input: r3 pointer to entity
001346  2               ; output: r1L : number of tiles height
001346  2               ;			X = r1H : number of tiles width
001346  2               ;			Y = r2L : index of the first tile to test
001346  2               ;				r2H : size of object in tile coordinated
001346  2               								; 8 pixels => + 0 byte
001346  2               								; 16 pixels => + 1 byte
001346  2               								; 32 pixels => + 2 bytes
001346  2               								; 64 pixels => + 4 bytes
001346  2               
001346  2               bbox_coverage:
001346  2  A0 0B        	ldy #Entity::bWidth
001348  2  B1 08        	lda (r3),y
00134A  2  C9 10        	cmp #16
00134C  2  D0 04        	bne :+
00134E  2  A9 01        	lda #01
001350  2  80 0A        	bra @width
001352  2               :
001352  2  C9 20        	cmp #32
001354  2  D0 04        	bne :+
001356  2  A9 02        	lda #02
001358  2  80 02        	bra @width
00135A  2               :
00135A  2  A9 00        	lda #00
00135C  2               
00135C  2               @width:
00135C  2  85 6A        	sta bTilesWidth
00135E  2               
00135E  2               	; X = how many column of tiles to test
00135E  2  A0 04            ldy #Entity::levelx
001360  2  B1 08        	lda (r3),y
001362  2  29 0F        	and #%00001111
001364  2  F0 0B        	beq @one_tile
001366  2               @two_tiles_right:
001366  2  A6 6A        	ldx bTilesWidth						; test 2 column ( y % 16 <> 0)
001368  2  E8           	inx
001369  2  86 04        	stx bTilesCoveredX
00136B  2  A0 00        	ldy #00								; starting on row +1
00136D  2  84 06        	sty r2L
00136F  2  80 08        	bra @test_lines
001371  2               @one_tile:
001371  2  A6 6A        	ldx bTilesWidth						; test 1 column ( y % 16  == 8)
001373  2  86 04        	stx bTilesCoveredX
001375  2  A0 00        	ldy #00								; starting on row +1
001377  2  84 06        	sty r2L
001379  2               
001379  2               @test_lines:
001379  2  A0 0C        	ldy #Entity::bHeight
00137B  2  B1 08        	lda (r3),y
00137D  2  C9 10        	cmp #16
00137F  2  D0 04        	bne :+
001381  2  A9 01        	lda #01
001383  2  80 0A        	bra @height
001385  2               :
001385  2  C9 20        	cmp #32
001387  2  D0 04        	bne :+
001389  2  A9 02        	lda #02
00138B  2  80 02        	bra @height
00138D  2               :
00138D  2  A9 00        	lda #00
00138F  2               @height:
00138F  2  85 6B        	sta bTilesHeight
001391  2               
001391  2  A0 06            ldy #Entity::levely
001393  2  B1 08        	lda (r3),y
001395  2  29 0F        	and #%00001111
001397  2  D0 05        	bne @yfloat				; if player is not on a multiple of 16 (tile size)
001399  2               @yint:
001399  2  A5 6B        	lda bTilesHeight		; test 2 lines ( y % 16 == 0)
00139B  2  85 05        	sta bTilesCoveredY
00139D  2  60           	rts
00139E  2               @yfloat:
00139E  2  A5 6B        	lda bTilesHeight
0013A0  2  1A           	inc
0013A1  2  85 05        	sta bTilesCoveredY
0013A3  2  60           	rts
0013A4  2               
0013A4  2               ;************************************************
0013A4  2               ; check collision on the height
0013A4  2               ; input: r3 pointer to entity
0013A4  2               ; return:;	A = vaule of the collision
0013A4  2               ;	        ZERO = no collision
0013A4  2               ;
0013A4  2               if_collision_tile_height:
0013A4  2  A0 10            ldy #Entity::collision_addr
0013A6  2  B1 08        	lda (r3),y
0013A8  2  85 02        	sta r0L
0013AA  2  C8               iny
0013AB  2  B1 08        	lda (r3),y
0013AD  2  85 03        	sta r0H
0013AF  2               
0013AF  2               	; only tiles test if we are on a tile edge
0013AF  2  A0 04            ldy #Entity::levelx
0013B1  2  B1 08        	lda (r3),y
0013B3  2  29 0F        	and #%00001111
0013B5  2  D0 40        	bne @no_collision
0013B7  2               
0013B7  2  20 46 13     	jsr bbox_coverage
0013BA  2  A6 05        	ldx bTilesCoveredY				; tiles height
0013BC  2  A5 69        	lda bSide2test
0013BE  2  10 11        	bpl @right
0013C0  2               
0013C0  2               @left:
0013C0  2               	; check one tile on the left
0013C0  2  38           	sec
0013C1  2  A5 02        	lda r0L
0013C3  2  E9 01        	sbc #01
0013C5  2  85 02        	sta r0L
0013C7  2  A5 03        	lda r0H
0013C9  2  E9 00        	sbc #00
0013CB  2  85 03        	sta r0H
0013CD  2  A0 00        	ldy #00
0013CF  2  80 03        	bra @test_line
0013D1  2               
0013D1  2               @right:
0013D1  2  A5 6A        	lda bTilesWidth
0013D3  2  A8           	tay					; test x(tile) + bTlesWidth
0013D4  2               
0013D4  2               @test_line:
0013D4  2  B1 02        	lda (r0L),y
0013D6  2  F0 15        	beq @test_next_line
0013D8  2               
0013D8  2  84 30        	sty $30
0013DA  2  A4 6E        	ldy bBasicCollisionTest			; if basic collision, any tilemap<>0 is a collision
0013DC  2  D0 08        	bne @collision
0013DE  2  A8           	tay
0013DF  2  B9 1F 23     	lda tiles_attributes,y
0013E2  2  89 02        	bit #TILE_ATTR::SOLID_WALL
0013E4  2  F0 05        	beq @test_next_line1			; else check the tilemap attributes
0013E6  2               @collision:
0013E6  2  A4 30        	ldy $30
0013E8  2  B1 02        	lda (r0L),y
0013EA  2  60           	rts
0013EB  2               
0013EB  2               @test_next_line1:
0013EB  2  A4 30        	ldy $30
0013ED  2               
0013ED  2               @test_next_line:
0013ED  2  CA           	dex
0013EE  2  F0 07        	beq @no_collision
0013F0  2  98           	tya
0013F1  2  18           	clc
0013F2  2  69 20        	adc #LEVEL_TILES_WIDTH			; test the tile on the right of the player (hip position)
0013F4  2  A8           	tay
0013F5  2  80 DD        	bra @test_line					; LADDERS can be traversed
0013F7  2               
0013F7  2               @no_collision:						; force a no collision
0013F7  2  A9 00        	lda #00
0013F9  2               @return:
0013F9  2  60           	rts
0013FA  2               
0013FA  2               ;************************************************
0013FA  2               ; check collision on the right
0013FA  2               ; input: r3 pointer to entity
0013FA  2               ; output: A = value of the collision, or 00/01 for sprites
0013FA  2               ;			ZERO = no collision
0013FA  2               ;
0013FA  2               check_collision_right:
0013FA  2               	; if levelx == TILEMAP_WIDTH - sprite.width => collision
0013FA  2  A0 05        	ldy #Entity::levelx + 1
0013FC  2  B1 08        	lda (r3),y
0013FE  2  F0 0F        	beq :+							; if x < 256, no need to test right border
001400  2  A0 04        	ldy #Entity::levelx
001402  2  B1 08        	lda (r3),y
001404  2  A0 0B        	ldy #Entity::bWidth
001406  2  71 08        	adc (r3),y
001408  2  C9 00        	cmp #<(LEVEL_WIDTH)
00140A  2  D0 03        	bne :+
00140C  2  A9 01        	lda #01							; colllision right border
00140E  2  60           	rts
00140F  2               
00140F  2               :
00140F  2  A9 01        	lda #$01
001411  2  85 69        	sta bSide2test
001413  2  20 A4 13     	jsr if_collision_tile_height
001416  2  D0 13        	bne @return						; if tile collision, return the tile value
001418  2               
001418  2  A0 01        	ldy #Entity::spriteID
00141A  2  B1 08        	lda (r3),y
00141C  2  AA               tax
00141D  2  A9 06        	lda #(02 | 04)
00141F  2  A0 01        	ldy #01
001421  2  20 5A 0F     	jsr Sprite::precheck_collision	; precheck 1 pixel right, if a=$ff => nocollision
001424  2  30 03        	bmi @no_collision
001426  2  A9 01        	lda #01
001428  2  60           	rts
001429  2               
001429  2               @no_collision:
001429  2  A9 00        	lda #00
00142B  2               @return:
00142B  2  60           	rts
00142C  2               
00142C  2               ;************************************************
00142C  2               ; check collision on the left
00142C  2               ; input: r3 pointer to entity
00142C  2               ; output: A = value of the collision, or 00/01 for sprites
00142C  2               ;			ZERO = no collision
00142C  2               ;
00142C  2               check_collision_left:
00142C  2               	; if levelx == 0 => collision
00142C  2  A0 05        	ldy #Entity::levelx + 1
00142E  2  B1 08        	lda (r3),y
001430  2  D0 09        	bne :+
001432  2  A0 04        	ldy #Entity::levelx
001434  2  B1 08        	lda (r3),y
001436  2  D0 03        	bne :+
001438  2  A9 01        	lda #01
00143A  2  60           	rts
00143B  2               
00143B  2               :
00143B  2               	; left border is a collision
00143B  2  A9 FF        	lda #$ff
00143D  2  85 69        	sta bSide2test
00143F  2  20 A4 13     	jsr if_collision_tile_height
001442  2  D0 13        	bne @return
001444  2               
001444  2  A0 01        	ldy #Entity::spriteID
001446  2  B1 08        	lda (r3),y
001448  2  AA               tax
001449  2  A9 0A        	lda #(02 | 08)
00144B  2  A0 01        	ldy #01
00144D  2  20 5A 0F     	jsr Sprite::precheck_collision	; precheck 1 pixel right
001450  2  30 03        	bmi @no_collision
001452  2  A9 01        	lda #01
001454  2  60           	rts
001455  2               
001455  2               @no_collision:
001455  2  A9 00        	lda #00
001457  2               @return:
001457  2  60           	rts
001458  2               
001458  2               ;************************************************
001458  2               ; check collision down
001458  2               ;	collision surface to test is 16 pixels around the mid X
001458  2               ; input: r3 pointer to entity
001458  2               ; output : Z = no collision
001458  2               ;
001458  2               check_collision_down:
001458  2               	; if levely == LEVEL_HEIGHT - sprite.width => collision
001458  2  A0 07        	ldy #Entity::levely + 1
00145A  2  B1 08        	lda (r3),y
00145C  2  F0 0F        	beq :+							; if x < 256, no need to test right border
00145E  2  A0 06        	ldy #Entity::levely
001460  2  B1 08        	lda (r3),y
001462  2  A0 0C        	ldy #Entity::bHeight
001464  2  71 08        	adc (r3),y
001466  2  C9 00        	cmp #<(LEVEL_HEIGHT)
001468  2  D0 03        	bne :+
00146A  2  A9 01        	lda #01
00146C  2  60           	rts
00146D  2               
00146D  2               :
00146D  2  A0 06            ldy #Entity::levely
00146F  2  B1 08        	lda (r3),y               	; if the player is inbetween 2 tiles there can be no collision
001471  2  29 0F        	and #%00001111
001473  2  D0 34        	bne @check_sprites
001475  2               
001475  2               @check_tiles:
001475  2  A0 10            ldy #Entity::collision_addr
001477  2  B1 08        	lda (r3),y
001479  2  85 02        	sta r0L
00147B  2  C8               iny
00147C  2  B1 08        	lda (r3),y
00147E  2  85 03        	sta r0H
001480  2               
001480  2  20 46 13     	jsr bbox_coverage
001483  2  A6 6B        	ldx bTilesHeight	; check below the player
001485  2  A9 00        	lda #00
001487  2  18           	clc
001488  2               @loop:
001488  2  69 20        	adc #LEVEL_TILES_WIDTH
00148A  2  CA           	dex
00148B  2  D0 FB        	bne @loop
00148D  2  A8           	tay
00148E  2               
00148E  2  A6 04        	ldx bTilesCoveredX						; tiles to test in width
001490  2               @test_colum:
001490  2  B1 02        	lda (r0L),y
001492  2  F0 0C        	beq @next_colum							; empty tile, test the next one
001494  2               
001494  2  84 30        	sty $30
001496  2  A8           	tay
001497  2  B9 1F 23     	lda tiles_attributes,y
00149A  2  89 01        	bit #TILE_ATTR::SOLID_GROUND
00149C  2  D0 08        	bne @collision							; considere slopes as empty
00149E  2  A4 30        	ldy $30
0014A0  2               
0014A0  2               @next_colum:
0014A0  2  CA           	dex
0014A1  2  F0 06        	beq @check_sprites
0014A3  2  C8           	iny
0014A4  2  80 EA        	bra @test_colum
0014A6  2               @collision:
0014A6  2  A9 01        	lda #01
0014A8  2  60           	rts
0014A9  2               
0014A9  2               @check_sprites:
0014A9  2  A0 01        	ldy #Entity::spriteID
0014AB  2  B1 08            lda (r3),y
0014AD  2  AA               tax
0014AE  2  A9 05        	lda #(01 | 04)
0014B0  2  A0 01        	ldy #01
0014B2  2  20 5A 0F     	jsr Sprite::precheck_collision	; precheck 1 pixel right
0014B5  2  30 03        	bmi @no_collision
0014B7  2  A9 01        	lda #01
0014B9  2  60           	rts
0014BA  2               @no_collision:
0014BA  2  A9 00        	lda #00
0014BC  2  60           	rts
0014BD  2               
0014BD  2  60           	rts
0014BE  2               
0014BE  2               ;************************************************
0014BE  2               ; check collision up
0014BE  2               ;	collision surface to test is 16 pixels around the mid X
0014BE  2               ; input: r3 pointer to entity
0014BE  2               ;		r0 : @ of current tile the top-left corner of the player sprite
0014BE  2               ; output : Z = no collision
0014BE  2               ;
0014BE  2               check_collision_up:
0014BE  2               	; if levely == 0 => collision
0014BE  2  A0 07        	ldy #Entity::levely + 1
0014C0  2  B1 08        	lda (r3),y
0014C2  2  D0 09        	bne :+
0014C4  2  A0 06        	ldy #Entity::levely
0014C6  2  B1 08        	lda (r3),y
0014C8  2  D0 03        	bne :+
0014CA  2  A9 01        	lda #01
0014CC  2  60           	rts
0014CD  2               
0014CD  2               :
0014CD  2  A0 06            ldy #Entity::levely
0014CF  2  B1 08        	lda (r3),y               	; if the player is inbetween 2 tiles there can be no collision
0014D1  2  29 0F        	and #%00001111
0014D3  2  D0 30        	bne @check_sprites
0014D5  2               
0014D5  2  38           	sec
0014D6  2  A0 10            ldy #Entity::collision_addr
0014D8  2  B1 08        	lda (r3),y
0014DA  2  E9 20        	sbc #LEVEL_TILES_WIDTH
0014DC  2  85 02        	sta r0L
0014DE  2  C8               iny
0014DF  2  B1 08        	lda (r3),y
0014E1  2  E9 00        	sbc #0
0014E3  2  85 03        	sta r0H
0014E5  2               
0014E5  2  20 46 13     	jsr bbox_coverage
0014E8  2               
0014E8  2  A6 04        	ldx bTilesCoveredX
0014EA  2  A0 00        	ldy #00
0014EC  2               @test_colum:
0014EC  2  B1 02        	lda (r0L),y							; left side
0014EE  2  F0 0C        	beq @next_column
0014F0  2               
0014F0  2  84 65        	sty ENTITY_ZP
0014F2  2  A8           	tay
0014F3  2  B9 1F 23     	lda tiles_attributes,y
0014F6  2  89 04        	bit #TILE_ATTR::SOLID_CEILING
0014F8  2  D0 08        	bne @collision
0014FA  2  A4 65        	ldy ENTITY_ZP
0014FC  2               
0014FC  2               @next_column:
0014FC  2  CA           	dex
0014FD  2  F0 06        	beq @no_collision
0014FF  2  C8           	iny
001500  2  80 EA        	bra @test_colum
001502  2               @collision:
001502  2  A9 01        	lda #01
001504  2  60           	rts
001505  2               @no_collision:
001505  2               @check_sprites:
001505  2  A9 00        	lda #00
001507  2  60           	rts
001508  2               
001508  2               ;************************************************
001508  2               ; check if the player feet is ABOVE a slope tile
001508  2               ;   input: 	r0 pointer to player position on collision map
001508  2               ;			r3 pointer to entity
001508  2               ;	        Y = feet position tested (vs r0)
001508  2               ;	modify: bPlayerOnSlop
001508  2               ;	return: Z = slop
001508  2               ;
001508  2               if_above_slop:
001508  2  64 6C        	stz bPlayerOnSlop				; no slope
00150A  2               
00150A  2  20 46 13     	jsr bbox_coverage
00150D  2               
00150D  2  18           	clc
00150E  2  A9 00        	lda #00
001510  2  A6 05        	ldx bTilesCoveredY					; test BELOW feet level
001512  2               :
001512  2  69 20        	adc #LEVEL_TILES_WIDTH
001514  2  CA           	dex
001515  2  D0 FB        	bne :-
001517  2  85 67        	sta ENTITY_ZP + 2					; position of the feet tiles
001519  2               
001519  2  A0 04            ldy #Entity::levelx
00151B  2  B1 08        	lda (r3),y
00151D  2  29 0F        	and #%00001111
00151F  2  C9 08        	cmp #08
001521  2  90 04        	bcc @column0
001523  2  F0 0E        	beq @no_slope						; if x % 16 > 8, on the edge
001525  2               @column1:
001525  2  E6 67        	inc ENTITY_ZP + 2					; if x % 16 > 8, check the next colum
001527  2               @column0:
001527  2  A4 67            ldy ENTITY_ZP + 2
001529  2  B1 02        	lda (r0),y
00152B  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
00152D  2  F0 09        	beq @above_slope
00152F  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
001531  2  F0 05        	beq @above_slope
001533  2               @no_slope:
001533  2  A9 00        	lda #0
001535  2  85 6C        	sta bPlayerOnSlop
001537  2  60           	rts
001538  2               @above_slope:
001538  2  85 6C        	sta bPlayerOnSlop
00153A  2  A5 6C        	lda bPlayerOnSlop
00153C  2  60           	rts
00153D  2               
00153D  2               ;************************************************
00153D  2               ; check if the entity base is exactly on a slope tile
00153D  2               ;   input:  A = direction the object is moving to  (left = $ff, right = $01)
00153D  2               ;			r0 pointer to player position on collision map
00153D  2               ;			r3 pointer to entity
00153D  2               ;	modify: bPlayerOnSlop
00153D  2               ;	return: Z = slop
00153D  2               ;			Y = feet position tested (vs r0)
00153D  2               ;
00153D  2               if_on_slop:
00153D  2  64 6C        	stz bPlayerOnSlop				; no slope
00153F  2               
00153F  2  20 46 13     	jsr bbox_coverage
001542  2               
001542  2  18           	clc
001543  2  A9 00        	lda #00
001545  2  A6 05        	ldx bTilesCoveredY
001547  2  CA           	dex									; remove 1 to pick the feet position, and not BELOW the feet
001548  2               :
001548  2  69 20        	adc #LEVEL_TILES_WIDTH
00154A  2  CA           	dex
00154B  2  D0 FB        	bne :-
00154D  2  85 67        	sta ENTITY_ZP + 2					; position of the feet tiles
00154F  2               
00154F  2  A0 04            ldy #Entity::levelx
001551  2  B1 08        	lda (r3),y
001553  2  29 0F        	and #%00001111
001555  2  C9 08        	cmp #08
001557  2  90 10        	bcc @column0						; if x % 16 < 8, check column 0
001559  2  D0 0C        	bne @column1						; if x % 16 > 8, check column 1
00155B  2               
00155B  2  A4 67            ldy ENTITY_ZP + 2					; if x%16==8 test both columns
00155D  2  B1 02        	lda (r0),y
00155F  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
001561  2  F0 12        	beq @on_slope
001563  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
001565  2  F0 0E        	beq @on_slope
001567  2               
001567  2               @column1:
001567  2  E6 67        	inc ENTITY_ZP + 2					; if x % 16 > 8, check the next colum
001569  2               @column0:
001569  2  A4 67            ldy ENTITY_ZP + 2
00156B  2               	; check if player feet is ON a slop
00156B  2  B1 02        	lda (r0),y						; test ON feet level
00156D  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
00156F  2  F0 04        	beq @on_slope
001571  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
001573  2  D0 05        	bne @no_slope
001575  2               @on_slope:
001575  2  85 6C        	sta bPlayerOnSlop
001577  2  A5 6C        	lda bPlayerOnSlop				; remove the Z flag
001579  2  60           	rts
00157A  2               
00157A  2               @no_slope:
00157A  2  A9 00        	lda #0
00157C  2  85 6C        	sta bPlayerOnSlop
00157E  2  60           	rts
00157F  2               
00157F  2               ;************************************************
00157F  2               ; Handle entity physics when jumping or falling
00157F  2               ;   input: r3 pointer to entity
00157F  2               ;
00157F  2               physics:
00157F  2  86 68        	stx bSaveX
001581  2               
001581  2  A0 02        	ldy #Entity::status
001583  2  B1 08        	lda (r3),y
001585  2  C9 02        	cmp #STATUS_CLIMBING
001587  2  F0 0B        	beq @return1
001589  2  C9 03        	cmp #STATUS_CLIMBING_IDLE
00158B  2  F0 07        	beq @return1
00158D  2  C9 05        	cmp #STATUS_JUMPING
00158F  2  D0 06        	bne @fall
001591  2  4C F9 16     	jmp @jump
001594  2               @return1:
001594  2  A6 68        	ldx bSaveX
001596  2  60           	rts
001597  2               
001597  2               	;
001597  2               	; deal with gravity driven falling
001597  2               	;
001597  2               @fall:
001597  2               .ifdef DEBUG
001597  2               	CHECK_DEBUG
001597  2               .endif
001597  2  64 6D        	stz bInLoop					; we are not yet the the physic loop
001599  2               @loop:
001599  2  20 E4 11     	jsr Entities::get_collision_map
00159C  2  20 58 14     	jsr check_collision_down
00159F  2  F0 03        	beq @check_on_slope				; no solid tile below the player, still check if the player is ON a slope
0015A1  2  4C E2 16     	jmp @sit_on_solid				; solid tile below the player that is not a slope
0015A4  2               
0015A4  2               @check_on_slope:
0015A4  2  20 3D 15     	jsr if_on_slop
0015A7  2  F0 43        	beq @no_collision_down			; not ON a slope, and not ABOVE a solid tile => fall
0015A9  2               	; player is on a slope
0015A9  2               @on_slope:
0015A9  2  A0 04        	ldy #Entity::levelx
0015AB  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
0015AD  2  F0 18        	beq @slope_left
0015AF  2               @slope_right:
0015AF  2  B1 08        	lda (r3),y						; X position defines how far down Y can go
0015B1  2  29 0F        	and #%00001111
0015B3  2  C9 08        	cmp #08
0015B5  2  90 07        	bcc :+
0015B7  2  49 0F        	eor #%00001111
0015B9  2  18           	clc
0015BA  2  69 09        	adc #09
0015BC  2  80 05        	bra @store_y1					; if x % 16 >= 8 = delta_y:  (x=8 => y=+15, x=15 => y = +8)
0015BE  2               :
0015BE  2  49 0F        	eor #%00001111
0015C0  2  38           	sec
0015C1  2  E9 07        	sbc #07							; if x % 16 < 8 = delta_y:  (x=0 => y=+8, x=7 => y = +0)
0015C3  2               @store_y1:
0015C3  2  85 30        	sta bSlopX_delta
0015C5  2  80 14        	bra @slope_y
0015C7  2               @slope_left:
0015C7  2  B1 08        	lda (r3),y						; X position defines how far down Y can go
0015C9  2  29 0F        	and #%00001111
0015CB  2  C9 08        	cmp #08
0015CD  2  F0 07        	beq :+							; x%16 == 8 => keep 16
0015CF  2  90 05        	bcc :+							; x%16 < 8	+8
0015D1  2  38           	sec								; x%16 > 8	-8
0015D2  2  E9 08        	sbc #08
0015D4  2  80 ED        	bra @store_y1
0015D6  2               :
0015D6  2  18           	clc
0015D7  2  69 08        	adc #08
0015D9  2  85 30        	sta bSlopX_delta
0015DB  2               @slope_y:
0015DB  2  A0 06        	ldy #Entity::levely
0015DD  2  B1 08        	lda (r3),y
0015DF  2  29 0F        	and #%00001111
0015E1  2  D0 02        	bne :+
0015E3  2  A9 10        	lda #$10						; dirty trick y % 16 == 0 => convert to $10 (far end of the tile)
0015E5  2               :
0015E5  2  C5 30        	cmp bSlopX_delta
0015E7  2  90 03        	bcc @no_collision_down
0015E9  2  4C E2 16     	jmp @sit_on_solid
0015EC  2               
0015EC  2               @no_collision_down:
0015EC  2  A5 6D        	lda bInLoop						; only modify the status and t if we are not in the loop
0015EE  2  D0 6C        	bne @drive_fall
0015F0  2               
0015F0  2  A9 01        	lda #01
0015F2  2  85 6D        	sta bInLoop
0015F4  2               
0015F4  2               	; if the entity is connected to another, sever the link
0015F4  2               
0015F4  2  A0 03        	ldy #Entity::connectedID
0015F6  2  B1 08        	lda (r3),y
0015F8  2  C9 FF        	cmp #$ff
0015FA  2  F0 2B        	beq :+
0015FC  2               
0015FC  2               	; TODO //////////////////////////////////////////////////////////
0015FC  2  AA           	tax
0015FD  2               
0015FD  2               	; call virtual function of the remote object to unbind
0015FD  2  BD 00 06     	lda indexLO,x
001600  2  85 14        	sta r9L
001602  2  BD 10 06     	lda indexHI,x
001605  2  85 15        	sta r9H
001607  2  20 07 18     	jsr Entities::unbind
00160A  2               
00160A  2               	; call virtual function of the remote object to unbind
00160A  2  A5 08        	lda r3L
00160C  2  85 14        	sta r9L
00160E  2  A5 09        	lda r3H
001610  2  85 15        	sta r9H
001612  2  BD 00 06     	lda indexLO,x
001615  2  85 08        	sta r3L
001617  2  BD 10 06     	lda indexHI,x
00161A  2  85 09        	sta r3H
00161C  2  20 07 18     	jsr Entities::unbind
00161F  2  A5 14        	lda r9L
001621  2  85 08        	sta r3L
001623  2  A5 15        	lda r9H
001625  2  85 09        	sta r3H				; restore this
001627  2               
001627  2               	; TODO \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
001627  2               
001627  2               	; if the player is already falling, increase t
001627  2               :
001627  2  A0 02        	ldy #Entity::status
001629  2  B1 08        	lda (r3),y
00162B  2  C9 04        	cmp #STATUS_FALLING
00162D  2  F0 0F        	beq @increase_ticks
00162F  2               
00162F  2               	; start the falling timer
00162F  2  A9 04        	lda #STATUS_FALLING
001631  2  91 08        	sta (r3),y
001633  2  A9 08        	lda #FALL_LO_TICKS
001635  2  A0 08        	ldy #Entity::falling_ticks
001637  2  91 08        	sta (r3),y						; reset t
001639  2  C8           	iny
00163A  2  A9 00        	lda #00
00163C  2  91 08        	sta (r3),y
00163E  2               @increase_ticks:
00163E  2  A0 08        	ldy #Entity::falling_ticks
001640  2  B1 08        	lda (r3),y									; increase the timer every 10 screen refresh
001642  2  3A           	dec
001643  2  91 08        	sta (r3),y
001645  2  D0 0A        	bne @check_loop
001647  2  A9 08        	lda #FALL_LO_TICKS
001649  2  91 08        	sta (r3),y
00164B  2  C8           	iny
00164C  2  B1 08        	lda (r3),y
00164E  2  1A           	inc
00164F  2  91 08        	sta (r3),y
001651  2               
001651  2               @check_loop:
001651  2  A0 09        	ldy #Entity::falling_ticks + 1
001653  2  B1 08        	lda (r3),y
001655  2  D0 03        	bne @start_drive_fall
001657  2  4C DD 16     	jmp @fall_once
00165A  2               
00165A  2               @start_drive_fall:
00165A  2  85 14        	sta r9L
00165C  2               
00165C  2               @drive_fall:
00165C  2               	; move the player down #(falling_ticks + 1)
00165C  2  20 04 13     	jsr position_y_inc
00165F  2               
00165F  2  C6 14        	dec r9L
001661  2  F0 03        	beq @apply_delta_x
001663  2  4C 99 15     	jmp @loop						; take t in count for gravity
001666  2               
001666  2               @apply_delta_x:
001666  2               	; we did all the Y modification, so now as there was no collision we can move X
001666  2  A0 0A        	ldy #Entity::delta_x
001668  2  B1 08        	lda (r3),y
00166A  2  F0 04        	beq :+						; delta_x == 0 => entity is not moving left or right
00166C  2  30 3B        	bmi @fall_left					; delta_x < 0 => move left
00166E  2  80 03        	bra @fall_right
001670  2               :
001670  2  A6 68        	ldx bSaveX
001672  2  60           	rts
001673  2               
001673  2               @fall_right:
001673  2               	; cannot move if we are at the right border
001673  2  A0 04        	ldy #Entity::levelx
001675  2  B1 08        	lda (r3),y
001677  2  C9 E0        	cmp #<(LEVEL_WIDTH - 32)
001679  2  D0 07        	bne @test_fall_collision_right
00167B  2  C8           	iny
00167C  2  B1 08        	lda (r3),y
00167E  2  C9 01        	cmp #>(LEVEL_WIDTH - 32)
001680  2  F0 05        	beq @fcollision_right			; we are at the level limit
001682  2               @test_fall_collision_right:
001682  2  20 FA 13     	jsr check_collision_right
001685  2  F0 07        	beq @no_fcollision_right
001687  2               @fcollision_right:
001687  2  A9 00        	lda #00
001689  2  A0 0A        	ldy #Entity::delta_x
00168B  2  91 08        	sta (r3),y						; cancel deltaX to transform to vertical movement
00168D  2  60           	rts
00168E  2               @no_fcollision_right:
00168E  2  A5 6C        	lda bPlayerOnSlop
001690  2  F0 11        	beq @move_x_inc
001692  2               
001692  2               	; on slope, check if we can move on X axis
001692  2  A0 06        	ldy #Entity::levely
001694  2  B1 08        	lda (r3),y
001696  2  29 0F        	and #%00001111
001698  2  D0 02        	bne :+
00169A  2  A9 10        	lda #$10						; dirty trick y % 16 == 0 => convert to $10 (far end of the tile)
00169C  2               :
00169C  2  C5 30        	cmp bSlopX_delta
00169E  2  90 03        	bcc @move_x_inc
0016A0  2               @cannot_move_x:
0016A0  2  A6 68        	ldx bSaveX
0016A2  2  60           	rts
0016A3  2               
0016A3  2               @move_x_inc:
0016A3  2  20 C2 12     	jsr position_x_inc
0016A6  2  A6 68        	ldx bSaveX
0016A8  2  60           	rts
0016A9  2               
0016A9  2               @fall_left:
0016A9  2               	; cannot move if we are at the left border
0016A9  2  A0 05        	ldy #Entity::levelx + 1
0016AB  2  B1 08        	lda (r3),y
0016AD  2  D0 05        	bne @test_fall_collision_left
0016AF  2  88           	dey
0016B0  2  B1 08        	lda (r3),y
0016B2  2  F0 05        	beq @fcollision_left
0016B4  2               @test_fall_collision_left:
0016B4  2  20 2C 14     	jsr check_collision_left
0016B7  2  F0 09        	beq @no_fcollision_left
0016B9  2               @fcollision_left:
0016B9  2  A9 00        	lda #00
0016BB  2  A0 0A        	ldy #Entity::delta_x
0016BD  2  91 08        	sta (r3),y				 		; cancel deltaX to transform to vertical movement
0016BF  2  A6 68        	ldx bSaveX
0016C1  2  60           	rts
0016C2  2               @no_fcollision_left:
0016C2  2  A5 6C        	lda bPlayerOnSlop
0016C4  2  F0 11        	beq @move_x_dec
0016C6  2               
0016C6  2               	; on slope, check if we can move on X axis
0016C6  2  A0 06        	ldy #Entity::levely
0016C8  2  B1 08        	lda (r3),y
0016CA  2  29 0F        	and #%00001111
0016CC  2  D0 02        	bne :+
0016CE  2  A9 10        	lda #$10						; dirty trick y % 16 == 0 => convert to $10 (far end of the tile)
0016D0  2               :
0016D0  2  C5 30        	cmp bSlopX_delta
0016D2  2  90 03        	bcc @move_x_dec
0016D4  2               @cannot_move_x_dec:
0016D4  2  A6 68        	ldx bSaveX
0016D6  2  60           	rts
0016D7  2               @move_x_dec:
0016D7  2  20 E2 12     	jsr position_x_dec
0016DA  2  A6 68        	ldx bSaveX
0016DC  2  60           	rts
0016DD  2               
0016DD  2               @fall_once:
0016DD  2  20 04 13     	jsr position_y_inc
0016E0  2  80 84        	bra @apply_delta_x
0016E2  2               
0016E2  2               @sit_on_solid:
0016E2  2  A0 0D        	ldy #Entity::bFlags
0016E4  2  B1 08        	lda (r3),y
0016E6  2  29 FE        	and #(255-EntityFlags::physics)
0016E8  2  91 08        	sta (r3),y						; disengage physics engine for that entity
0016EA  2               
0016EA  2               	; change the status if falling
0016EA  2  A0 02        	ldy #Entity::status
0016EC  2  B1 08        	lda (r3),y
0016EE  2  C9 04        	cmp #STATUS_FALLING
0016F0  2  D0 04        	bne @return
0016F2  2  A9 00        	lda #STATUS_WALKING_IDLE
0016F4  2  91 08        	sta (r3),y
0016F6  2               
0016F6  2               @return:
0016F6  2  A6 68        	ldx bSaveX
0016F8  2  60           	rts
0016F9  2               
0016F9  2               	;
0016F9  2               	; deal with gravity driven jumping
0016F9  2               	;
0016F9  2               @jump:
0016F9  2               @decrease_ticks:
0016F9  2  A0 08        	ldy #Entity::falling_ticks
0016FB  2  B1 08        	lda (r3),y
0016FD  2  3A           	dec								 	; decrease  HI every 10 refresh
0016FE  2  91 08        	sta (r3),y
001700  2  D0 0D        	bne @drive_jump
001702  2  C8           	iny
001703  2  B1 08        	lda (r3),y
001705  2  3A           	dec
001706  2  91 08        	sta (r3),y
001708  2  F0 50        	beq @apex							; reached the apex of the jump
00170A  2               
00170A  2  A9 0A        	lda #JUMP_LO_TICKS
00170C  2  88           	dey
00170D  2  91 08        	sta (r3),y							; reset t
00170F  2               
00170F  2               @drive_jump:
00170F  2  A0 09        	ldy #Entity::falling_ticks + 1
001711  2  B1 08        	lda (r3),y
001713  2  85 66        	sta ENTITY_ZP + 1
001715  2               @loop_jump:
001715  2  20 24 13     	jsr position_y_dec
001718  2               
001718  2               	; refresh the collision address
001718  2  20 E4 11     	jsr Entities::get_collision_map
00171B  2               
00171B  2  A0 06        	ldy #Entity::levely
00171D  2  B1 08        	lda (r3),y
00171F  2  29 0F        	and #%00001111
001721  2  D0 05        	bne @no_collision_up				; if player is not on a multiple of 16 (tile size)
001723  2               
001723  2               	; test hit a ceiling
001723  2  20 BE 14     	jsr check_collision_up
001726  2  D0 04        	bne @collision_up
001728  2               @no_collision_up:
001728  2  C6 66        	dec ENTITY_ZP + 1
00172A  2  D0 E9        	bne @loop_jump						; loop to take t in count for gravity
00172C  2               
00172C  2               @collision_up:
00172C  2  A0 0A        	ldy #Entity::delta_x
00172E  2  B1 08        	lda (r3),y					 		; deal with deltax
001730  2  F0 C4        	beq @return
001732  2  30 12        	bmi @jump_left
001734  2               @jump_right:
001734  2  20 FA 13     	jsr check_collision_right
001737  2  F0 09        	beq @no_collision_right
001739  2               @collision_right:
001739  2  A9 00        	lda #00
00173B  2  A0 0A        	ldy #Entity::delta_x
00173D  2  91 08        	sta (r3),y							; cancel deltaX to transform to vertical movement
00173F  2  A6 68        	ldx bSaveX
001741  2  60           	rts
001742  2               @no_collision_right:
001742  2  20 C2 12     	jsr position_x_inc
001745  2  60           	rts
001746  2               @jump_left:
001746  2  20 2C 14     	jsr check_collision_left
001749  2  F0 09        	beq @no_collision_left
00174B  2               @collision_left:
00174B  2  A9 00        	lda #00
00174D  2  A0 0A        	ldy #Entity::delta_x
00174F  2  91 08        	sta (r3),y							; cancel deltaX to transform to vertical movement
001751  2  A6 68        	ldx bSaveX
001753  2  60           	rts
001754  2               @no_collision_left:
001754  2  20 E2 12     	jsr position_x_dec
001757  2  A6 68        	ldx bSaveX
001759  2  60           	rts
00175A  2               
00175A  2               @apex:
00175A  2  A0 02            ldy #Entity::status
00175C  2  A9 06        	lda #STATUS_JUMPING_IDLE
00175E  2  91 08        	sta (r3),y
001760  2               
001760  2  A6 68        	ldx bSaveX
001762  2  60           	rts
001763  2               
001763  2               ;************************************************
001763  2               ; Try to move entity to the right
001763  2               ;	input : X = entity ID
001763  2               ;	return: A = 00 => succeeded to move
001763  2               ;			A = ff => error_right_border
001763  2               ;			A = 02 => error collision on right
001763  2               ;
001763  2               move_right:
001763  2  BD 10 06     	lda indexHI,x
001766  2  85 09        	sta r3H
001768  2  BD 00 06     	lda indexLO,x
00176B  2  85 08        	sta r3L
00176D  2               
00176D  2               move_right_entry:
00176D  2               	; cannot move if we are at the border
00176D  2  A0 05        	ldy #Entity::levelx + 1
00176F  2  B1 08        	lda (r3), y
001771  2  C9 01        	cmp #>(LEVEL_WIDTH - 32)
001773  2  D0 0B        	bne @not_border
001775  2               
001775  2  A0 04        	ldy #Entity::levelx
001777  2  B1 08        	lda (r3), y
001779  2  C9 E0        	cmp #<(LEVEL_WIDTH - 32)
00177B  2  D0 03        	bne @not_border
00177D  2               
00177D  2               @failed_border:
00177D  2  A9 FF        	lda #$ff
00177F  2  60           	rts
001780  2               
001780  2               @not_border:
001780  2  A0 10        	ldy #Entity::collision_addr
001782  2  B1 08        	lda (r3), y
001784  2  85 02        	sta r0L
001786  2  C8           	iny
001787  2  B1 08        	lda (r3), y
001789  2  85 03        	sta r0H
00178B  2               
00178B  2  20 FA 13     	jsr Entities::check_collision_right
00178E  2  AA           	tax
00178F  2  F0 02        	beq @no_collision						; block is collision on the right  and there is no slope on the right
001791  2  8A           	txa
001792  2  60           	rts										; return the collision tile code
001793  2               
001793  2               @no_collision:
001793  2               	; set direction vector
001793  2  A0 0A        	ldy #Entity::delta_x
001795  2  A9 01        	lda #01
001797  2  91 08        	sta (r3),y
001799  2               
001799  2               	; move the entity in the level
001799  2  20 C2 12     	jsr Entities::position_x_inc
00179C  2  20 E4 11     	jsr Entities::get_collision_map
00179F  2               
00179F  2               	; activate physics engine
00179F  2  A0 0D        	ldy #Entity::bFlags
0017A1  2  B1 08        	lda (r3),y
0017A3  2  09 01        	ora #(EntityFlags::physics)
0017A5  2  91 08        	sta (r3),y
0017A7  2               
0017A7  2  A9 00        	lda #00
0017A9  2  60           	rts
0017AA  2               
0017AA  2               ;************************************************
0017AA  2               ; Try to move entity to the left
0017AA  2               ;	input : X = entity ID
0017AA  2               ;	return: A = 00 => succeeded to move
0017AA  2               ;			A = ff => error_right_border
0017AA  2               ;			A = 02 => error collision on right
0017AA  2               ;
0017AA  2               move_left:
0017AA  2  BD 10 06     	lda indexHI,x
0017AD  2  85 09        	sta r3H
0017AF  2  BD 00 06     	lda indexLO,x
0017B2  2  85 08        	sta r3L
0017B4  2               
0017B4  2               move_left_entry:
0017B4  2               	; cannot move if we are at the left border
0017B4  2  A0 05        	ldy #Entity::levelx + 1
0017B6  2  B1 08        	lda (r3), y
0017B8  2  D0 08        	bne @not_border
0017BA  2  88           	dey
0017BB  2  B1 08        	lda (r3), y
0017BD  2  D0 03        	bne @not_border
0017BF  2               
0017BF  2               @failed_border:
0017BF  2  A9 FF        	lda #$ff
0017C1  2  60           	rts
0017C2  2               
0017C2  2               @not_border:
0017C2  2  A0 10        	ldy #Entity::collision_addr
0017C4  2  B1 08        	lda (r3), y
0017C6  2  85 02        	sta r0L
0017C8  2  C8           	iny
0017C9  2  B1 08        	lda (r3), y
0017CB  2  85 03        	sta r0H
0017CD  2               
0017CD  2  20 2C 14     	jsr Entities::check_collision_left
0017D0  2  AA           	tax
0017D1  2  F0 02        	beq @no_collision
0017D3  2  8A           	txa										; block is collision on the left  and there is no slope on the right
0017D4  2  60           	rts										; return the collision tile code
0017D5  2               
0017D5  2               @no_collision:
0017D5  2               	; set direction vector LEFT
0017D5  2  A0 0A        	ldy #Entity::delta_x
0017D7  2  A9 FF        	lda #$ff
0017D9  2  91 08        	sta (r3),y
0017DB  2               
0017DB  2               	; move the entity in the level
0017DB  2  20 E2 12     	jsr Entities::position_x_dec
0017DE  2  20 E4 11     	jsr Entities::get_collision_map
0017E1  2               
0017E1  2               	; activate physics engine
0017E1  2  A0 0D        	ldy #Entity::bFlags
0017E3  2  B1 08        	lda (r3),y
0017E5  2  09 01        	ora #(EntityFlags::physics)
0017E7  2  91 08        	sta (r3),y
0017E9  2               
0017E9  2  A9 00        	lda #00
0017EB  2  60           	rts
0017EC  2               
0017EC  2               ;************************************************
0017EC  2               ; virtual function bind
0017EC  2               ;   input: r3 = this
0017EC  2               ;   input: r9 = start of connected object
0017EC  2               ;
0017EC  2               bind:
0017EC  2  A0 00        	ldy #Entity::id
0017EE  2  B1 08        	lda (r3),y							; link the grabbed object back
0017F0  2  A0 03        	ldy #Entity::connectedID
0017F2  2  91 14        	sta (r9),y
0017F4  2               
0017F4  2               	; simulate a jsr ((r3),y)
0017F4  2  A0 13        	ldy #Entity::fnBind+1
0017F6  2  B1 08        	lda (r3),y
0017F8  2  D0 01        	bne @call_children
0017FA  2  60           	rts
0017FB  2               @call_children:
0017FB  2  8D 06 18     	sta @jsr + 2
0017FE  2  88           	dey
0017FF  2  B1 08        	lda (r3),y
001801  2  8D 05 18     	sta @jsr + 1
001804  2               @jsr:
001804  2  4C 00 00     	jmp 0000							; call children class
001807  2               
001807  2               ;************************************************
001807  2               ; virtual function unbind
001807  2               ;   input: r3 = this
001807  2               ;   input: r9 = start of connected object
001807  2               ;
001807  2               unbind:
001807  2  A9 FF        	lda #$ff
001809  2  A0 03        	ldy #Entity::connectedID
00180B  2  91 08        	sta (r3),y
00180D  2               
00180D  2               	; simulate a jsr ((r3),y)
00180D  2  A0 15        	ldy #Entity::fnUnbind+1
00180F  2  B1 08        	lda (r3),y
001811  2  D0 01        	bne @call_children
001813  2  60           	rts
001814  2               @call_children:
001814  2  8D 1F 18     	sta @jsr + 2
001817  2  88           	dey
001818  2  B1 08        	lda (r3),y
00181A  2  8D 1E 18     	sta @jsr + 1
00181D  2               @jsr:
00181D  2  4C 00 00     	jmp 0000							; call children class
001820  2               
001820  2               ;************************************************
001820  2               ; virtual function move_right
001820  2               ;   input: r3 = this
001820  2               ;
001820  2               fn_move_right:
001820  2  BD 10 06     	lda indexHI,x
001823  2  85 09        	sta r3H
001825  2  BD 00 06     	lda indexLO,x
001828  2  85 08        	sta r3L
00182A  2               
00182A  2  A0 17        	ldy #Entity::fnMoveRight+1
00182C  2  B1 08        	lda (r3),y
00182E  2  D0 03        	bne @call_subclass
001830  2  4C 6D 17     	jmp Entities::move_right_entry
001833  2               @call_subclass:
001833  2  8D 3E 18     	sta @jsr + 2
001836  2  88           	dey
001837  2  B1 08        	lda (r3),y
001839  2  8D 3D 18     	sta @jsr + 1
00183C  2               @jsr:
00183C  2  4C 00 00     	jmp 0000
00183F  2               
00183F  2               ;************************************************
00183F  2               ; virtual function move_left
00183F  2               ;   input: r3 = this
00183F  2               ;
00183F  2               fn_move_left:
00183F  2  BD 10 06     	lda indexHI,x
001842  2  85 09        	sta r3H
001844  2  BD 00 06     	lda indexLO,x
001847  2  85 08        	sta r3L
001849  2               
001849  2  A0 19        	ldy #Entity::fnMoveLeft+1
00184B  2  B1 08        	lda (r3),y
00184D  2  D0 03        	bne @call_subclass
00184F  2  4C B4 17     	jmp Entities::move_left_entry
001852  2               @call_subclass:
001852  2  8D 5D 18     	sta @jsr + 2
001855  2  88           	dey
001856  2  B1 08        	lda (r3),y
001858  2  8D 5C 18     	sta @jsr + 1
00185B  2               @jsr:
00185B  2  4C 00 00     	jmp 0000
00185E  2               
00185E  2               .endscope
00185E  2               
00185E  1               .include "objects.asm"
00185E  2               ;-----------------------------------------------------------------------------
00185E  2               ;/////////////////////////////////////////////////////////////////////////////
00185E  2               ;           start OBJECT code
00185E  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
00185E  2               ;-----------------------------------------------------------------------------
00185E  2               
00185E  2               .scope Objects
00185E  2               
00185E  2               OBJECT_ZP = $0060	    ; memory reserved for objects
00185E  2               
00185E  2  00 00        objects_map: .word 0
001860  2  00 00        objects_sprites: .word 0    ; vera memory of the start of the sprites
001862  2               
001862  2               .enum Attribute
001862  2                   GRAB = 1
001862  2               .endenum
001862  2               
001862  2               .struct Object
001862  2               	entity		.tag Entity
001862  2                   imageID     .byte   ; ID of the image in the spritesheet
001862  2                   attribute   .byte
001862  2               .endstruct
001862  2               
001862  2               ;************************************************
001862  2               ; init the object data of the level
001862  2               ;
001862  2               initModule:
001862  2                   ; load the list of objects at the end of the previous load
001862  2  AD 10 08         lda current_load
001865  2  8D 5E 18         sta objects_map
001868  2  AD 11 08         lda current_load + 1
00186B  2  8D 5F 18         sta objects_map + 1
00186E  2  A9 01 A2 08  	LOAD_FILE_NEXT fsobjects, (fsobjects_end-fsobjects)
001872  2  A0 00 20 BA  
001876  2  FF A9 0B A2  
001891  2               
001891  2                   ; load the sprites  of objects at the end of the previous vload
001891  2  AD 12 08         lda Vera::vram_load
001894  2  8D 60 18         sta objects_sprites
001897  2  AD 13 08         lda Vera::vram_load + 1
00189A  2  8D 61 18         sta objects_sprites + 1
00189D  2  A9 01 A2 08  	VLOAD_FILE_NEXT fssprites1, (fssprites1_end-fssprites1)
0018A1  2  A0 00 20 BA  
0018A5  2  FF A9 0C A2  
0018C0  2               
0018C0  2                   ; add each available sprites on screen
0018C0  2  AD 5E 18         lda objects_map
0018C3  2  85 08            sta r3L
0018C5  2  AD 5F 18         lda objects_map + 1
0018C8  2  85 09            sta r3H
0018CA  2               
0018CA  2  B2 08            lda (r3)
0018CC  2  85 31            sta $31     ; number of objects
0018CE  2  64 32            stz $32     ; object #0
0018D0  2               
0018D0  2  E6 08            inc r3L
0018D2  2               
0018D2  2               @loop:
0018D2  2                   ; get a free sprite
0018D2  2  20 BE 0C         jsr Sprite::new
0018D5  2  8A               txa
0018D6  2  A0 01            ldy #Entity::spriteID
0018D8  2  91 08            sta (r3),y
0018DA  2               
0018DA  2                   ; register the entity
0018DA  2  A5 08            lda r3L
0018DC  2  A4 09            ldy r3H
0018DE  2  20 37 11         jsr Entities::register
0018E1  2  8A               txa
0018E2  2  A0 00            ldy #Entity::id
0018E4  2  91 08            sta (r3),y
0018E6  2               
0018E6  2                   ; load the first object
0018E6  2  AD 60 18     	lda objects_sprites
0018E9  2  85 02        	sta r0L
0018EB  2  AD 61 18     	lda objects_sprites + 1
0018EE  2  85 03        	sta r0H
0018F0  2  20 58 0D         jsr Sprite::vram_to_16_5
0018F3  2  A5 04            lda r1L
0018F5  2  85 02            sta r0L
0018F7  2  A5 05            lda r1H
0018F9  2  85 03            sta r0H
0018FB  2               
0018FB  2  A0 01            ldy #Entity::spriteID
0018FD  2  B1 08        	lda (r3),y                        ; sprite id
0018FF  2  A8               tay
001900  2  A9 10           	lda #%00010000					; collision mask 1
001902  2  A2 50           	ldx #%01010000					; 16x16 sprite
001904  2  20 FB 0C     	jsr Sprite::load
001907  2               
001907  2                   ; display the object
001907  2  A0 01            ldy #Entity::spriteID
001909  2  B1 08        	lda (r3),y                       ; sprite id
00190B  2  A8               tay
00190C  2  A2 0C        	ldx #SPRITE_ZDEPTH_TOP
00190E  2  20 86 0D     	jsr Sprite::display
001911  2               
001911  2  A0 0D        	ldy #Entity::bFlags
001913  2  A9 07        	lda #(EntityFlags::physics | EntityFlags::moved | EntityFlags::colission_map_changed)
001915  2  91 08        	sta (r3),y	                    ; force screen position and size to be recomputed
001917  2  20 A3 11         jsr Entities::set_position
00191A  2               
00191A  2                   ; register virtual functions move_right/left
00191A  2  A0 16            ldy #Entity::fnMoveRight
00191C  2  A9 A7            lda #<Objects::move_right
00191E  2  91 08            sta (r3),y
001920  2  C8               iny
001921  2  A9 19            lda #>Objects::move_right
001923  2  91 08            sta (r3),y
001925  2  C8               iny
001926  2  A9 B1            lda #<Objects::move_left
001928  2  91 08            sta (r3),y
00192A  2  C8               iny
00192B  2  A9 19            lda #>Objects::move_left
00192D  2  91 08            sta (r3),y
00192F  2               
00192F  2                   ; last object ?
00192F  2  C6 31            dec $31
001931  2  F0 11            beq @return
001933  2               
001933  2                   ; move to the next object
001933  2  18               clc
001934  2  A5 08            lda r3L
001936  2  69 1C            adc #.sizeof(Object)
001938  2  85 08            sta r3L
00193A  2  A5 09            lda r3H
00193C  2  69 00            adc #00
00193E  2  85 09            sta r3H
001940  2               
001940  2  E6 32            inc $32                     ; object #next
001942  2  80 8E            bra @loop
001944  2               
001944  2               @return:
001944  2  60               rts
001945  2               
001945  2               ;************************************************
001945  2               ; change  position of the sprite (level view) => (screen view)
001945  2               ;   input: X = index of the object
001945  2               ;   output: r3 = pointer to the object
001945  2               ;
001945  2               set_position_index:
001945  2  AD 44 11         lda Entities::get_pointer
001948  2               
001948  2               ;************************************************
001948  2               ; change position of all sprites when the layer moves (level view) => (screen view)
001948  2               ;
001948  2               fix_positions:
001948  2  AD 5E 18         lda objects_map
00194B  2  85 08            sta r3L
00194D  2  AD 5F 18         lda objects_map + 1
001950  2  85 09            sta r3H
001952  2               
001952  2  B2 08            lda (r3)
001954  2  85 31            sta $31     ; number of objects
001956  2  64 32            stz $32
001958  2  E6 08            inc r3L
00195A  2               
00195A  2               @loop:
00195A  2                   ; position the first object
00195A  2  20 A3 11         jsr Entities::set_position
00195D  2               
00195D  2                   ; last object ?
00195D  2  E6 32            inc $32
00195F  2  C6 31            dec $31
001961  2  F0 0F            beq @return
001963  2               
001963  2                   ; move to the next object
001963  2  18               clc
001964  2  A5 08            lda r3L
001966  2  69 1C            adc #.sizeof(Object)
001968  2  85 08            sta r3L
00196A  2  A5 09            lda r3H
00196C  2  69 00            adc #00
00196E  2  85 09            sta r3H
001970  2               
001970  2  80 E8            bra @loop
001972  2               
001972  2               @return:
001972  2  60               rts
001973  2               
001973  2               ;************************************************
001973  2               ; find the object with a sprite ID
001973  2               ;   input: A = spriteID
001973  2               ;   output: (r3) start of the object
001973  2               ;           Y = EntityID, $FF if no object
001973  2               ;
001973  2               get_by_spriteID:
001973  2  85 60            sta OBJECT_ZP
001975  2               
001975  2  AD 5E 18         lda objects_map
001978  2  85 08            sta r3L
00197A  2  AD 5F 18         lda objects_map + 1
00197D  2  85 09            sta r3H
00197F  2               
00197F  2  B2 08            lda (r3)            ; number of objects
001981  2  AA               tax
001982  2  E6 08            inc r3L             ; move to the first object
001984  2               
001984  2  A0 01            ldy #Entity::spriteID
001986  2               @loop:
001986  2  B1 08            lda (r3), y
001988  2  C5 60            cmp OBJECT_ZP
00198A  2  F0 12            beq @found
00198C  2               
00198C  2                   ; last object ?
00198C  2  CA               dex
00198D  2  F0 15            beq @no_object
00198F  2               
00198F  2                   ; move to the next object
00198F  2  18               clc
001990  2  A5 08            lda r3L
001992  2  69 1C            adc #.sizeof(Object)
001994  2  85 08            sta r3L
001996  2  A5 09            lda r3H
001998  2  69 00            adc #00
00199A  2  85 09            sta r3H
00199C  2  80 E8            bra @loop
00199E  2               
00199E  2               @found:
00199E  2  A0 00            ldy #Entity::id
0019A0  2  B1 08            lda (r3), y
0019A2  2  A8               tay
0019A3  2  60               rts
0019A4  2               
0019A4  2               @no_object:
0019A4  2  A0 FF            ldy #$ff
0019A6  2  60               rts
0019A7  2               
0019A7  2               ;************************************************
0019A7  2               ; virtual function move_right
0019A7  2               ;   input: r3 = start of the object
0019A7  2               move_right:
0019A7  2  A9 01        	lda #01
0019A9  2  85 6E        	sta Entities::bBasicCollisionTest		; for objects do basic collision
0019AB  2               
0019AB  2  20 63 17         jsr Entities::move_right
0019AE  2               
0019AE  2  64 6E        	stz Entities::bBasicCollisionTest		; remove basic collision
0019B0  2  60               rts
0019B1  2               
0019B1  2               ;************************************************
0019B1  2               ; virtual function move_left
0019B1  2               ;   input: r3 = start of the object
0019B1  2               move_left:
0019B1  2  A9 01        	lda #01
0019B3  2  85 6E        	sta Entities::bBasicCollisionTest		; for objects do basic collision
0019B5  2               
0019B5  2  20 AA 17         jsr Entities::move_left
0019B8  2               
0019B8  2  64 6E        	stz Entities::bBasicCollisionTest		; remove basic collision
0019BA  2  60               rts
0019BB  2               
0019BB  2               .endscope
0019BB  2               
0019BB  1               .include "layers.asm"
0019BB  2               ;-----------------------------------------------------------------------------
0019BB  2               ;/////////////////////////////////////////////////////////////////////////////
0019BB  2               ; START Layers code
0019BB  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
0019BB  2               ;-----------------------------------------------------------------------------
0019BB  2               
0019BB  2               .scope Layers
0019BB  2               
0019BB  2               LAYERS_ZP = $0055
0019BB  2               wHScroll = LAYERS_ZP
0019BB  2               wVScroll = LAYERS_ZP + 2
0019BB  2               bDirty = LAYERS_ZP + 4
0019BB  2               
0019BB  2               HSCROLL = 0
0019BB  2               VSCROLL = 2
0019BB  2               
0019BB  2               ;************************************************
0019BB  2               ; init layers module
0019BB  2               ;
0019BB  2               init:
0019BB  2  64 55        	stz wHScroll
0019BD  2  64 56        	stz wHScroll + 1
0019BF  2               
0019BF  2  64 57        	stz wVScroll
0019C1  2  64 58        	stz wVScroll + 1
0019C3  2               
0019C3  2  64 59        	stz bDirty
0019C5  2  60           	rts
0019C6  2               
0019C6  2               ;************************************************
0019C6  2               ; set layer1 X position
0019C6  2               ; input: X = xLO
0019C6  2               ;		 Y = xHI
0019C6  2               set_x:
0019C6  2               	; is a real change requested ?
0019C6  2  C4 56        	cpy wHScroll + 1
0019C8  2  D0 05        	bne @dirty
0019CA  2  E4 55        	cpx wHScroll
0019CC  2  D0 01        	bne @dirty
0019CE  2  60           	rts
0019CF  2               @dirty:
0019CF  2  86 55        	stx wHScroll
0019D1  2  8E 37 9F     	stx VERA_L1_hscrolllo
0019D4  2  84 56        	sty wHScroll + 1
0019D6  2  8C 38 9F     	sty VERA_L1_hscrollhi
0019D9  2               
0019D9  2  A9 01        	lda #01
0019DB  2  85 59        	sta bDirty
0019DD  2  60           	rts
0019DE  2               
0019DE  2               ;************************************************
0019DE  2               ; set layer1 y position
0019DE  2               ; input: X = yLO
0019DE  2               ;		 Y = yHI
0019DE  2               set_y:
0019DE  2               	; is a real change requested ?
0019DE  2  C4 58        	cpy wVScroll + 1
0019E0  2  D0 05        	bne @dirty
0019E2  2  E4 57        	cpx wVScroll
0019E4  2  D0 01        	bne @dirty
0019E6  2  60           	rts
0019E7  2               @dirty:
0019E7  2  86 57        	stx wVScroll
0019E9  2  8E 39 9F     	stx VERA_L1_vscrolllo
0019EC  2  84 58        	sty wVScroll + 1
0019EE  2  8C 3A 9F     	sty VERA_L1_vscrollhi
0019F1  2               
0019F1  2  A9 01        	lda #01
0019F3  2  85 59        	sta bDirty
0019F5  2  60           	rts
0019F6  2               
0019F6  2               ;************************************************
0019F6  2               ; increase layer scrolling with a 8bits limit
0019F6  2               ;	X: : 0 = horizontal
0019F6  2               ;	   : 2 = vertical
0019F6  2               ;	Y: limit
0019F6  2               ;
0019F6  2               scroll_inc_8:
0019F6  2  84 02        	sty r0L
0019F8  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
0019FB  2  C5 02        	cmp r0L
0019FD  2  F0 0F        	beq @noscroll
0019FF  2               @scrollinc:
0019FF  2  1A           	inc
001A00  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
001A03  2  D0 03        	bne @scrolled
001A05  2  FE 38 9F     	inc VERA_L1_hscrollhi, x
001A08  2               @scrolled:
001A08  2               	; fix the objects position now that the layers scrolled
001A08  2  20 48 19     	jsr Objects::fix_positions
001A0B  2  A9 01        	lda #01		; clear ZERO => scrolled
001A0D  2  60           	rts
001A0E  2               @noscroll:
001A0E  2  A9 00        	lda #00		; set ZERO => noscroll
001A10  2  60           	rts
001A11  2               
001A11  2               ;************************************************
001A11  2               ; increase layer scrolling with a 16bits limit
001A11  2               ;	X: : 0 = horizontal
001A11  2               ;	   : 2 = vertical
001A11  2               ;	r0L: limit
001A11  2               ;
001A11  2               scroll_inc_16:
001A11  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
001A14  2  C5 02        	cmp r0L
001A16  2  D0 09        	bne @scrollinc								; if low bits are not equals to the limit low bits => safe to increase
001A18  2  A8           	tay
001A19  2  BD 38 9F     	lda VERA_L1_hscrollhi, x
001A1C  2  C5 03        	cmp r0H
001A1E  2  F0 10        	beq @noscroll								; if high bits are equals to the limit high bits => we reached the limit
001A20  2  98           	tya
001A21  2               @scrollinc:
001A21  2  1A           	inc
001A22  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
001A25  2  D0 03        	bne @scrolled
001A27  2  FE 38 9F     	inc VERA_L1_hscrollhi, x
001A2A  2               @scrolled:
001A2A  2               	; fix the objects position now that the layers scrolled
001A2A  2  20 48 19     	jsr Objects::fix_positions
001A2D  2  A9 01        	lda #01	; clear ZERO => scrolled
001A2F  2  60           	rts
001A30  2               @noscroll:
001A30  2  A9 00        	lda #00	; set ZERO => noscroll
001A32  2  60           	rts
001A33  2               
001A33  2               ; increase a layer scroll offset but do NOT overlap
001A33  2               .macro VSCROLL_INC direction,limit
001A33  2               .if limit > 255
001A33  2               	LOAD_r0 limit
001A33  2               	ldx #direction
001A33  2               	jsr Layers::scroll_inc_16
001A33  2               .else
001A33  2               	ldy #limit
001A33  2               	ldx #direction
001A33  2               	jsr Layers::scroll_inc_8
001A33  2               .endif
001A33  2               .endmacro
001A33  2               
001A33  2               ;
001A33  2               ;
001A33  2               ; decrease a layer scroll offset
001A33  2               ;	X : 0 = horizontal
001A33  2               ;	  : 2 = vertical
001A33  2               ;
001A33  2               scroll_dec:
001A33  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
001A36  2  F0 06        	beq @scrollHI			; 00 => decrease high bits
001A38  2  3A           	dec
001A39  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
001A3C  2  80 0E        	bra @scrolled
001A3E  2               @scrollHI:
001A3E  2  BC 38 9F     	ldy VERA_L1_hscrollhi, x
001A41  2  F0 0F        	beq @noscroll		; 0000 => no scrolling
001A43  2  3A           	dec
001A44  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
001A47  2  88           	dey
001A48  2  98           	tya
001A49  2  9D 38 9F     	sta VERA_L1_hscrollhi, x
001A4C  2               
001A4C  2               @scrolled:
001A4C  2               	; fix the objects position now that the layers scrolled
001A4C  2  20 55 12     	jsr Entities::fix_positions
001A4F  2  A9 01        	lda #01		; clear ZERO => scrolled
001A51  2  60           	rts
001A52  2               
001A52  2               @noscroll:
001A52  2  A9 00        	lda #00		; set ZERO => noscroll
001A54  2  60           	rts
001A55  2               
001A55  2               ;************************************************
001A55  2               ; refresh layers
001A55  2               ;		layer 0 : scrolling to be half of the layer1 scrolling
001A55  2               ;		entities : screen position = entity position - layers1 position
001A55  2               ;
001A55  2               update:
001A55  2  A5 59        	lda bDirty
001A57  2  F0 1D        	beq @return
001A59  2               
001A59  2  A5 56        	lda wHScroll + 1		; layer0 hScroll is layer 1 / 2
001A5B  2  4A           	lsr
001A5C  2  8D 31 9F     	sta VERA_L0_hscrollhi
001A5F  2  A5 55        	lda wHScroll
001A61  2  6A           	ror
001A62  2  8D 30 9F     	sta VERA_L0_hscrolllo
001A65  2               
001A65  2  A5 58        	lda wVScroll + 1		; layer0 hScroll is layer 1 / 2
001A67  2  4A           	lsr
001A68  2  8D 33 9F     	sta VERA_L0_vscrollhi
001A6B  2  A5 57        	lda wVScroll
001A6D  2  6A           	ror
001A6E  2  8D 32 9F     	sta VERA_L0_vscrolllo
001A71  2               
001A71  2               	; fix the objects position now that the layers scrolled
001A71  2  20 55 12     	jsr Entities::fix_positions
001A74  2               
001A74  2               	; clear dirty flag
001A74  2  64 59        	stz bDirty
001A76  2               @return:
001A76  2  60           	rts
001A77  2               .endscope
001A77  2               
001A77  1               .include "player.asm"
001A77  2               ;-----------------------------------------------------------------------------
001A77  2               ;/////////////////////////////////////////////////////////////////////////////
001A77  2               ; START player code
001A77  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
001A77  2               ;-----------------------------------------------------------------------------
001A77  2               
001A77  2               PLAYER_SPRITE_ANIMATION = 3
001A77  2               
001A77  2               JUMP_LO_TICKS = 10
001A77  2               JUMP_HI_TICKS = 2
001A77  2               FALL_LO_TICKS = 8
001A77  2               FALL_HI_TICKS = 2
001A77  2               
001A77  2               PLAYER_ZP = $0050
001A77  2               addrSaveR0L = PLAYER_ZP + 1
001A77  2               addrSaveR0H = addrSaveR0L + 1
001A77  2               
001A77  2               PNG_SPRITES_LINES = 6
001A77  2               PNG_SPRITES_COLUMNS = 3
001A77  2               
001A77  2               .enum
001A77  2               	STATUS_WALKING_IDLE
001A77  2               	STATUS_WALKING
001A77  2               	STATUS_CLIMBING
001A77  2               	STATUS_CLIMBING_IDLE
001A77  2               	STATUS_FALLING
001A77  2               	STATUS_JUMPING
001A77  2               	STATUS_JUMPING_IDLE
001A77  2               	STATUS_PUSHING
001A77  2               .endenum
001A77  2               
001A77  2               .enum
001A77  2               	SITTING_NO_SLOP
001A77  2               	SITTING_ON_SLOPE
001A77  2               	SITTING_ABOVE_SLOPE
001A77  2               .endenum
001A77  2               
001A77  2               .struct PLAYER
001A77  2               	entity			.tag Entity
001A77  2               	animation_tick	.byte
001A77  2               	frameID 		.byte	; current animation loop start
001A77  2               	frame 			.byte	; current frame
001A77  2               	frameDirection 	.byte 	; direction of the animation
001A77  2               	flip 			.byte
001A77  2               	grab_left_right .byte	; grabbed object is on the lef tor on the right
001A77  2               	vera_bitmaps    .res 	(2 * 3 * 5)	; 9 words to store vera bitmaps address
001A77  2               .endstruct
001A77  2               
001A77  2               player0 = $0500
001A77  2               player0_end = player0 + .sizeof(PLAYER)
001A77  2               
001A77  2               .macro m_status value
001A77  2               	lda #(value)
001A77  2               	sta player0 + PLAYER::entity + Entity::status
001A77  2               .endmacro
001A77  2               
001A77  2               .scope Player
001A77  2               
001A77  2               bCollisionID = PLAYER_ZP
001A77  2               
001A77  2               .macro SET_SPRITE id, frameval
001A77  2               	lda #id
001A77  2               	sta player0 + PLAYER::frameID
001A77  2               	lda #frameval
001A77  2               	sta player0 + PLAYER::frame
001A77  2               	jsr set_bitmap
001A77  2               .endmacro
001A77  2               
001A77  2               ;************************************************
001A77  2               ; player sprites status
001A77  2               ;
001A77  2               .enum Sprites
001A77  2               	FRONT = 0
001A77  2               	LEFT = FRONT + PNG_SPRITES_COLUMNS
001A77  2               	CLIMB = LEFT + PNG_SPRITES_COLUMNS
001A77  2               	HANG = CLIMB + PNG_SPRITES_COLUMNS
001A77  2               	PUSH = HANG + PNG_SPRITES_COLUMNS
001A77  2               	PULL = PUSH + PNG_SPRITES_COLUMNS
001A77  2               .endenum
001A77  2               
001A77  2               .enum Grab
001A77  2               	NONE = 0
001A77  2               	LEFT = 1
001A77  2               	RIGHT = 2
001A77  2               .endenum
001A77  2               
001A77  2               WIDTH = 16
001A77  2               HEIGHT = 32
001A77  2               
001A77  2               ;************************************************
001A77  2               ; local variables
001A77  2               ;
001A77  2               
001A77  2  00           ladders: .byte 0
001A78  2  00           test_right_left: .byte 0
001A79  2               
001A79  2               ;************************************************
001A79  2               ; init the player data
001A79  2               ;
001A79  2               init:
001A79  2  A2 00        	ldx #00
001A7B  2  A9 00        	lda #<player0
001A7D  2  85 08        	sta r3L
001A7F  2  A0 05        	ldy #>player0
001A81  2  84 09        	sty r3H
001A83  2  20 37 11     	jsr Entities::register
001A86  2  9C 00 05     	stz player0 + PLAYER::entity + Entity::id
001A89  2               
001A89  2  20 59 11     	jsr Entities::init
001A8C  2               
001A8C  2  A9 0A        	lda #10
001A8E  2  A0 1A        	ldy #PLAYER::animation_tick
001A90  2  91 08        	sta (r3), y
001A92  2  A9 03        	lda #Player::Sprites::LEFT
001A94  2  A0 1B        	ldy #PLAYER::frameID
001A96  2  91 08        	sta (r3), y
001A98  2  A9 00        	lda #00
001A9A  2  A0 1C        	ldy #PLAYER::frame
001A9C  2  91 08        	sta (r3), y
001A9E  2  A9 01        	lda #1
001AA0  2  A0 1D        	ldy #PLAYER::frameDirection
001AA2  2  91 08        	sta (r3), y
001AA4  2  A9 00        	lda #00
001AA6  2  A0 1E        	ldy #PLAYER::flip
001AA8  2  91 08        	sta (r3), y
001AAA  2  A9 00        	lda #00
001AAC  2  A0 1F        	ldy #PLAYER::grab_left_right
001AAE  2  91 08        	sta (r3), y
001AB0  2               
001AB0  2               	; player sprite is 32x32, but collision box is 16x32
001AB0  2  A0 0B        	ldy #Entity::bWidth
001AB2  2  A9 10        	lda #Player::WIDTH
001AB4  2  91 08        	sta (r3), y
001AB6  2  A0 0C        	ldy #Entity::bHeight
001AB8  2  A9 20        	lda #Player::HEIGHT
001ABA  2  91 08        	sta (r3), y
001ABC  2               
001ABC  2               	; player collision box is shifted by (8,0) pixels compared to sprite top-left corner
001ABC  2  A9 08        	lda #08
001ABE  2  A0 0E        	ldy #Entity::bXOffset
001AC0  2  91 08        	sta (r3), y
001AC2  2  A9 00        	lda #00
001AC4  2  A0 0F        	ldy #Entity::bYOffset
001AC6  2  91 08        	sta (r3), y
001AC8  2               
001AC8  2               	; register virtual function bind/unbind
001AC8  2  A0 14        	ldy #Entity::fnUnbind
001ACA  2  A9 B3        	lda #<Player::unbind
001ACC  2  91 08        	sta (r3),y
001ACE  2  C8           	iny
001ACF  2  A9 21        	lda #>Player::unbind
001AD1  2  91 08        	sta (r3),y
001AD3  2               
001AD3  2               	; register virtual function move_right/left
001AD3  2  A0 16        	ldy #Entity::fnMoveRight
001AD5  2  A9 00        	lda #00
001AD7  2  91 08        	sta (r3),y
001AD9  2  C8           	iny
001ADA  2  91 08        	sta (r3),y
001ADC  2  C8           	iny
001ADD  2  91 08        	sta (r3),y
001ADF  2  C8           	iny
001AE0  2  91 08        	sta (r3),y
001AE2  2               
001AE2  2               	; load sprites data at the end of the tiles
001AE2  2  A9 01 A2 08  	VLOAD_FILE fssprite, (fsspriteend-fssprite), (::VRAM_tiles + tiles * tile_size)
001AE6  2  A0 00 20 BA  
001AEA  2  FF A9 0B A2  
001B03  2               
001B03  2  AD 20 05     	lda player0 + PLAYER::vera_bitmaps
001B06  2  85 02        	sta r0L
001B08  2  AD 21 05     	lda player0 + PLAYER::vera_bitmaps+1
001B0B  2  85 03        	sta r0H
001B0D  2               
001B0D  2  A0 01        	ldy #Entity::spriteID
001B0F  2  B1 08        	lda (r3),y
001B11  2  A8           	tay
001B12  2  A9 10        	lda #%00010000					; collision mask 1
001B14  2  A2 A0        	ldx #%10100000					; 32x32 sprite
001B16  2  20 FB 0C     	jsr Sprite::load
001B19  2               
001B19  2  A9 08        	lda #08
001B1B  2  85 02        	sta r0L
001B1D  2  A9 00        	lda #00
001B1F  2  85 03        	sta r0H
001B21  2  A9 0F        	lda #15
001B23  2  85 04        	sta r1L
001B25  2  A9 1F        	lda #31
001B27  2  85 05        	sta r1H
001B29  2               
001B29  2  A0 01        	ldy #Entity::spriteID
001B2B  2  B1 08        	lda (r3),y
001B2D  2  A8           	tay
001B2E  2  20 43 0D     	jsr Sprite::set_aabb			; collision box (8,0) -> (24, 32)
001B31  2               
001B31  2               	; turn sprite 0 on
001B31  2  A0 01        	ldy #Entity::spriteID
001B33  2  B1 08        	lda (r3),y
001B35  2  A8           	tay
001B36  2  A2 0C        	ldx #SPRITE_ZDEPTH_TOP
001B38  2  20 86 0D     	jsr Sprite::display
001B3B  2               
001B3B  2               	; register the vera simplified memory 12:5
001B3B  2  A0 12        	ldy #(PNG_SPRITES_COLUMNS * PNG_SPRITES_LINES)
001B3D  2  84 50        	sty PLAYER_ZP
001B3F  2  A0 20        	ldy #PLAYER::vera_bitmaps
001B41  2  A9 00 85 04  	LOAD_r1 (::VRAM_tiles + tiles * tile_size)
001B45  2  A9 41 85 05  
001B49  2               
001B49  2               @loop:
001B49  2               	; load full VERA memory (12:0) into R0
001B49  2  A5 04        	lda r1L
001B4B  2  85 02        	sta r0L
001B4D  2  A5 05        	lda r1H
001B4F  2  85 03        	sta r0H
001B51  2               
001B51  2               	; convert full addr to vera mode (bit shiting >> 5)
001B51  2  A5 03        	lda r0H
001B53  2  4A           	lsr
001B54  2  66 02        	ror r0L
001B56  2  4A           	lsr
001B57  2  66 02        	ror r0L
001B59  2  4A           	lsr
001B5A  2  66 02        	ror r0L
001B5C  2  4A           	lsr
001B5D  2  66 02        	ror r0L						; bit shift 4x 16 bits vera memory
001B5F  2  4A           	lsr
001B60  2  66 02        	ror r0L						; bit shift 4x 16 bits vera memory
001B62  2               
001B62  2               	; store 12:5 into our cache
001B62  2  91 08        	sta (r3), y
001B64  2  C8           	iny
001B65  2  A5 02        	lda r0L
001B67  2  91 08        	sta (r3), y
001B69  2  C8           	iny
001B6A  2               
001B6A  2               	; increase the vram (+4 r1H = +1024 r1)
001B6A  2  18           	clc
001B6B  2  A5 05        	lda r1H
001B6D  2  69 04        	adc #4
001B6F  2  85 05        	sta r1H
001B71  2               
001B71  2  C6 50        	dec PLAYER_ZP
001B73  2  D0 D4        	bne @loop
001B75  2               
001B75  2               	; set first bitmap
001B75  2  20 79 1B     	jsr set_bitmap
001B78  2  60           	rts
001B79  2               
001B79  2               ;************************************************
001B79  2               ; change the player bitmap
001B79  2               ;
001B79  2               set_bitmap:
001B79  2  18           	clc
001B7A  2  AD 1C 05     	lda player0 + PLAYER::frame
001B7D  2  6D 1B 05     	adc player0 + PLAYER::frameID
001B80  2  0A           	asl						; convert sprite index to work position
001B81  2  AA           	tax
001B82  2               
001B82  2               	; extract the vera bitmap address in vera format (12:5 bits)
001B82  2  BD 20 05     	lda player0 + PLAYER::vera_bitmaps, x
001B85  2  85 03        	sta r0H
001B87  2  BD 21 05     	lda player0 + PLAYER::vera_bitmaps + 1, x
001B8A  2  85 02        	sta r0L
001B8C  2               
001B8C  2  AC 01 05     	ldy player0 + PLAYER::entity + Entity::spriteID
001B8F  2  20 74 0D     	jsr Sprite::set_bitmap
001B92  2  60           	rts
001B93  2               
001B93  2               ;************************************************
001B93  2               ; move layers if the player sprite reached the screen boundaries
001B93  2               ;
001B93  2               check_scroll_layers:
001B93  2               	; distance from layer border to sprite absolute position
001B93  2  38           	sec
001B94  2  AD 04 05     	lda player0 + PLAYER::entity + Entity::levelx
001B97  2  E5 55        	sbc Layers::wHScroll
001B99  2  85 02        	sta r0L
001B9B  2  AD 05 05     	lda player0 + PLAYER::entity + Entity::levelx + 1
001B9E  2  E5 56        	sbc Layers::wHScroll + 1
001BA0  2  85 03        	sta r0H									; r0 = dx = level.x - layer.x
001BA2  2               
001BA2  2  D0 26        	bne @check_right						; dx > 256, no need to check left
001BA4  2               @check_left:
001BA4  2  A5 02        	lda r0L
001BA6  2  C9 40        	cmp #64
001BA8  2  B0 20        	bcs @check_right						; dx > 96 and dx < 256, no need to check left
001BAA  2               	; are we on far left of the layer ?
001BAA  2  A5 56        	lda Layers::wHScroll + 1
001BAC  2  D0 04        	bne @scroll_layer_left					; H_SCROLL > 256, scroll layer
001BAE  2  A5 55        	lda Layers::wHScroll
001BB0  2  F0 0F        	beq @set_x_0							; H_SCROLL == 0 => NO horizontal scroll
001BB2  2               @scroll_layer_left:
001BB2  2  38           	sec
001BB3  2  AD 04 05     	lda player0 + PLAYER::entity + Entity::levelx
001BB6  2  E9 40        	sbc #64
001BB8  2  AA           	tax
001BB9  2  AD 05 05     	lda player0 + PLAYER::entity + Entity::levelx + 1
001BBC  2  E9 00        	sbc #00
001BBE  2  A8           	tay
001BBF  2  80 04        	bra @fix_layer_0_x
001BC1  2               @set_x_0:
001BC1  2  A2 00        	ldx #00
001BC3  2  A0 00        	ldy #00
001BC5  2               @fix_layer_0_x:
001BC5  2  20 C6 19     	jsr Layers::set_x
001BC8  2  80 21        	bra @check_top
001BCA  2               
001BCA  2               @check_right:
001BCA  2  A5 02        	lda r0L
001BCC  2  C9 F1        	cmp #<(SCREEN_WIDTH - 63 - Player::WIDTH)		; remove the width of the sprite
001BCE  2  90 1B        	bcc @check_top							; dx < 320 - 96, no need to check right
001BD0  2               	; are we on far right of the layer ?
001BD0  2  A5 55        	lda Layers::wHScroll
001BD2  2  C9 BF        	cmp #(32*16-320 - 1)
001BD4  2  B0 0F        	bcs @set_x_max							; H_SCROLL > 192 (512 - 320) => force max
001BD6  2               
001BD6  2  38           	sec
001BD7  2  AD 04 05     	lda player0 + PLAYER::entity + Entity::levelx
001BDA  2  E9 F0        	sbc #<(320 - 64 - Player::WIDTH)
001BDC  2  AA           	tax
001BDD  2  AD 05 05     	lda player0 + PLAYER::entity + Entity::levelx + 1
001BE0  2  E9 00        	sbc #>(320 - 64 - Player::WIDTH)
001BE2  2  A8           	tay
001BE3  2  80 E0        	bra @fix_layer_0_x
001BE5  2               @set_x_max:
001BE5  2  A2 C0        	ldx #<(32*16-320)
001BE7  2  A0 00        	ldy #>(32*16-320)
001BE9  2  80 DA        	bra @fix_layer_0_x
001BEB  2               
001BEB  2               @check_top:
001BEB  2               	; distance from layer border to sprite absolute position
001BEB  2  38           	sec
001BEC  2  AD 06 05     	lda player0 + PLAYER::entity + Entity::levely
001BEF  2  E5 57        	sbc Layers::wVScroll
001BF1  2  85 02        	sta r0L
001BF3  2  AD 07 05     	lda player0 + PLAYER::entity + Entity::levely + 1
001BF6  2  E5 58        	sbc Layers::wVScroll + 1
001BF8  2  85 03        	sta r0H									; r0 = dy = level.y - layer.y
001BFA  2               
001BFA  2  D0 25        	bne @check_bottom						; dy > 256, no need to check top
001BFC  2               @check_top_1:
001BFC  2  A5 02        	lda r0L
001BFE  2  C9 20        	cmp #Player::HEIGHT
001C00  2  B0 1F        	bcs @check_bottom						; dy > 96 and dy < 256, check bottom
001C02  2               @move_y:
001C02  2               	; are we on far top of the layer ?
001C02  2  A5 58        	lda Layers::wVScroll + 1
001C04  2  D0 04        	bne @scroll_layer_top					; V_SCROLL > 256, scroll layer
001C06  2  A5 57        	lda Layers::wVScroll
001C08  2  F0 0F        	beq @set_y_0							; V_SCROLL == 0 => NO vertical scroll
001C0A  2               @scroll_layer_top:
001C0A  2  38           	sec
001C0B  2  AD 06 05     	lda player0 + PLAYER::entity + Entity::levely
001C0E  2  E9 20        	sbc #Player::HEIGHT
001C10  2  AA           	tax
001C11  2  AD 07 05     	lda player0 + PLAYER::entity + Entity::levely + 1
001C14  2  E9 00        	sbc #00
001C16  2  A8           	tay
001C17  2  80 04        	bra @fix_layer_0_y
001C19  2               @set_y_0:
001C19  2  A2 00        	ldx #00
001C1B  2  A0 00        	ldy #00
001C1D  2               @fix_layer_0_y:
001C1D  2  20 DE 19     	jsr Layers::set_y
001C20  2  60           	rts
001C21  2               
001C21  2               @check_bottom:
001C21  2  A5 02        	lda r0L
001C23  2  C9 B0        	cmp #<(240 - Player::HEIGHT * 2)
001C25  2  B0 01        	bcs @scroll_bottom
001C27  2  60           	rts										; dy < 144, no need to check vertical
001C28  2               @scroll_bottom:
001C28  2               	; are we on far bottom of the layer ?
001C28  2  A5 58        	lda Layers::wVScroll + 1
001C2A  2  F0 06        	beq @scroll_layer_bottom				; V_SCROLL < 256, scroll layer
001C2C  2  A5 57        	lda Layers::wVScroll
001C2E  2  C9 0F        	cmp #<(32*16-240 - 1)
001C30  2  B0 0F        	bcs @set_y_max							; V_SCROLL == 512-240 => NO vertical scroll
001C32  2               @scroll_layer_bottom:
001C32  2  38           	sec
001C33  2  AD 06 05     	lda player0 + PLAYER::entity + Entity::levely
001C36  2  E9 B0        	sbc #<(240 - Player::HEIGHT*2)
001C38  2  AA           	tax
001C39  2  AD 07 05     	lda player0 + PLAYER::entity + Entity::levely + 1
001C3C  2  E9 00        	sbc #>(240 - Player::HEIGHT*2)
001C3E  2  A8           	tay
001C3F  2  80 DC        	bra @fix_layer_0_y
001C41  2               @set_y_max:
001C41  2  A2 10        	ldx #<(32*16-240)
001C43  2  A0 01        	ldy #>(32*16-240)
001C45  2  80 D6        	bra @fix_layer_0_y
001C47  2               
001C47  2               ;************************************************
001C47  2               ; hide the current sprite
001C47  2               ;
001C47  2               hide1:
001C47  2  DB           	stp
001C48  2  18           	clc
001C49  2  AD 1C 05     	lda player0 + PLAYER::frame
001C4C  2  6D 1B 05     	adc player0 + PLAYER::frameID
001C4F  2  A8           	tay		; sprite index
001C50  2  A2 00        	ldx #SPRITE_ZDEPTH_DISABLED
001C52  2  20 86 0D     	jsr Sprite::display			; turn current sprite off
001C55  2  60           	rts
001C56  2               
001C56  2               ;************************************************
001C56  2               ; Animate the player if needed
001C56  2               ;
001C56  2               animate:
001C56  2  AD 02 05     	lda player0 + PLAYER::entity + Entity::status
001C59  2  C9 00        	cmp #STATUS_WALKING_IDLE
001C5B  2  F0 37        	beq @end
001C5D  2  C9 04        	cmp #STATUS_FALLING
001C5F  2  F0 33        	beq @end
001C61  2  C9 03        	cmp #STATUS_CLIMBING_IDLE
001C63  2  F0 2F        	beq @end
001C65  2               
001C65  2  CE 1A 05     	dec player0 + PLAYER::animation_tick
001C68  2  D0 2A        	bne @end
001C6A  2               
001C6A  2  A9 0A        	lda #10
001C6C  2  8D 1A 05     	sta player0 + PLAYER::animation_tick	; reset animation tick counter
001C6F  2               
001C6F  2  18           	clc
001C70  2  AD 1C 05     	lda player0 + PLAYER::frame
001C73  2  6D 1D 05     	adc player0 + PLAYER::frameDirection
001C76  2  F0 06        	beq @set_sprite_anim_increase					; reached 0
001C78  2  C9 03        	cmp #3
001C7A  2  F0 0B        	beq @set_sprite_anim_decrease
001C7C  2  80 10        	bra @set_sprite_on
001C7E  2               @set_sprite_anim_increase:
001C7E  2  A9 01        	lda #01
001C80  2  8D 1D 05     	sta player0 + PLAYER::frameDirection
001C83  2  A9 00        	lda #0
001C85  2  80 07        	bra @set_sprite_on
001C87  2               @set_sprite_anim_decrease:
001C87  2  A9 FF        	lda #$ff
001C89  2  8D 1D 05     	sta player0 + PLAYER::frameDirection
001C8C  2  A9 02        	lda #2
001C8E  2               @set_sprite_on:
001C8E  2  8D 1C 05     	sta player0 + PLAYER::frame	; turn next sprite on
001C91  2  20 79 1B     	jsr Player::set_bitmap
001C94  2               @end:
001C94  2  60           	rts
001C95  2               
001C95  2               ;************************************************
001C95  2               ; force player status to be idle
001C95  2               ;
001C95  2               set_idle:
001C95  2  AD 02 05     	lda player0 + PLAYER::entity + Entity::status
001C98  2  C9 01        	cmp #STATUS_WALKING
001C9A  2  F0 06        	beq @set_idle_walking
001C9C  2  C9 02        	cmp #STATUS_CLIMBING
001C9E  2  F0 08        	beq @set_idle_climbing
001CA0  2  60           	rts							; keep the current value
001CA1  2               @set_idle_jump:
001CA1  2  60           	rts
001CA2  2               @set_idle_walking:
001CA2  2  A9 00 8D 02  	m_status STATUS_WALKING_IDLE
001CA6  2  05           
001CA7  2  60           	rts
001CA8  2               @set_idle_climbing:
001CA8  2  A9 03 8D 02  	m_status STATUS_CLIMBING_IDLE
001CAC  2  05           
001CAD  2  60           	rts
001CAE  2               
001CAE  2               ;************************************************
001CAE  2               ; status to ignore while moving
001CAE  2               ;
001CAE  2               ignore_move_request:
001CAE  2  00           	.byte	00	;	STATUS_WALKING_IDLE
001CAF  2  00           	.byte	00	;	STATUS_WALKING
001CB0  2  02           	.byte	02	;	STATUS_CLIMBING
001CB1  2  02           	.byte	02	;	STATUS_CLIMBING_IDLE
001CB2  2  01           	.byte	01	;	STATUS_FALLING
001CB3  2  01           	.byte	01	;	STATUS_JUMPING
001CB4  2  01           	.byte	01	;	STATUS_JUMPING_IDLE
001CB5  2  00           	.byte	00	;	STATUS_PUSHING
001CB6  2               
001CB6  2               ;************************************************
001CB6  2               ; Try to move player to the right, walk up if facing a slope
001CB6  2               ;
001CB6  2               move_right:
001CB6  2               	; only move if the status is compatible
001CB6  2  AC 02 05     	ldy player0 + PLAYER::entity + Entity::status
001CB9  2  B9 AE 1C     	lda ignore_move_request, y
001CBC  2  F0 08        	beq @walk_push_pull_right		; if 0 => can move
001CBE  2  C9 02        	cmp #02
001CC0  2  F0 01        	beq :+							; if 2 => has to climb
001CC2  2  60           	rts								; else block the move
001CC3  2               :
001CC3  2  4C DD 1D     	jmp @climb_right
001CC6  2               
001CC6  2               @walk_push_pull_right:
001CC6  2  AE 03 05     	ldx player0 + PLAYER::entity + Entity::connectedID
001CC9  2  E0 FF        	cpx #$ff
001CCB  2  F0 0D        	beq @walk_right				; entityID cannot be 0
001CCD  2               
001CCD  2               	; if the player is pushing right an object located on its right, move the object first
001CCD  2  AD 1F 05     	lda player0 + PLAYER::grab_left_right
001CD0  2  C9 02        	cmp #Grab::RIGHT
001CD2  2  D0 06        	bne @walk_right
001CD4  2  20 20 18     	jsr Entities::fn_move_right
001CD7  2  F0 01        	beq @walk_right				; cannot move the grabbed object => refuse to move
001CD9  2  60           	rts
001CDA  2               
001CDA  2               @walk_right:
001CDA  2  A2 00        	ldx #00
001CDC  2  20 72 12     	jsr Entities::save_position
001CDF  2  20 63 17     	jsr Entities::move_right
001CE2  2  F0 01        	beq @set_sprite
001CE4  2  60           	rts							; blocked by tile, border or sprite
001CE5  2               
001CE5  2               @no_collision:
001CE5  2               @set_sprite:
001CE5  2               	; pick the correct sprite animation based on move or push or pull
001CE5  2  AD 1F 05     	lda player0 + PLAYER::grab_left_right
001CE8  2  C9 00        	cmp #Grab::NONE
001CEA  2  F0 46        	beq @set_walk_right
001CEC  2  C9 01        	cmp #Grab::LEFT
001CEE  2  F0 21        	beq @set_pull_right
001CF0  2               
001CF0  2               @set_push_right:
001CF0  2  AD 1B 05     	lda player0 + PLAYER::frameID
001CF3  2  C9 0C        	cmp #Player::Sprites::PUSH
001CF5  2  F0 75        	beq @pull_object					; already push animation
001CF7  2               
001CF7  2  A5 02        	lda r0L								; set_bitmap overwrite r0, so we need to save
001CF9  2  85 51        	sta addrSaveR0L
001CFB  2  A5 03        	lda r0H
001CFD  2  85 52        	sta addrSaveR0H
001CFF  2               
001CFF  2  A9 0C        	lda #Player::Sprites::PUSH
001D01  2  8D 1B 05     	sta player0 + PLAYER::frameID
001D04  2  20 74 0D     	jsr Sprite::set_bitmap
001D07  2               
001D07  2  A5 51        	lda addrSaveR0L								; set_bitmap overwrite r0, so we need to restore
001D09  2  85 02        	sta r0L
001D0B  2  A5 52        	lda addrSaveR0H
001D0D  2  85 03        	sta r0H
001D0F  2               
001D0F  2  80 5B        	bra @pull_object
001D11  2               
001D11  2               @set_pull_right:
001D11  2  AD 1B 05     	lda player0 + PLAYER::frameID
001D14  2  C9 0F        	cmp #Player::Sprites::PULL
001D16  2  F0 54        	beq @pull_object					; already push animation
001D18  2               
001D18  2  A5 02        	lda r0L								; set_bitmap overwrite r0, so we need to save
001D1A  2  85 51        	sta addrSaveR0L
001D1C  2  A5 03        	lda r0H
001D1E  2  85 52        	sta addrSaveR0H
001D20  2               
001D20  2  A9 0F        	lda #Player::Sprites::PULL
001D22  2  8D 1B 05     	sta player0 + PLAYER::frameID
001D25  2  20 74 0D     	jsr Sprite::set_bitmap
001D28  2               
001D28  2  A5 51        	lda addrSaveR0L								; set_bitmap overwrite r0, so we need to restore
001D2A  2  85 02        	sta r0L
001D2C  2  A5 52        	lda addrSaveR0H
001D2E  2  85 03        	sta r0H
001D30  2               
001D30  2  80 3A        	bra @pull_object
001D32  2               
001D32  2               @set_walk_right:
001D32  2  A9 01        	lda #SPRITE_FLIP_H
001D34  2  8D 1E 05     	sta player0 + PLAYER::flip
001D37  2  AC 01 05     	ldy player0 + PLAYER::entity + Entity::spriteID
001D3A  2  20 34 0E     	jsr Sprite::set_flip				; force sprite to look right
001D3D  2               
001D3D  2               	; sprite is already the good one
001D3D  2  AD 02 05     	lda player0 + PLAYER::entity + Entity::status
001D40  2  C9 01        	cmp #STATUS_WALKING
001D42  2  F0 28        	beq @pull_object
001D44  2  C9 07        	cmp #STATUS_PUSHING
001D46  2  F0 24        	beq @pull_object
001D48  2               
001D48  2               	; force the sprite and status to walking (will keep the pushing status if needed)
001D48  2  A9 01 8D 02  	m_status STATUS_WALKING
001D4C  2  05           
001D4D  2               
001D4D  2               	;change player sprite
001D4D  2  A9 03        	lda #Player::Sprites::LEFT
001D4F  2  CD 1B 05     	cmp player0 + PLAYER::frameID
001D52  2  F0 18        	beq @pull_object
001D54  2               
001D54  2  A5 02        	lda r0L								; set_bitmap overwrite r0, so we need to save
001D56  2  85 51        	sta addrSaveR0L
001D58  2  A5 03        	lda r0H
001D5A  2  85 52        	sta addrSaveR0H
001D5C  2               
001D5C  2  A9 03        	lda #Player::Sprites::LEFT
001D5E  2  8D 1B 05     	sta player0 + PLAYER::frameID
001D61  2  20 74 0D     	jsr Sprite::set_bitmap
001D64  2               
001D64  2  A5 51        	lda addrSaveR0L								; set_bitmap overwrite r0, so we need to restore
001D66  2  85 02        	sta r0L
001D68  2  A5 52        	lda addrSaveR0H
001D6A  2  85 03        	sta r0H
001D6C  2               
001D6C  2               @pull_object:
001D6C  2               	; if the player is pulling right an object located on its left, move the object last
001D6C  2  AD 1F 05     	lda player0 + PLAYER::grab_left_right
001D6F  2  C9 01        	cmp #Grab::LEFT
001D71  2  D0 1F        	bne @check_slope
001D73  2  AE 03 05     	ldx player0 + PLAYER::entity + Entity::connectedID
001D76  2  20 20 18     	jsr Entities::fn_move_right
001D79  2  F0 05        	beq @validate_object_move
001D7B  2               
001D7B  2               	; object is blocked when being pulled (player on slope, object cannot be moved on slope)
001D7B  2               	; restore player position and exit
001D7B  2  A2 00        	ldx #00
001D7D  2  4C 96 12     	jmp Entities::restore_position
001D80  2               
001D80  2               @validate_object_move:
001D80  2  A9 00        	lda #<player0						; restore 'this'
001D82  2  85 08        	sta r3L
001D84  2  A9 05        	lda #>player0
001D86  2  85 09        	sta r3H
001D88  2  AD 10 05     	lda player0 + PLAYER::entity + Entity::collision_addr	; restore collision address
001D8B  2  85 02        	sta r0L
001D8D  2  AD 11 05     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
001D90  2  85 03        	sta r0H
001D92  2               
001D92  2               @check_slope:
001D92  2               	; if sitting on a slop
001D92  2  20 3D 15     	jsr Entities::if_on_slop
001D95  2  D0 08        	bne @move_slop
001D97  2               
001D97  2               	; TODO ///////////////////////
001D97  2  20 E4 11     	jsr Entities::get_collision_map
001D9A  2  20 08 15     	jsr Entities::if_above_slop			; check if NOW were are above a slope
001D9D  2  F0 3D        	beq @set_position
001D9F  2               	; TODO \\\\\\\\\\\\\\\\\\\\\\\\\\
001D9F  2               
001D9F  2               @move_slop:
001D9F  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
001DA1  2  F0 26        	beq @move_y_up
001DA3  2               @try_move_y_dow:
001DA3  2  AD 06 05     	lda player0 + PLAYER::entity + Entity::levely
001DA6  2  29 0F        	and #%00001111
001DA8  2  D0 1A        	bne @move_y_down
001DAA  2  AD 10 05     	lda player0 + PLAYER::entity + Entity::collision_addr
001DAD  2  85 02        	sta r0L
001DAF  2  AD 11 05     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
001DB2  2  85 03        	sta r0H
001DB4  2  A5 06        	lda r2L
001DB6  2  18           	clc
001DB7  2  69 41        	adc #(LEVEL_TILES_WIDTH * 2 + 1)	; check on the 2nd block
001DB9  2  A8           	tay
001DBA  2  B1 02        	lda (r0), y							; check if the tile below as an attribute SOLID_GROUND
001DBC  2  A8           	tay
001DBD  2  B9 1F 23     	lda tiles_attributes,y
001DC0  2  89 01        	bit #TILE_ATTR::SOLID_GROUND
001DC2  2  D0 7F        	bne @return							; do not change Y if the tile below the player is a solid one
001DC4  2               @move_y_down:
001DC4  2  20 04 13     	jsr Entities::position_y_inc
001DC7  2  80 13        	bra @set_position
001DC9  2               @move_y_up:
001DC9  2  AD 04 05     	lda player0 + PLAYER::entity + Entity::levelx
001DCC  2  29 0F        	and #%00001111
001DCE  2  C9 08        	cmp #08
001DD0  2  D0 07        	bne :+
001DD2  2  AD 06 05     	lda player0 + PLAYER::entity + Entity::levely
001DD5  2  29 0F        	and #%00001111
001DD7  2  F0 03        	beq @return1						; if x%8 == 0, y MUST be equal 0, or increase
001DD9  2               :
001DD9  2  20 24 13     	jsr Entities::position_y_dec
001DDC  2               
001DDC  2               @set_position:
001DDC  2               @return1:
001DDC  2  60           	rts
001DDD  2               
001DDD  2               @climb_right:
001DDD  2  20 FA 13     	jsr Entities::check_collision_right
001DE0  2  F0 05        	beq @climb_right_1
001DE2  2  C9 04        	cmp #TILE_SOLID_LADER
001DE4  2  F0 01        	beq @climb_right_1
001DE6  2  60           	rts
001DE7  2               @climb_right_1:
001DE7  2  20 46 13     	jsr Entities::bbox_coverage
001DEA  2               
001DEA  2  A2 01        	ldx #01
001DEC  2  A0 00        	ldy #00
001DEE  2  AD 04 05     	lda player0 + PLAYER::entity + Entity::levelx
001DF1  2  29 0F        	and #%00001111
001DF3  2  F0 01        	beq @get_tile
001DF5  2  E8           	inx								; if x%8 <> 0, test 2 tiles
001DF6  2               @get_tile:
001DF6  2  B1 02        	lda (r0),y
001DF8  2  F0 0E        	beq @no_grab					; no tile on right
001DFA  2  85 31        	sta $31
001DFC  2  84 30        	sty $30
001DFE  2  A8           	tay
001DFF  2  B9 1F 23     	lda tiles_attributes,y
001E02  2  89 08        	bit #TILE_ATTR::GRABBING
001E04  2  D0 08        	bne @climb_right_2				; tile on right with a GRAB attribute
001E06  2  A4 30        	ldy $30
001E08  2               @no_grab:							; test the tile on the right on next line
001E08  2  C8           	iny
001E09  2  CA           	dex
001E0A  2  D0 EA        	bne @get_tile
001E0C  2  80 23        	bra @climb_right_drop			; no grab tile on the right of the player
001E0E  2               @climb_right_2:
001E0E  2  A5 31        	lda $31							; tile index with grab attribute
001E10  2  C9 05        	cmp #TILE_LEDGE
001E12  2  D0 04        	bne @set_climb_sprite
001E14  2               @set_hang_sprite:
001E14  2  A9 09        	lda #Player::Sprites::HANG
001E16  2  80 02        	bra @next
001E18  2               @set_climb_sprite:
001E18  2  A9 06        	lda #Player::Sprites::CLIMB
001E1A  2               @next:
001E1A  2  8D 1B 05     	sta player0 + PLAYER::frameID
001E1D  2  20 79 1B     	jsr set_bitmap
001E20  2  A9 02 8D 02  	m_status STATUS_CLIMBING
001E24  2  05           
001E25  2  20 C2 12     	jsr Entities::position_x_inc		; move the player sprite, if the
001E28  2               	;TODO ///////////////////////
001E28  2  AD 0D 05     	lda player0 + PLAYER::entity + Entity::bFlags
001E2B  2  09 01        	ora #(EntityFlags::physics)
001E2D  2  8D 0D 05     	sta player0 + PLAYER::entity + Entity::bFlags	; activate physics engine
001E30  2               	;TODO ///////////////////////
001E30  2  60           	rts
001E31  2               @climb_right_drop:
001E31  2  A9 01 8D 02  	m_status STATUS_WALKING
001E35  2  05           
001E36  2  A9 03 8D 1B  	SET_SPRITE Player::Sprites::LEFT, 1
001E3A  2  05 A9 01 8D  
001E3E  2  1C 05 20 79  
001E43  2               
001E43  2               @return:
001E43  2  60           	rts
001E44  2               
001E44  2               ;************************************************
001E44  2               ; try to move the player to the left
001E44  2               ;
001E44  2               move_left:
001E44  2               	; only move if the status is compatible
001E44  2  AC 02 05     	ldy player0 + PLAYER::entity + Entity::status
001E47  2  B9 AE 1C     	lda ignore_move_request, y
001E4A  2  F0 08        	beq @walk_push_pull_left		; if 0 => can move
001E4C  2  C9 02        	cmp #02
001E4E  2  D0 01        	bne :+							; if 2 => has to climb
001E50  2  60           	rts								; else block the move
001E51  2               :
001E51  2  4C 60 1F     	jmp @climb_left
001E54  2               
001E54  2               @walk_push_pull_left:
001E54  2  AE 03 05     	ldx player0 + PLAYER::entity + Entity::connectedID
001E57  2  E0 FF        	cpx #$ff
001E59  2  F0 0D        	beq @walk_left				; entityID cannot be 0
001E5B  2               
001E5B  2               	; if the player is pushing left an object located on its left, move the object first
001E5B  2  AD 1F 05     	lda player0 + PLAYER::grab_left_right
001E5E  2  C9 01        	cmp #Grab::LEFT
001E60  2  D0 06        	bne @walk_left
001E62  2  20 3F 18     	jsr Entities::fn_move_left
001E65  2  F0 01        	beq @walk_left				; cannot move the grabbed object => refuse to move
001E67  2  60           	rts
001E68  2               
001E68  2               @walk_left:
001E68  2               	; try move from the parent class Entity
001E68  2  A2 00        	ldx #00
001E6A  2  20 72 12     	jsr Entities::save_position
001E6D  2  20 AA 17     	jsr Entities::move_left			; return r3 = 'this'
001E70  2  F0 01        	beq @set_sprite
001E72  2  60           	rts								; blocked by tile, border or sprite
001E73  2               
001E73  2               @no_collision:
001E73  2               @set_sprite:
001E73  2               	; pick the correct sprite animation based on move or push or pull
001E73  2  AD 1F 05     	lda player0 + PLAYER::grab_left_right
001E76  2  C9 00        	cmp #Grab::NONE
001E78  2  F0 46        	beq @set_walk_left
001E7A  2  C9 02        	cmp #Grab::RIGHT
001E7C  2  F0 21        	beq @set_pull_left
001E7E  2               
001E7E  2               @set_push_left:
001E7E  2  AD 1B 05     	lda player0 + PLAYER::frameID
001E81  2  C9 0C        	cmp #Player::Sprites::PUSH
001E83  2  F0 6A        	beq @pull_object					; already push animation
001E85  2               
001E85  2  A5 02        	lda r0L								; set_bitmap overwrite r0, so we need to save
001E87  2  85 51        	sta addrSaveR0L
001E89  2  A5 03        	lda r0H
001E8B  2  85 52        	sta addrSaveR0H
001E8D  2               
001E8D  2  A9 0C        	lda #Player::Sprites::PUSH
001E8F  2  8D 1B 05     	sta player0 + PLAYER::frameID
001E92  2  20 74 0D     	jsr Sprite::set_bitmap
001E95  2               
001E95  2  A5 51        	lda addrSaveR0L								; set_bitmap overwrite r0, so we need to restore
001E97  2  85 02        	sta r0L
001E99  2  A5 52        	lda addrSaveR0H
001E9B  2  85 03        	sta r0H
001E9D  2               
001E9D  2  80 50        	bra @pull_object
001E9F  2               
001E9F  2               @set_pull_left:
001E9F  2  AD 1B 05     	lda player0 + PLAYER::frameID
001EA2  2  C9 0F        	cmp #Player::Sprites::PULL
001EA4  2  F0 49        	beq @pull_object					; already push animation
001EA6  2               
001EA6  2  A5 02        	lda r0L								; set_bitmap overwrite r0, so we need to save
001EA8  2  85 51        	sta addrSaveR0L
001EAA  2  A5 03        	lda r0H
001EAC  2  85 52        	sta addrSaveR0H
001EAE  2               
001EAE  2  A9 0F        	lda #Player::Sprites::PULL
001EB0  2  8D 1B 05     	sta player0 + PLAYER::frameID
001EB3  2  20 74 0D     	jsr Sprite::set_bitmap
001EB6  2               
001EB6  2  A5 51        	lda addrSaveR0L								; set_bitmap overwrite r0, so we need to restore
001EB8  2  85 02        	sta r0L
001EBA  2  A5 52        	lda addrSaveR0H
001EBC  2  85 03        	sta r0H
001EBE  2               
001EBE  2  80 2F        	bra @pull_object
001EC0  2               
001EC0  2               @set_walk_left:
001EC0  2  A9 00        	lda #SPRITE_FLIP_NONE
001EC2  2  8D 1E 05     	sta player0 + PLAYER::flip
001EC5  2  AC 01 05     	ldy player0 + PLAYER::entity + Entity::spriteID
001EC8  2  20 34 0E     	jsr Sprite::set_flip				; force sprite to loop right
001ECB  2               
001ECB  2  A9 01 8D 02  	m_status STATUS_WALKING
001ECF  2  05           
001ED0  2               
001ED0  2  A9 03        	lda #Player::Sprites::LEFT
001ED2  2  CD 1B 05     	cmp player0 + PLAYER::frameID
001ED5  2  F0 18        	beq @pull_object
001ED7  2               
001ED7  2  A5 02        	lda r0L								; set_bitmap overwrite r0, so we need to save
001ED9  2  85 51        	sta addrSaveR0L
001EDB  2  A5 03        	lda r0H
001EDD  2  85 52        	sta addrSaveR0H
001EDF  2               
001EDF  2               	;change player sprite
001EDF  2  A9 03        	lda #Player::Sprites::LEFT
001EE1  2  8D 1B 05     	sta player0 + PLAYER::frameID
001EE4  2  20 74 0D     	jsr Sprite::set_bitmap
001EE7  2               
001EE7  2  A5 51        	lda addrSaveR0L								; set_bitmap overwrite r0, so we need to restore
001EE9  2  85 02        	sta r0L
001EEB  2  A5 52        	lda addrSaveR0H
001EED  2  85 03        	sta r0H
001EEF  2               
001EEF  2               @pull_object:
001EEF  2               	; if the player is pulling left an object located on its right, move the object last
001EEF  2  AD 1F 05     	lda player0 + PLAYER::grab_left_right
001EF2  2  C9 02        	cmp #Grab::RIGHT
001EF4  2  D0 1F        	bne @check_slope
001EF6  2  AE 03 05     	ldx player0 + PLAYER::entity + Entity::connectedID
001EF9  2  20 3F 18     	jsr Entities::fn_move_left
001EFC  2  F0 05        	beq @validate_object_move
001EFE  2               
001EFE  2               	; object is blocked when being pulled (player on slope, object cannot be moved on slope)
001EFE  2               	; restore player position and exit
001EFE  2  A2 00        	ldx #00
001F00  2  4C 96 12     	jmp Entities::restore_position
001F03  2               
001F03  2               @validate_object_move:
001F03  2  A9 00        	lda #<player0						; restore 'this'
001F05  2  85 08        	sta r3L
001F07  2  A9 05        	lda #>player0
001F09  2  85 09        	sta r3H
001F0B  2  AD 10 05     	lda player0 + PLAYER::entity + Entity::collision_addr	; restore collision address
001F0E  2  85 02        	sta r0L
001F10  2  AD 11 05     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
001F13  2  85 03        	sta r0H
001F15  2               
001F15  2               @check_slope:
001F15  2  20 3D 15     	jsr Entities::if_on_slop
001F18  2  D0 08        	bne @move_slop
001F1A  2               
001F1A  2               	; TODO ///////////////////////
001F1A  2  20 E4 11     	jsr Entities::get_collision_map
001F1D  2  20 08 15     	jsr Entities::if_above_slop			; check if NOW were are above a slope
001F20  2  F0 3D        	beq @set_position
001F22  2               	; TODO \\\\\\\\\\\\\\\\\\\\\\\\\\
001F22  2               
001F22  2               @move_slop:
001F22  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
001F24  2  F0 26        	beq @move_y_up
001F26  2               @try_move_y_dow:
001F26  2  AD 06 05     	lda player0 + PLAYER::entity + Entity::levely
001F29  2  29 0F        	and #%00001111
001F2B  2  D0 1A        	bne @move_y_down
001F2D  2  AD 10 05     	lda player0 + PLAYER::entity + Entity::collision_addr
001F30  2  85 02        	sta r0L
001F32  2  AD 11 05     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
001F35  2  85 03        	sta r0H
001F37  2  A5 06        	lda r2L
001F39  2  18           	clc
001F3A  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)
001F3C  2  A8           	tay
001F3D  2  B1 02        	lda (r0), y							; check if the tile below as an attribute TILE_SOLID_GROUND
001F3F  2  A8           	tay
001F40  2  B9 1F 23     	lda tiles_attributes,y
001F43  2  89 01        	bit #TILE_ATTR::SOLID_GROUND
001F45  2  D0 18        	bne @set_position					; do not change Y if the tile below the player is a solid one
001F47  2               @move_y_down:
001F47  2  20 04 13     	jsr Entities::position_y_inc
001F4A  2  80 13        	bra @set_position
001F4C  2               @move_y_up:
001F4C  2  AD 04 05     	lda player0 + PLAYER::entity + Entity::levelx
001F4F  2  29 0F        	and #%00001111
001F51  2  C9 08        	cmp #08
001F53  2  D0 07        	bne :+
001F55  2  AD 06 05     	lda player0 + PLAYER::entity + Entity::levely
001F58  2  29 0F        	and #%00001111
001F5A  2  F0 03        	beq @return							; if x%8 == 0, y MUST be equal 0, or increase
001F5C  2               :
001F5C  2  20 24 13     	jsr Entities::position_y_dec
001F5F  2               
001F5F  2               @set_position:
001F5F  2               @return:
001F5F  2  60           	rts
001F60  2               
001F60  2               @climb_left:
001F60  2  20 2C 14     	jsr Entities::check_collision_left
001F63  2  F0 01        	beq @climb_left_1
001F65  2  60           	rts								; collision on left, block the move
001F66  2               @climb_left_1:
001F66  2  20 46 13     	jsr Entities::bbox_coverage				; what tiles is the player covering
001F69  2               
001F69  2  A2 01        	ldx #01
001F6B  2  A0 00        	ldy #00
001F6D  2  AD 04 05     	lda player0 + PLAYER::entity + Entity::levelx
001F70  2  29 0F        	and #%00001111
001F72  2  F0 01        	beq @get_tile
001F74  2  E8           	inx								; if x%8 <> 0, test 2 tiles
001F75  2               @get_tile:
001F75  2  B1 02        	lda (r0),y
001F77  2  F0 0E        	beq @no_grab					; no tile on right
001F79  2  85 31        	sta $31
001F7B  2  84 30        	sty $30
001F7D  2  A8           	tay
001F7E  2  B9 1F 23     	lda tiles_attributes,y
001F81  2  89 08        	bit #TILE_ATTR::GRABBING
001F83  2  D0 08        	bne @climb_left_2				; tile on left with a GRAB attribute
001F85  2  A4 30        	ldy $30
001F87  2               @no_grab:							; test the tile on the left on next line
001F87  2  C8           	iny
001F88  2  CA           	dex
001F89  2  D0 EA        	bne @get_tile
001F8B  2  80 23        	bra @climb_left_drop			; no grab tile on the right of the player
001F8D  2               @climb_left_2:
001F8D  2  A5 31        	lda $31							; tile index with grab attribute
001F8F  2  C9 05        	cmp #TILE_LEDGE
001F91  2  D0 04        	bne @set_climb_sprite
001F93  2               @set_hang_sprite:
001F93  2  A9 09        	lda #Player::Sprites::HANG
001F95  2  80 02        	bra @next
001F97  2               @set_climb_sprite:
001F97  2  A9 06        	lda #Player::Sprites::CLIMB
001F99  2               @next:
001F99  2  8D 1B 05     	sta player0 + PLAYER::frameID
001F9C  2  20 79 1B     	jsr set_bitmap
001F9F  2  A9 02 8D 02  	m_status STATUS_CLIMBING
001FA3  2  05           
001FA4  2  20 E2 12     	jsr Entities::position_x_dec		; move the player sprite, if the
001FA7  2               	;TODO ///////////////////////
001FA7  2  AD 0D 05     	lda player0 + PLAYER::entity + Entity::bFlags	; activate physics engine
001FAA  2  09 01        	ora #(EntityFlags::physics)
001FAC  2  8D 0D 05     	sta player0 + PLAYER::entity + Entity::bFlags	; activate physics engine
001FAF  2               	;TODO ///////////////////////
001FAF  2  60           	rts
001FB0  2               @climb_left_drop:					; no ladder to stick to
001FB0  2  A9 01 8D 02  	m_status STATUS_WALKING
001FB4  2  05           
001FB5  2  A9 03 8D 1B  	SET_SPRITE Player::Sprites::LEFT, 1
001FB9  2  05 A9 01 8D  
001FBD  2  1C 05 20 79  
001FC2  2  60           	rts
001FC3  2               
001FC3  2               ;************************************************
001FC3  2               ; try to move the player down (crouch, hide, move down a ladder)
001FC3  2               ;
001FC3  2               move_down:
001FC3  2               	; r3 = *player
001FC3  2  A9 00        	lda #<player0
001FC5  2  85 08        	sta r3L
001FC7  2  A9 05        	lda #>player0
001FC9  2  85 09        	sta r3H
001FCB  2               
001FCB  2  AD 02 05     	lda player0 + PLAYER::entity + Entity::status
001FCE  2  C9 04        	cmp #STATUS_FALLING
001FD0  2  D0 01        	bne @try_move_down						; cannot move when falling
001FD2  2  60           	rts
001FD3  2               
001FD3  2               @try_move_down:
001FD3  2               	; custom collision down
001FD3  2  AD 10 05     	lda player0 + PLAYER::entity + Entity::collision_addr
001FD6  2  85 02        	sta r0L
001FD8  2  AD 11 05     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
001FDB  2  85 03        	sta r0H
001FDD  2               
001FDD  2  20 46 13     	jsr Entities::bbox_coverage
001FE0  2  8E 77 1A     	stx ladders						; width of the player in tiles = number of ladders to find below
001FE3  2  A5 06        	lda r2L
001FE5  2  18           	clc
001FE6  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)	; check below the player
001FE8  2  A8           	tay
001FE9  2               
001FE9  2               @test_colum:
001FE9  2  B1 02        	lda (r0L),y
001FEB  2  C9 04        	cmp #TILE_SOLID_LADER
001FED  2  D0 05        	bne @check_solid_ground
001FEF  2               @ladder_down:
001FEF  2  CE 77 1A     	dec ladders
001FF2  2  80 0C        	bra @next_column
001FF4  2               @check_solid_ground:
001FF4  2  84 30        	sty $30
001FF6  2  A8           	tay
001FF7  2  B9 1F 23     	lda tiles_attributes,y
001FFA  2  89 01        	bit #TILE_ATTR::SOLID_GROUND
001FFC  2  D0 4A        	bne @cannot_move_down
001FFE  2  A4 30        	ldy $30
002000  2               @next_column:
002000  2  CA           	dex
002001  2  F0 03        	beq @end
002003  2  C8           	iny
002004  2  80 E3        	bra @test_colum
002006  2               @end:
002006  2               
002006  2  AD 77 1A     	lda ladders
002009  2  F0 1C        	beq @move_down						; correct number of ladder tiles below the player
00200B  2               
00200B  2               	; if there player is covering ANY ladders (accros the boundingbox)
00200B  2  A4 06        	ldy r2L
00200D  2               @check_line:							; already climbing down is player grabbing no ladder
00200D  2  A6 05        	ldx r1H
00200F  2               @check_row:
00200F  2  B1 02        	lda (r0L),y
002011  2  C9 04        	cmp #TILE_SOLID_LADER
002013  2  F0 12        	beq @move_down
002015  2  C8           	iny
002016  2  CA           	dex
002017  2  D0 F6        	bne @check_row
002019  2  C6 04        	dec r1L
00201B  2  F0 2B        	beq @cannot_move_down
00201D  2               
00201D  2  98           	tya
00201E  2  18           	clc
00201F  2  69 20        	adc #LEVEL_TILES_WIDTH
002021  2  38           	sec
002022  2  E5 05        	sbc r1H
002024  2  A8           	tay
002025  2  80 E6        	bra @check_line
002027  2               
002027  2               @move_down:
002027  2  20 04 13     	jsr Entities::position_y_inc		; move down the ladder
00202A  2               	;TODO ///////////////////////
00202A  2  AD 0D 05     	lda player0 + PLAYER::entity + Entity::bFlags	; activate physics engine
00202D  2  09 01        	ora #(EntityFlags::physics)
00202F  2  8D 0D 05     	sta player0 + PLAYER::entity + Entity::bFlags	; activate physics engine
002032  2               	;TODO ///////////////////////
002032  2               
002032  2  A9 02 8D 02  	m_status STATUS_CLIMBING
002036  2  05           
002037  2               
002037  2  A9 06        	lda #Player::Sprites::CLIMB
002039  2  CD 1B 05     	cmp player0 + PLAYER::frameID
00203C  2  D0 01        	bne @change_sprite
00203E  2  60           	rts
00203F  2               
00203F  2               @change_sprite:
00203F  2               	;change player sprite
00203F  2  A9 06        	lda #Player::Sprites::CLIMB
002041  2  8D 1B 05     	sta player0 + PLAYER::frameID
002044  2  20 79 1B     	jsr set_bitmap
002047  2  60           	rts
002048  2               
002048  2               @cannot_move_down:
002048  2  A9 00        	lda #STATUS_WALKING_IDLE
00204A  2  8D 02 05     	sta player0 + PLAYER::entity + Entity::status
00204D  2  A9 01        	lda #01
00204F  2  8D 1C 05     	sta player0 + PLAYER::frame
002052  2  20 79 1B     	jsr set_bitmap
002055  2  9C 0A 05     	stz player0 + PLAYER::entity + Entity::delta_x
002058  2  60           	rts
002059  2               
002059  2               ;************************************************
002059  2               ; try to move the player up (move up a ladder)
002059  2               ;	only climb a ladder if the 16 pixels mid-X are fully enclosed in the ladder
002059  2               ;	modify: r0, r1, r2
002059  2               ;
002059  2               move_up:
002059  2               	; r3 = *player
002059  2  A9 00        	lda #<player0
00205B  2  85 08        	sta r3L
00205D  2  A9 05        	lda #>player0
00205F  2  85 09        	sta r3H
002061  2               
002061  2  AD 02 05     	lda player0 + PLAYER::entity + Entity::status
002064  2  C9 04        	cmp #STATUS_FALLING
002066  2  D0 01        	bne @try_move_up				; cannot move when falling
002068  2  60           	rts
002069  2               @try_move_up:
002069  2               	; custom collision up
002069  2  20 46 13     	jsr Entities::bbox_coverage
00206C  2  A4 06        	ldy r2L
00206E  2  8E 77 1A     	stx ladders						; width of the player in tiles = number of ladders to find below
002071  2               
002071  2               	; check the situation ABOVE the player
002071  2  38           	sec
002072  2  AD 10 05     	lda player0 + PLAYER::entity + Entity::collision_addr
002075  2  E9 20        	sbc #LEVEL_TILES_WIDTH
002077  2  85 02        	sta r0L
002079  2  AD 11 05     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
00207C  2  E9 00        	sbc #0
00207E  2  85 03        	sta r0H
002080  2               
002080  2               	; if there the right numbers of ladder tiles above the player
002080  2               @test_colum:
002080  2  B1 02        	lda (r0L),y
002082  2  C9 04        	cmp #TILE_SOLID_LADER
002084  2  D0 05        	bne @check_solid_ceiling
002086  2  CE 77 1A     	dec ladders
002089  2  80 0C        	bra @next_column
00208B  2               @check_solid_ceiling:
00208B  2  84 30        	sty $30
00208D  2  A8           	tay
00208E  2  B9 1F 23     	lda tiles_attributes,y
002091  2  89 04        	bit #TILE_ATTR::SOLID_CEILING
002093  2  D0 54        	bne @cannot_move_up
002095  2  A4 30        	ldy $30
002097  2               @next_column:
002097  2  CA           	dex
002098  2  F0 03        	beq @end
00209A  2  C8           	iny
00209B  2  80 E3        	bra @test_colum
00209D  2               @end:
00209D  2               
00209D  2  AD 77 1A     	lda ladders
0020A0  2  F0 26        	beq @climb_down						; correct number of ladder tiles above the player
0020A2  2               
0020A2  2               	; if there player is covering ANY LADER (accros the boundingbox)
0020A2  2  AD 10 05     	lda player0 + PLAYER::entity + Entity::collision_addr
0020A5  2  85 02        	sta r0L
0020A7  2  AD 11 05     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
0020AA  2  85 03        	sta r0H
0020AC  2               
0020AC  2  A4 06        	ldy r2L
0020AE  2               @check_line:							; already climbing up is player grabbing no ladder
0020AE  2  A6 05        	ldx r1H
0020B0  2               @check_row:
0020B0  2  B1 02        	lda (r0L),y
0020B2  2  C9 04        	cmp #TILE_SOLID_LADER
0020B4  2  F0 12        	beq @climb_down
0020B6  2  C8           	iny
0020B7  2  CA           	dex
0020B8  2  D0 F6        	bne @check_row
0020BA  2  C6 04        	dec r1L
0020BC  2  F0 2B        	beq @cannot_move_up
0020BE  2               
0020BE  2  98           	tya
0020BF  2  18           	clc
0020C0  2  69 20        	adc #LEVEL_TILES_WIDTH
0020C2  2  38           	sec
0020C3  2  E5 05        	sbc r1H
0020C5  2  A8           	tay
0020C6  2  80 E6        	bra @check_line
0020C8  2               
0020C8  2               @climb_down:
0020C8  2  20 24 13     	jsr Entities::position_y_dec		; move up the ladder
0020CB  2               	;TODO ///////////////////////
0020CB  2  AD 0D 05     	lda player0 + PLAYER::entity + Entity::bFlags	; activate physics engine
0020CE  2  09 01        	ora #(EntityFlags::physics)
0020D0  2  8D 0D 05     	sta player0 + PLAYER::entity + Entity::bFlags	; activate physics engine
0020D3  2               	;TODO ///////////////////////
0020D3  2               
0020D3  2  A9 02 8D 02  	m_status STATUS_CLIMBING
0020D7  2  05           
0020D8  2               
0020D8  2  A9 06        	lda #Player::Sprites::CLIMB
0020DA  2  CD 1B 05     	cmp player0 + PLAYER::frameID
0020DD  2  D0 01        	bne @set_sprite
0020DF  2  60           	rts
0020E0  2               @set_sprite:						;change player sprite
0020E0  2  A9 06        	lda #Player::Sprites::CLIMB
0020E2  2  8D 1B 05     	sta player0 + PLAYER::frameID
0020E5  2  20 79 1B     	jsr set_bitmap
0020E8  2  60           	rts
0020E9  2               
0020E9  2               @cannot_move_up:
0020E9  2  A9 00        	lda #STATUS_WALKING_IDLE
0020EB  2  8D 02 05     	sta player0 + PLAYER::entity + Entity::status
0020EE  2  60           	rts
0020EF  2               
0020EF  2               ;************************************************
0020EF  2               ; jump
0020EF  2               ;	input: A = delta X value
0020EF  2               ;
0020EF  2               jump:
0020EF  2  AA           	tax
0020F0  2               
0020F0  2               	; r3 = *player
0020F0  2  A9 00        	lda #<player0
0020F2  2  85 08        	sta r3L
0020F4  2  A9 05        	lda #>player0
0020F6  2  85 09        	sta r3H
0020F8  2               
0020F8  2  AC 02 05         ldy player0 + PLAYER::entity + Entity::status
0020FB  2  B9 AE 1C     	lda ignore_move_request,y
0020FE  2  D0 1F        	bne @return
002100  2  8E 0A 05     	stx player0 + PLAYER::entity + Entity::delta_x
002103  2               
002103  2               	; ensure there is no ceiling over the player
002103  2  20 BE 14     	jsr Entities::check_collision_up
002106  2  D0 17        	bne @return
002108  2               
002108  2  A9 0A        	lda #JUMP_LO_TICKS
00210A  2  8D 08 05     	sta player0 + PLAYER::entity + Entity::falling_ticks	; decrease  HI every 10 refresh
00210D  2  A9 02        	lda #JUMP_HI_TICKS
00210F  2  8D 09 05     	sta player0 + PLAYER::entity + Entity::falling_ticks	+ 1
002112  2               
002112  2               
002112  2  A0 0D        	ldy #Entity::bFlags
002114  2  B1 08        	lda (r3),y
002116  2  09 01        	ora #EntityFlags::physics
002118  2  91 08        	sta (r3),y						; engage physics engine for that entity
00211A  2               
00211A  2  A9 05 8D 02  	m_status STATUS_JUMPING
00211E  2  05           
00211F  2               @return:
00211F  2  60           	rts
002120  2               
002120  2               ;************************************************
002120  2               ; grab the object if front of the player, if there is an object
002120  2               ;
002120  2               grab_object:
002120  2  AD 1E 05     	lda player0 + PLAYER::flip
002123  2  D0 04        	bne @right
002125  2               @left:
002125  2  A9 0A        	lda #(02 | 08)
002127  2  80 02        	bra @cont
002129  2               @right:
002129  2  A9 06        	lda #(02 | 04)
00212B  2               @cont:
00212B  2  AE 01 05     	ldx player0 + PLAYER::entity + Entity::spriteID
00212E  2  20 5A 0F     	jsr Sprite::precheck_collision	; get the frameID in Y
002131  2  30 4E        	bmi @return						; no object
002133  2               
002133  2  20 73 19     	jsr Objects::get_by_spriteID	; find the object that has frameID A
002136  2  C0 FF        	cpy #$ff
002138  2  F0 47        	beq @return						; no object with this ID
00213A  2               
00213A  2  84 50        	sty bCollisionID
00213C  2  A0 1A        	ldy #Objects::Object::imageID
00213E  2  B1 08        	lda (r3), y
002140  2  89 01        	bit #Objects::Attribute::GRAB
002142  2  F0 3D        	beq @return						; object cannot be grabbed
002144  2               
002144  2               	; call virtual function of the remote object to bind
002144  2  A9 00        	lda #<player0
002146  2  85 14        	sta r9L
002148  2  A9 05        	lda #>player0
00214A  2  85 15        	sta r9H
00214C  2  20 EC 17     	jsr Entities::bind
00214F  2               
00214F  2               	; bind remote object
00214F  2  A4 50        	ldy bCollisionID
002151  2  8C 03 05     	sty player0 + PLAYER::entity + Entity::connectedID ; save the EntityID to the grabbed object
002154  2               
002154  2  AD 1E 05     	lda player0 + PLAYER::flip
002157  2  D0 07        	bne @right1
002159  2               @left1:
002159  2  A9 01        	lda #Grab::LEFT
00215B  2  8D 1F 05     	sta player0 + PLAYER::grab_left_right
00215E  2  80 05        	bra @change_sprite
002160  2               @right1:
002160  2  A9 02        	lda #Grab::RIGHT
002162  2  8D 1F 05     	sta player0 + PLAYER::grab_left_right
002165  2               @change_sprite:
002165  2  A9 0C        	lda #Player::Sprites::PUSH
002167  2  8D 1B 05     	sta player0 + PLAYER::frameID
00216A  2  9C 1C 05     	stz player0 + PLAYER::frame
00216D  2  A9 0A        	lda #10
00216F  2  8D 1A 05     	sta player0 + PLAYER::animation_tick	; reset animation tick counter
002172  2  A9 01        	lda #01
002174  2  8D 1D 05     	sta player0 + PLAYER::frameDirection
002177  2               
002177  2  A9 0F        	lda #Player::Sprites::PULL
002179  2  A9 07 8D 02  	m_status STATUS_PUSHING
00217D  2  05           
00217E  2               
00217E  2  20 79 1B     	jsr set_bitmap
002181  2               
002181  2               @return:
002181  2  60           	rts
002182  2               
002182  2               ;************************************************
002182  2               ; release the object the player is moving
002182  2               ;
002182  2               release_object:
002182  2  AE 03 05     	ldx player0 + PLAYER::entity + Entity::connectedID
002185  2  20 44 11     	jsr Entities::get_pointer
002188  2               
002188  2  A0 03        	ldy #Entity::connectedID				; disconnect the object from the player
00218A  2  A9 FF        	lda #$ff
00218C  2  91 08        	sta (r3),y
00218E  2               
00218E  2  A9 FF        	lda #$ff
002190  2  8D 03 05     	sta player0 + PLAYER::entity + Entity::connectedID	; disconnect the object from the player
002193  2               
002193  2  A9 00 8D 02  	m_status STATUS_WALKING_IDLE
002197  2  05           
002198  2               
002198  2  A9 00        	lda #Grab::NONE
00219A  2  8D 1F 05     	sta player0 + PLAYER::grab_left_right
00219D  2               
00219D  2  A9 03        	lda #Player::Sprites::LEFT
00219F  2  8D 1B 05     	sta player0 + PLAYER::frameID
0021A2  2  9C 1C 05     	stz player0 + PLAYER::frame
0021A5  2  A9 0A        	lda #10
0021A7  2  8D 1A 05     	sta player0 + PLAYER::animation_tick	; reset animation tick counter
0021AA  2  A9 01        	lda #01
0021AC  2  8D 1D 05     	sta player0 + PLAYER::frameDirection
0021AF  2  20 79 1B     	jsr set_bitmap
0021B2  2               
0021B2  2  60           	rts
0021B3  2               
0021B3  2               ;************************************************
0021B3  2               ; virtual function unbind : also change the status of the object
0021B3  2               ;   input: r3 = this
0021B3  2               ;   input: r4L = start of connected object
0021B3  2               ;
0021B3  2               unbind:
0021B3  2  A9 00        	lda #STATUS_WALKING_IDLE
0021B5  2  8D 02 05     	sta player0 + PLAYER::entity + Entity::status
0021B8  2               
0021B8  2  A9 00        	lda #Grab::NONE
0021BA  2  8D 1F 05     	sta player0 + PLAYER::grab_left_right
0021BD  2               
0021BD  2  60           	rts
0021BE  2               
0021BE  2               .endscope
0021BE  2               
0021BE  1               
0021BE  1               ;-----------------------------------------------------------------------------
0021BE  1               ;/////////////////////////////////////////////////////////////////////////////
0021BE  1               ; main code
0021BE  1               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
0021BE  1               ;-----------------------------------------------------------------------------
0021BE  1               
0021BE  1  00 00        objects: .word 0
0021C0  1               
0021C0  1               start:
0021C0  1               	; 320x240
0021C0  1  A9 40        	lda #64
0021C2  1  8D 2A 9F     	sta veradchscale
0021C5  1  8D 2B 9F     	sta veradcvscale
0021C8  1               
0021C8  1               	; activate layer0
0021C8  1  A9 71        	lda #%01110001
0021CA  1               ;	and #(255-VERA_LAYER0)
0021CA  1               ;	ora #(VERA_LAYER1)             ; Read Video Register
0021CA  1  8D 29 9F     	sta veradcvideo             ; Store new value to Video Register
0021CD  1               
0021CD  1  20 BB 19     	jsr Layers::init
0021D0  1  20 21 11     	jsr Entities::initModule
0021D3  1               
0021D3  1               	;---------------------------------
0021D3  1               	; load tiles file into vram
0021D3  1               	;---------------------------------
0021D3  1  20 45 08     	jsr Tiles::load_static
0021D6  1               
0021D6  1               	;---------------------------------
0021D6  1               	;---------------------------------
0021D6  1               	; load tilemaps into vram
0021D6  1               	;---------------------------------
0021D6  1  20 53 10     	jsr Tilemap::load
0021D9  1               
0021D9  1               	; load animated tiles into ram
0021D9  1               	;---------------------------------
0021D9  1  20 8F 08     	jsr Tiles::load_anim
0021DC  1               
0021DC  1               	;---------------------------------
0021DC  1               	; load sprite 0,1,2 into vram
0021DC  1               	;---------------------------------
0021DC  1               load_sprites:
0021DC  1               	; prepare VERA sprites
0021DC  1  20 6A 0C     	jsr Sprite::init_addr_table
0021DF  1               
0021DF  1  A9 00 85 02  	LOAD_r0 (::VRAM_tiles + tiles * tile_size)	; base for the sprites
0021E3  1  A9 41 85 03  
0021E7  1  20 79 1A     	jsr Player::init
0021EA  1               
0021EA  1               	;---------------------------------
0021EA  1               	; load objects list into ram
0021EA  1               	;---------------------------------
0021EA  1  20 62 18     	jsr Objects::initModule
0021ED  1               
0021ED  1  20 25 12     	jsr Entities::update				; place all entitieson on screen
0021F0  1               setirq:
0021F0  1                  ; backup default RAM IRQ vector
0021F0  1  AD 14 03        lda IRQVec
0021F3  1  8D 1C 23        sta default_irq_vector
0021F6  1  AD 15 03        lda IRQVec+1
0021F9  1  8D 1D 23        sta default_irq_vector+1
0021FC  1               
0021FC  1                  ; overwrite RAM IRQ vector with custom handler address
0021FC  1  78              sei ; disable IRQ while vector is changing
0021FD  1  A9 14           lda #<custom_irq_handler
0021FF  1  8D 14 03        sta IRQVec
002202  1  A9 22           lda #>custom_irq_handler
002204  1  8D 15 03        sta IRQVec+1
002207  1  AD 26 9F        lda veraien
00220A  1  09 01           ora #VERA_VSYNC_BIT ; make VERA only generate VSYNC IRQs
00220C  1  8D 26 9F        sta veraien
00220F  1  58              cli ; enable IRQ now that vector is properly set
002210  1               
002210  1               mainloop:
002210  1  CB           	wai
002211  1  80 FD        	bra mainloop
002213  1               
002213  1  60           	rts
002214  1               
002214  1               ;-----------------------------------------------------------------------------
002214  1               ;/////////////////////////////////////////////////////////////////////////////
002214  1               ; deal with IRQ"s
002214  1               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
002214  1               ;-----------------------------------------------------------------------------
002214  1               custom_irq_handler:
002214  1  AD 27 9F     	lda veraisr
002217  1  AA           	tax
002218  1  29 04        	and #VERA_SPRCOL_BIT
00221A  1  F0 0B        	beq @check_vsync
00221C  1               
00221C  1               @sprite_collision:
00221C  1  8D 27 9F     	sta veraisr						; acknowled the SPRCOL IRQ
00221F  1  8A           	txa
002220  1  4A           	lsr
002221  1  4A           	lsr
002222  1  4A           	lsr
002223  1  4A           	lsr								; extract the collision mask (4:7)
002224  1  20 AB 0E     	jsr Sprite::register_collision
002227  1               
002227  1               @check_vsync:
002227  1  8A           	txa
002228  1  29 01        	and #VERA_VSYNC_BIT
00222A  1  F0 6B        	beq @continue
00222C  1               
00222C  1               @frame_update:
00222C  1  8D 27 9F     	sta veraisr						; acknowled the VSYNC IRQ
00222F  1               
00222F  1               	;---------------------------------
00222F  1               	; animate sprite
00222F  1               	;---------------------------------
00222F  1  20 56 1C     	jsr Player::animate
002232  1               
002232  1               	;---------------------------------
002232  1               	; swap animated tiles
002232  1               	;---------------------------------
002232  1  20 39 09     	jsr Tiles::animate
002235  1               
002235  1               	;---------------------------------
002235  1               	; sprite collisions management
002235  1               	;---------------------------------
002235  1  20 32 0F     	jsr Sprite::check_irq_collision
002238  1               
002238  1               	;---------------------------------
002238  1               	; check keyboard
002238  1               	;---------------------------------
002238  1               @check_keyboard:
002238  1               	; get fake-joystick data from keyboard
002238  1  A9 00        	lda #0
00223A  1  20 56 FF     	jsr joystick_get
00223D  1  8D 26 23     	sta joystick_data
002240  1  8E 27 23     	stx joystick_data + 1
002243  1               
002243  1               	; get real joystick data
002243  1  A9 01        	lda #1
002245  1  20 56 FF     	jsr joystick_get
002248  1  C0 00        	cpy #0
00224A  1  D0 0D        	bne @check_buttons
00224C  1               
00224C  1               	; if there is a joystick, mix the data
00224C  1  2D 26 23     	and joystick_data
00224F  1  8D 26 23     	sta joystick_data
002252  1               
002252  1  8A           	txa
002253  1  2D 27 23     	and joystick_data + 1
002256  1  8D 27 23     	sta joystick_data + 1
002259  1               
002259  1               @check_buttons:
002259  1               	; check button A press/release
002259  1  4D 29 23     	eor joystick_data_old + 1
00225C  1               
00225C  1  89 80        	bit #JOY_A
00225E  1  F0 0F        	beq @save_data				; no change for the A
002260  1               
002260  1  AD 27 23     	lda joystick_data + 1
002263  1  89 80        	bit #JOY_A
002265  1  F0 05        	beq @grab
002267  1               @release:
002267  1  20 82 21     	jsr Player::release_object
00226A  1  80 03        	bra @save_data
00226C  1               @grab:
00226C  1  20 20 21     	jsr Player::grab_object
00226F  1               @save_data:
00226F  1  AD 27 23     	lda joystick_data + 1
002272  1  8D 29 23     	sta joystick_data_old + 1
002275  1               
002275  1               ;  .A, byte 0:      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
002275  1               ;              NES  | A | B |SEL|STA|UP |DN |LT |RT |
002275  1               ;              SNES | B | Y |SEL|STA|UP |DN |LT |RT |
002275  1               ;
002275  1               ;  .X, byte 1:      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
002275  1               ;              NES  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | X |
002275  1               ;              SNES | A | X | L | R | 1 | 1 | 1 | 1 |
002275  1               ;  .Y, byte 2:
002275  1               ;              $00 = joystick present
002275  1               ;              $FF = joystick not present
002275  1               
002275  1               @other_check:
002275  1  AD 26 23     	lda joystick_data
002278  1               
002278  1  89 81        	bit #(JOY_RIGHT|JOY_B)
00227A  1  F0 27        	beq @jump_right
00227C  1  89 82        	bit #(JOY_LEFT|JOY_B)
00227E  1  F0 2A        	beq @jump_left
002280  1  89 01        	bit #JOY_RIGHT
002282  1  F0 32        	beq @joystick_right
002284  1  89 02        	bit #JOY_LEFT
002286  1  F0 29        	beq @joystick_left
002288  1  89 04        	bit #JOY_DOWN
00228A  1  F0 34        	beq @movedown
00228C  1  89 08        	bit #JOY_UP
00228E  1  F0 2B        	beq @moveup
002290  1  89 80        	bit #JOY_B
002292  1  F0 31        	beq @jump
002294  1               
002294  1  20 95 1C     	jsr Player::set_idle
002297  1               
002297  1               @continue:
002297  1  20 55 1A     	jsr Layers::update					; refresh layers if needed
00229A  1  20 25 12     	jsr Entities::update				; place all entities on on screen
00229D  1  20 93 1B     	jsr Player::check_scroll_layers
0022A0  1               
0022A0  1               	; continue to default IRQ handler
0022A0  1  6C 1C 23     	jmp (default_irq_vector)
0022A3  1               	; RTI will happen after jump
0022A3  1               
0022A3  1               @jump_right:
0022A3  1  A9 01        	lda #$01					; jump right
0022A5  1  20 EF 20     	jsr Player::jump
0022A8  1  80 ED        	bra @continue
0022AA  1               
0022AA  1               @jump_left:
0022AA  1  A9 FF        	lda #$ff					; jump left
0022AC  1  20 EF 20     	jsr Player::jump
0022AF  1  80 E6        	bra @continue
0022B1  1               
0022B1  1               @joystick_left:
0022B1  1  20 44 1E     	jsr Player::move_left
0022B4  1  80 E1        	bra @continue
0022B6  1               
0022B6  1               @joystick_right:
0022B6  1  20 B6 1C     	jsr Player::move_right
0022B9  1  80 DC        	bra @continue
0022BB  1               
0022BB  1               @moveup:
0022BB  1  20 59 20     	jsr Player::move_up
0022BE  1  80 D7        	bra @continue
0022C0  1               
0022C0  1               @movedown:
0022C0  1  20 C3 1F     	jsr Player::move_down
0022C3  1  80 D2        	bra @continue
0022C5  1               
0022C5  1               @jump:
0022C5  1  A9 00        	lda #0				; jump up
0022C7  1  20 EF 20     	jsr Player::jump
0022CA  1  80 CB        	bra @continue
0022CC  1               
0022CC  1               .segment "DATA"
0022CC  1               .include "tilemap.inc"
0022CC  2               map:
0022CC  2  20 20        	.byte 32,32
0022CE  2  6C 65 76 65  fslevel: .literal "level.bin"
0022D2  2  6C 2E 62 69  
0022D6  2  6E           
0022D7  2               fslevel_end:
0022D7  2  73 63 65 6E  fsbackground: .literal "scenery.bin"
0022DB  2  65 72 79 2E  
0022DF  2  62 69 6E     
0022E2  2               fsbackground_end:
0022E2  2  63 6F 6C 6C  fscollision: .literal "collision.bin"
0022E6  2  69 73 69 6F  
0022EA  2  6E 2E 62 69  
0022EF  2               fscollision_end:
0022EF  2  6F 62 6A 65  fsobjects: .literal "objects.bin"
0022F3  2  63 74 73 2E  
0022F7  2  62 69 6E     
0022FA  2               fsobjects_end:
0022FA  2  73 70 72 69  fssprites1: .literal "sprites1.bin"
0022FE  2  74 65 73 31  
002302  2  2E 62 69 6E  
002306  2               fssprites1_end:
002306  2               tileset:
002306  2  10 10        	.byte 16,16
002308  2               tiles = 49
002308  2               tile_size = 256
002308  2  74 69 6C 65  fstile: .literal "tiles.bin"
00230C  2  73 2E 62 69  
002310  2  6E           
002311  2               fstileend:
002311  2               
002311  1               .include "sprite.inc"
002311  2  73 70 72 69  fssprite:	.literal "sprites.bin"
002315  2  74 65 73 2E  
002319  2  62 69 6E     
00231C  2               fsspriteend:
00231C  2               sprites = 18
00231C  2               sprite_size = 1024
00231C  2               
00231C  1               
00231C  1  00 00        default_irq_vector: .addr 0
00231E  1  00           trigger_debug: .byte 0
00231F  1               tiles_attributes:
00231F  1  00           	.byte %00000000	;	TILE_NO_COLLISION
002320  1  07           	.byte %00000111	;	TILE_SOLID_GROUND
002321  1  04           	.byte %00000100	;	TILE_SOLD_SLOP_LEFT
002322  1  04           	.byte %00000100	;	TILE_SOLD_SLOP_RIGHT
002323  1  09           	.byte %00001001	;	TILE_SOLID_LADER
002324  1  09           	.byte %00001001	;	TILE_LEDGE
002325  1  01           	.byte TILE_ATTR::SOLID_GROUND	;	TILE_FLOOR
002326  1               
002326  1               .segment "BSS"
002326  1  00 00        	joystick_data: .byte 0, 0
002328  1  00 00        	joystick_data_old: .byte 0, 0
002329  1               
