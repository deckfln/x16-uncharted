ca65 V2.19 - Git e4f01a2
Main file   : main.asm
Current file: main.asm

000000r 1               .org $080D
00080D  1               .segment "STARTUP"
00080D  1               .segment "INIT"
00080D  1               .segment "ONCE"
00080D  1               .segment "CODE"
00080D  1               
00080D  1  4C F9 1B        jmp start
000810  1               
000810  1               .macro LOAD_r0 addr16
000810  1               	lda #<addr16
000810  1               	sta r0L
000810  1               	lda #>addr16
000810  1               	sta r0H
000810  1               .endmacro
000810  1               .macro SAVE_r0 addr16
000810  1               	lda r0L
000810  1               	sta addr16
000810  1               	lda r0H
000810  1               	sta addr16 + 1
000810  1               .endmacro
000810  1               .macro LOAD_r1 addr16
000810  1               	lda #<addr16
000810  1               	sta r1L
000810  1               	lda #>addr16
000810  1               	sta r1H
000810  1               .endmacro
000810  1               .macro LOAD_r3 addr16
000810  1               	lda #<addr16
000810  1               	sta r3L
000810  1               	lda #>addr16
000810  1               	sta r3H
000810  1               .endmacro
000810  1               
000810  1               .include "x16.inc"
000810  2               .ifndef X16_INC
000810  2               X16_INC = 1
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Commodore 64 API
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               ; Channel I/O
000810  2               SETMSG		= $FF90 ; set verbosity
000810  2               READST		= $FFB7 ; return status byte
000810  2               SETLFS		= $FFBA ; set LA, FA and SA
000810  2               SETNAM		= $FFBD ; set filename
000810  2               OPEN		= $FFC0 ; open a channel
000810  2               CLOSE		= $FFC3 ; close a channel
000810  2               CHKIN		= $FFC6 ; set channel for character input
000810  2               CHKOUT		= $FFC9 ; set channel for character output
000810  2               CLRCHN		= $FFCC ; restore character I/O to screen/keyboard
000810  2               BASIN		= $FFCF ; get character
000810  2               BSOUT		= $FFD2 ; write character
000810  2               LOAD		= $FFD5 ; load a file into memory
000810  2               SAVE		= $FFD8 ; save a file from memory
000810  2               CLALL		= $FFE7 ; close all channels
000810  2               
000810  2               ; Commodore Peripheral Bus
000810  2               TALK		= $FFB4 ; send TALK command
000810  2               LISTEN		= $FFB1 ; send LISTEN command
000810  2               UNLSN		= $FFAE ; send UNLISTEN command
000810  2               UNTLK		= $FFAB ; send UNTALK command
000810  2               IECOUT		= $FFA8 ; send byte to serial bus
000810  2               IECIN		= $FFA5 ; read byte from serial bus
000810  2               SETTMO		= $FFA2 ; set timeout
000810  2               TKSA		= $FF96 ; send TALK secondary address
000810  2               SECOND		= $FF93 ; send LISTEN secondary address
000810  2               
000810  2               ; Memory
000810  2               MEMBOT		= $FF9C ; read/write address of start of usable RAM
000810  2               MEMTOP		= $FF99 ; read/write address of end of usable RAM
000810  2               
000810  2               ; Time
000810  2               RDTIM		= $FFDE ; read system clock
000810  2               SETTIM		= $FFDB ; write system clock
000810  2               UDTIM		= $FFEA ; advance clock
000810  2               
000810  2               ; Other:
000810  2               STOP		= $FFE1 ; test for STOP key
000810  2               GETIN		= $FFE4 ; get character from keyboard
000810  2               SCREEN		= $FFED ; get the screen resolution
000810  2               PLOT		= $FFF0 ; read/write cursor position
000810  2               IOBASE		= $FFF3 ; return start of I/O area
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Commodore 128 API
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               CLOSE_ALL		= $FF4A ; close all files on a device
000810  2               LKUPLA		= $FF8D ; search tables for given LA
000810  2               LKUPSA		= $FF8A ; search tables for given SA
000810  2               DLCHR		= $FF62 ; activate a text mode font in the video hardware [not yet implemented]
000810  2               PFKEY		= $FF65 ; program a function key [not yet implemented]
000810  2               FETCH		= $FF74 ; LDA (fetvec),Y from any bank
000810  2               STASH		= $FF77 ; STA (stavec),Y to any bank
000810  2               CMPARE		= $FF7A ; CMP (cmpvec),Y to any bank
000810  2               PRIMM		= $FF7D ; print string following the callerâ€™s code
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Commander X16 API
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               ; Clock
000810  2               clock_set_date_time		= $FF4D ; set date and time
000810  2               clock_get_date_time		= $FF50 ; get date and time
000810  2               
000810  2               ; Mouse
000810  2               mouse_config			= $FF68 ; configure mouse pointer
000810  2               mouse_get				= $FF6B ; get state of mouse
000810  2               
000810  2               ; Joystick
000810  2               joystick_scan			= $FF53 ; query joysticks
000810  2               joystick_get			= $FF56 ; get state of one joystick
000810  2               
000810  2               ; Sprites
000810  2               sprite_set_image		= $FEF0 ; set the image of a sprite
000810  2               sprite_set_position		= $FEF3 ; set the position of a sprite
000810  2               
000810  2               ; Framebuffer
000810  2               FB_init					= $FEF6 ; enable graphics mode
000810  2               FB_get_info				= $FEF9 ; get screen size and color depth
000810  2               FB_set_palette			= $FEFC ; set (parts of) the palette
000810  2               FB_cursor_position		= $FEFF ; position the direct;access cursor
000810  2               FB_cursor_next_line		= $FF02 ; move direct;access cursor to next line
000810  2               FB_get_pixel			= $FF05 ; read one pixel, update cursor
000810  2               FB_get_pixels			= $FF08 ; copy pixels into RAM, update cursor
000810  2               FB_set_pixel			= $FF0B ; set one pixel, update cursor
000810  2               FB_set_pixels			= $FF0E ; copy pixels from RAM, update cursor
000810  2               FB_set_8_pixels			= $FF11 ; set 8 pixels from bit mask (transparent), update cursor
000810  2               FB_set_8_pixels_opaque	= $FF14 ; set 8 pixels from bit mask (opaque), update cursor
000810  2               FB_fill_pixels			= $FF17 ; fill pixels with constant color, update cursor
000810  2               FB_filter_pixels		= $FF1A ; apply transform to pixels, update cursor
000810  2               FB_move_pixels			= $FF1D ; copy horizontally consecutive pixels to a different position
000810  2               
000810  2               ; Graphics
000810  2               GRAPH_init				= $FF20 ; initialize graphics
000810  2               GRAPH_clear				= $FF23 ; clear screen
000810  2               GRAPH_set_window		= $FF26 ; set clipping region
000810  2               GRAPH_set_colors		= $FF29 ; set stroke, fill and background colors
000810  2               GRAPH_draw_line			= $FF2C ; draw a line
000810  2               GRAPH_draw_rect			= $FF2F ; draw a rectangle (optionally filled)
000810  2               GRAPH_move_rect			= $FF32 ; move pixels
000810  2               GRAPH_draw_oval			= $FF35 ; draw an oval or circle
000810  2               GRAPH_draw_image		= $FF38 ; draw a rectangular image
000810  2               GRAPH_set_font			= $FF3B ; set the current font
000810  2               GRAPH_get_char_size		= $FF3E ; get size and baseline of a character
000810  2               GRAPH_put_char			= $FF41 ; print a character
000810  2               
000810  2               ; Console
000810  2               CONSOLE_init					= $FEDB ; initialize console mode
000810  2               CONSOLE_put_char				= $FEDE ; print character to console
000810  2               CONSOLE_put_image				= $FED8 ; draw image as if it was a character
000810  2               CONSOLE_get_char				= $FEE1 ; get character from console
000810  2               CONSOLE_set_paging_message		= $FED5 ; set paging message or disable paging
000810  2               
000810  2               ; Other
000810  2               memory_fill				= $FEE4 ; fill memory region with a byte value
000810  2               memory_copy				= $FEE7 ; copy memory region
000810  2               memory_crc				= $FEEA ; calculate CRC16 of memory region
000810  2               memory_decompress		= $FEED ; decompress LZSA2 block
000810  2               entropy_get				= $FECF ; Get 24 random bits
000810  2               monitor					= $FF44 ; enter machine language monitor
000810  2               restore_basic			= $FF47 ; enter BASIC
000810  2               screen_set_mode			= $FF5F ; set screen mode
000810  2               screen_set_charset		= $FF62 ; activate 8x8 text mode charset
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; VRAM Addresses
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               VRAM_composer		= $F0000
000810  2               VRAM_hscale			= VRAM_composer+1
000810  2               VRAM_vscale			= VRAM_composer+2
000810  2               VRAM_palette		= $F1000
000810  2               VRAM_layer0			= $F2000
000810  2               VRAM_layer1			= $F3000
000810  2               VRAM_sprreg			= $F4000
000810  2               VRAM_sprattr		= $F5000
000810  2               VRAM_audio			= $F6000
000810  2               VRAM_spi			= $F7000
000810  2               VRAM_uart			= $F8000
000810  2               
000810  2               VROM_petscii				= $1F000
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; IRQs
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               IRQVec		= $0314
000810  2               BRKVec		= $0316
000810  2               NMIVec		= $0318
000810  2               
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Virtual registers
000810  2               ; ------------------------------------------------------------
000810  2               r0			= $02
000810  2               r0L			= $02
000810  2               r0H			= $03
000810  2               r1			= $04
000810  2               r1L			= $04
000810  2               r1H			= $05
000810  2               r2			= $06
000810  2               r2L			= $06
000810  2               r2H			= $07
000810  2               r3			= $08
000810  2               r3L			= $08
000810  2               r3H			= $09
000810  2               r4			= $0a
000810  2               r4L			= $0a
000810  2               r4H			= $0b
000810  2               r5			= $0c
000810  2               r5L			= $0c
000810  2               r5H			= $0d
000810  2               r6			= $0e
000810  2               r6L			= $0e
000810  2               r6H			= $0f
000810  2               r7			= $10
000810  2               r7L			= $10
000810  2               r7H			= $11
000810  2               r8			= $12
000810  2               r8L			= $12
000810  2               r8H			= $13
000810  2               r9			= $14
000810  2               r9L			= $14
000810  2               r9H			= $15
000810  2               r10			= $16
000810  2               r10L		= $16
000810  2               r10H		= $17
000810  2               r11			= $18
000810  2               r11L		= $18
000810  2               r11H		= $19
000810  2               r12			= $1a
000810  2               r12L		= $1a
000810  2               r12H		= $1b
000810  2               r13			= $1c
000810  2               r13L		= $1c
000810  2               r13H		= $1d
000810  2               r14			= $1e
000810  2               r14L		= $1e
000810  2               r14H		= $1f
000810  2               r15			= $20
000810  2               r15L		= $20
000810  2               r15H		= $21
000810  2               
000810  2               
000810  2               .endif
000810  2               
000810  1               .include "vera.inc"
000810  2               ; License: Public Domain
000810  2               .ifndef VERA_INC
000810  2               VERA_INC = 1
000810  2               
000810  2               verareg =$9f20
000810  2               
000810  2               veralo  		= verareg+$0
000810  2               veramid 		= verareg+$1
000810  2               verahi  		= verareg+$2
000810  2               veradat 		= verareg+$3
000810  2               veradat2		= verareg+$4
000810  2               veractl 		= verareg+$5
000810  2               veraien 		= verareg+$6
000810  2               veraisr 		= verareg+$7
000810  2               verairqlo 		= verareg+$8
000810  2               
000810  2               ; DCSEl = 0
000810  2               veradcvideo		= verareg+$9
000810  2               
000810  2               VERA_VGA		= %00000001
000810  2               VERA_LAYER0		= %00010000
000810  2               VERA_LAYER1		= %00100000
000810  2               VERA_SPRITE		= %01000000
000810  2               
000810  2               veradchscale	= verareg+$a
000810  2               veradcvscale	= verareg+$b
000810  2               veradcborder	= verareg+$c
000810  2               
000810  2               ; DCSEl = 1
000810  2               veradchstart	= verareg+$9
000810  2               veradchstop		= verareg+$a
000810  2               veradcvstart	= verareg+$b
000810  2               veradcvstop		= verareg+$c
000810  2               
000810  2               ; L0
000810  2               veral0config	= verareg+$d
000810  2               veral0mapbase	= verareg+$e
000810  2               veral0tilebase	= verareg+$f
000810  2               VERA_L0_hscrolllo	= verareg+$10
000810  2               VERA_L0_hscrollhi	= verareg+$11
000810  2               veral0vscrolllo	= verareg+$12
000810  2               veral0vscrollhi	= verareg+$13
000810  2               
000810  2               ; L1
000810  2               veral1config	= verareg+$14
000810  2               veral1mapbase	= verareg+$15
000810  2               veral1tilebase	= verareg+$16
000810  2               VERA_L1_hscrolllo	= verareg+$17
000810  2               VERA_L1_hscrollhi	= verareg+$18
000810  2               VERA_L1_vscrolllo	= verareg+$19
000810  2               VERA_L1_vscrollhi	= verareg+$1a
000810  2               
000810  2               VERA_CONFIG_CLEAR_TILES=%00001111
000810  2               VERA_CONFIG_32x32 = 	%00000000
000810  2               VERA_CONFIG_32x64 = 	%00010000
000810  2               VERA_CONFIG_32x128 = 	%00100000
000810  2               VERA_CONFIG_32x256 = 	%00110000
000810  2               VERA_CONFIG_64x32 = 	%01000000
000810  2               VERA_CONFIG_128x32 = 	%10000000
000810  2               VERA_CONFIG_256x32 = 	%11000000
000810  2               VERA_CONFIG_64x64 = 	%01010000
000810  2               VERA_CONFIG_64x128 = 	%01100000
000810  2               VERA_CONFIG_64x256 = 	%01110000
000810  2               VERA_CONFIG_128x64 = 	%10010000
000810  2               VERA_CONFIG_128x128 = 	%10100000
000810  2               VERA_CONFIG_128x256 = 	%10110000
000810  2               VERA_CONFIG_256x64 = 	%11010000
000810  2               VERA_CONFIG_256x128 = 	%11100000
000810  2               VERA_CONFIG_256x256 = 	%11110000
000810  2               
000810  2               VERA_CONFIG_CLEAR_DEPTH=%00001111
000810  2               VERA_CONFIG_1BPP	=	%00000000
000810  2               VERA_CONFIG_2BPP	=	%00000001
000810  2               VERA_CONFIG_4BPP	=	%00000010
000810  2               VERA_CONFIG_8BPP	=	%00000011
000810  2               
000810  2               VERA_CLEAR_TILE_SIZE= %11111100
000810  2               VERA_TILE_8x8 		= %00000000
000810  2               VERA_TILE_8x16 		= %00000010
000810  2               VERA_TILE_16x8 		= %00000001
000810  2               VERA_TILE_16x16 	= %00000011
000810  2               
000810  2               VERA_TILEBASE_CLEAR_ADR = %00000011
000810  2               
000810  2               ; audio
000810  2               veraaudioctl	= verareg+$1b
000810  2               veraaudiorate	= verareg+$1c
000810  2               veraaudiodata	= verareg+$1d
000810  2               veraspidata		= verareg+$1e
000810  2               veraspictl		= verareg+$1f
000810  2               
000810  2               vram_sprd  = $1fc00
000810  2               
000810  2               AUTO_INC_0 		= $000000
000810  2               AUTO_INC_1 		= $100000
000810  2               AUTO_INC_2 		= $200000
000810  2               AUTO_INC_4 		= $300000
000810  2               AUTO_INC_8 		= $400000
000810  2               AUTO_INC_16		= $500000
000810  2               AUTO_INC_32		= $600000
000810  2               AUTO_INC_64		= $700000
000810  2               AUTO_INC_128	= $800000
000810  2               AUTO_INC_256	= $900000
000810  2               AUTO_INC_512	= $A00000
000810  2               AUTO_INC_40		= $B00000
000810  2               AUTO_INC_80		= $C00000
000810  2               AUTO_INC_160	= $C00000
000810  2               AUTO_INC_320	= $E00000
000810  2               AUTO_INC_640	= $F00000
000810  2               
000810  2               SPRITE_SIZE_8	= $0
000810  2               SPRITE_SIZE_16	= $1
000810  2               SPRITE_SIZE_32	= $2
000810  2               SPRITE_SIZE_64	= $3
000810  2               
000810  2               SPRITE_ZDEPTH_DISABLED = %00000000
000810  2               SPRITE_ZDEPTH_BGto0 = %00000100
000810  2               SPRITE_ZDEPTH_0to1 = %00001000
000810  2               SPRITE_ZDEPTH_TOP = %00001100
000810  2               
000810  2               SPRITE_FLIP_CLEAR = %11111100
000810  2               SPRITE_FLIP_NONE = %00000000
000810  2               SPRITE_FLIP_H = %00000001
000810  2               SPRITE_FLIP_V = %00000010
000810  2               
000810  2               veral0mode = %00010000
000810  2               VERA_VSYNC_BIT         = $01
000810  2               VERA_LINE_BIT        = $04
000810  2               VERA_SPRCOL_BIT        = $04
000810  2               
000810  2               .macro vset addr
000810  2               	lda #0
000810  2               	sta veractl
000810  2               	lda #<(addr >> 16) | $10
000810  2               	sta verahi
000810  2               	lda #<(addr >> 8)
000810  2               	sta veramid
000810  2               	lda #<(addr)
000810  2               	sta veralo
000810  2               .endmacro
000810  2               
000810  2               .macro vset2 addr
000810  2               	lda #1
000810  2               	sta veractl
000810  2               	lda #<(addr >> 16) | $10
000810  2               	sta verahi
000810  2               	lda #<(addr >> 8)
000810  2               	sta veramid
000810  2               	lda #<(addr)
000810  2               	sta veralo
000810  2               .endmacro
000810  2               
000810  2               .macro vstore addr
000810  2               	pha
000810  2               	vset addr
000810  2               	pla
000810  2               	sta veradat
000810  2               .endmacro
000810  2               
000810  2               .macro vstore2 addr
000810  2               	pha
000810  2               	vset addr
000810  2               	pla
000810  2               	sta veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro vload addr
000810  2               	vset addr
000810  2               	lda veradat
000810  2               .endmacro
000810  2               
000810  2               .macro vload2 addr
000810  2               	vset addr
000810  2               	lda veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro sprset offset
000810  2               	lda #<(vram_sprd >> 16) | $10
000810  2               	sta verahi
000810  2               	txa
000810  2               	lsr
000810  2               	lsr
000810  2               	lsr
000810  2               	lsr
000810  2               	lsr
000810  2               	clc
000810  2               	adc #<((vram_sprd + offset) >> 8)
000810  2               	sta veramid
000810  2               	txa
000810  2               	asl
000810  2               	asl
000810  2               	asl
000810  2               	clc
000810  2               	adc #<(vram_sprd + offset)
000810  2               	sta veralo
000810  2               .endmacro
000810  2               
000810  2               .macro sprload offset
000810  2               	sprset offset
000810  2               	lda veradat
000810  2               .endmacro
000810  2               
000810  2               .macro sprload2 offset
000810  2               	sprset offset
000810  2               	lda veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro sprstore offset
000810  2               	pha
000810  2               	sprset offset
000810  2               	pla
000810  2               	sta veradat
000810  2               .endmacro
000810  2               
000810  2               .macro sprstore2 offset
000810  2               	pha
000810  2               	sprset offset
000810  2               	pla
000810  2               	sta veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro video_init
000810  2               	lda #0
000810  2               	sta veractl ; set ADDR1 active
000810  2               	sta veramid
000810  2               	lda #$1F    ; $F0000 increment 1
000810  2               	sta verahi
000810  2               	lda #$00
000810  2               	sta veralo
000810  2               	lda #1
000810  2               	sta veradat ; VGA output
000810  2               .endmacro
000810  2               
000810  2               ; set the tilebase for the layer
000810  2               .macro VTILEBASE layer,addr
000810  2                   lda veral0tilebase + layer * 7                  ; set memory for tilebase
000810  2               	and #VERA_TILEBASE_CLEAR_ADR
000810  2               	ora #(addr >> 9)
000810  2               	sta veral0tilebase + layer * 7
000810  2               .endmacro
000810  2               
000810  2               ; define size of tiles for layer
000810  2               .macro VTILEMODE layer, mode
000810  2               	lda veral0tilebase + layer * 7
000810  2               	and #VERA_CLEAR_TILE_SIZE
000810  2               	ora #mode
000810  2               	sta veral0tilebase + layer * 7
000810  2               .endmacro
000810  2               
000810  2               
000810  2               ; define number of tiles in the map
000810  2               .macro VCONFIG_TILES layer,mode
000810  2               	lda veral0config + layer * 7
000810  2               	and #VERA_CONFIG_CLEAR_TILES
000810  2               	ora #mode
000810  2               	sta veral0config + layer * 7
000810  2               .endmacro
000810  2               
000810  2               ; define number of colors for the map
000810  2               .macro VCONFIG_DEPTH layer,mode
000810  2               	lda veral0config + layer * 7
000810  2               	and #VERA_CONFIG_CLEAR_DEPTH
000810  2               	ora #mode
000810  2               	sta veral0config + layer * 7
000810  2               .endmacro
000810  2               
000810  2               ; set the mapbase for the layer
000810  2               .macro VMAPBASE layer,addr
000810  2                   lda #(addr >> 9)         ; store 2 last bits
000810  2                   sta veral0mapbase + layer * 7                   ; Store to Map Base Pointer
000810  2               .endmacro
000810  2               
000810  2               .endif
000810  2               
000810  1               
000810  1               ; VRAM Addresses
000810  1               VRAM_layer0_map   = $00000
000810  1               VRAM_layer1_map   = $00800
000810  1               VRAM_tiles        = $01000
000810  1               
000810  1               HIMEM = $a000
000810  1               
000810  1               SCREEN_WIDTH = 320
000810  1               SCREEN_HEIGHT = 240
000810  1               LEVEL_TILES_WIDTH = 32
000810  1               LEVEL_WIDTH = LEVEL_TILES_WIDTH*16
000810  1               LEVEL_HEIGHT = 32*16
000810  1               
000810  1               .enum
000810  1               	TILE_NO_COLLISION
000810  1               	TILE_SOLID_GROUND
000810  1               	TILE_SOLD_SLOP_LEFT
000810  1               	TILE_SOLD_SLOP_RIGHT
000810  1               	TILE_SOLID_LADER
000810  1               	TILE_LEDGE
000810  1               .endenum
000810  1               
000810  1               .macro SET_DEBUG
000810  1               	inc trigger_debug
000810  1               .endmacro
000810  1               
000810  1               .macro CHECK_DEBUG
000810  1               	pha
000810  1               	lda trigger_debug
000810  1               	beq @no_debug
000810  1               	dec trigger_debug
000810  1               	stp
000810  1               @no_debug:
000810  1               	pla
000810  1               .endmacro
000810  1               
000810  1               ;---------------------------------
000810  1               ; joystick management
000810  1               ;---------------------------------
000810  1               
000810  1               JOY_RIGHT 	= %00000001
000810  1               JOY_LEFT 	= %00000010
000810  1               JOY_DOWN 	= %00000100
000810  1               JOY_UP 		= %00001000
000810  1               JOY_START	= %00010000
000810  1               JOY_SEL		= %00100000
000810  1               JOY_Y		= %01000000
000810  1               JOY_B		= %10000000
000810  1               
000810  1               JOY_A		= %10000000
000810  1               
000810  1               .macro VCOPY from, to, blocks
000810  1               	LOAD_r0 from
000810  1               	LOAD_r1 (to & $00ffff)
000810  1               	ldy #(to >> 16)
000810  1               	ldx #(blocks)
000810  1               	jsr Vera::vcopy
000810  1               .endmacro
000810  1               
000810  1               ;-----------------------------------------------------------------------------
000810  1               ;/////////////////////////////////////////////////////////////////////////////
000810  1               ; START Vera code
000810  1               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000810  1               ;-----------------------------------------------------------------------------
000810  1               
000810  1  00 00        current_load: .word 0		; end of the last memory load
000812  1               
000812  1               .macro LOAD_FILE filename, length, ram
000812  1               	lda #1
000812  1               	ldx #8
000812  1               	ldy #0
000812  1               	jsr SETLFS
000812  1               	lda #length
000812  1               	ldx #<filename
000812  1               	ldy #>filename
000812  1               	jsr SETNAM
000812  1               	lda #0
000812  1               	ldx #<ram
000812  1               	ldy #>ram
000812  1               	jsr LOAD
000812  1               	stx current_load
000812  1               	sty current_load + 1
000812  1               .endmacro
000812  1               
000812  1               .macro LOAD_FILE_NEXT filename, length
000812  1               	lda #1
000812  1               	ldx #8
000812  1               	ldy #0
000812  1               	jsr SETLFS
000812  1               	lda #length
000812  1               	ldx #<filename
000812  1               	ldy #>filename
000812  1               	jsr SETNAM
000812  1               	lda #0
000812  1               	ldx current_load
000812  1               	ldy current_load + 1
000812  1               	jsr LOAD
000812  1               	stx current_load
000812  1               	sty current_load + 1
000812  1               .endmacro
000812  1               
000812  1               .scope Vera
000812  1               
000812  1  00 00        vram_load: .word 0		; end of the last memory load
000814  1               
000814  1               .macro VLOAD_FILE filename, length, vram
000814  1               	lda #1
000814  1               	ldx #8
000814  1               	ldy #0
000814  1               	jsr SETLFS
000814  1               	lda #length
000814  1               	ldx #<filename
000814  1               	ldy #>filename
000814  1               	jsr SETNAM
000814  1               	lda #(^vram + 2)
000814  1               	ldx #<vram
000814  1               	ldy #>vram
000814  1               	jsr LOAD
000814  1               	stx Vera::vram_load
000814  1               	sty Vera::vram_load + 1
000814  1               .endmacro
000814  1               
000814  1               .macro VLOAD_FILE_NEXT filename, length
000814  1               	lda #1
000814  1               	ldx #8
000814  1               	ldy #0
000814  1               	jsr SETLFS
000814  1               	lda #length
000814  1               	ldx #<filename
000814  1               	ldy #>filename
000814  1               	jsr SETNAM
000814  1               	lda #(^Vera::vram_load + 2)
000814  1               	ldx Vera::vram_load
000814  1               	ldy Vera::vram_load + 1
000814  1               	jsr LOAD
000814  1               	stx Vera::vram_load
000814  1               	sty Vera::vram_load + 1
000814  1               .endmacro
000814  1               
000814  1               ;
000814  1               ; copy from rom to vram
000814  1               ;	r0 : from
000814  1               ;	r1 : to (first 16 bites)
000814  1               ;   	y : vera bank (0, 1)
000814  1               ;	X: blocks
000814  1               ;
000814  1               vcopy:
000814  1  A9 00        	lda #0
000816  1  8D 25 9F     	sta veractl
000819  1  98           	tya
00081A  1  09 10        	ora #$10
00081C  1  8D 22 9F     	sta verahi
00081F  1  A5 05        	lda r1H
000821  1  8D 21 9F     	sta veramid
000824  1  A5 04        	lda r1L
000826  1  8D 20 9F     	sta veralo
000829  1               
000829  1               @loop:
000829  1  A0 00            ldy #0
00082B  1               @loop1tile:
00082B  1  B1 02        	lda (r0),y                         	; read from tiles data
00082D  1  8D 23 9F         sta veradat                      	; Write to VRAM with +1 Autoincrement
000830  1  C8               iny
000831  1  D0 F8            bne @loop1tile
000833  1               
000833  1  E6 03        	inc r0H
000835  1  CA           	dex
000836  1  D0 F1        	bne @loop
000838  1  60           	rts
000839  1               .endscope
000839  1               
000839  1               .include "tiles.asm"
000839  2               ;-----------------------------------------------------------------------------
000839  2               ;/////////////////////////////////////////////////////////////////////////////
000839  2               ; START Tiles code
000839  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000839  2               ;-----------------------------------------------------------------------------
000839  2               
000839  2               .enum TILE_ATTR
000839  2               	SOLID_GROUND = 1
000839  2               	SOLID_WALL = 2
000839  2               	SOLID_CEILING = 4
000839  2               	GRABBING = 8			; player can grab the tile (ladder, ledge, rope)
000839  2               .endenum
000839  2               
000839  2               
000839  2               .scope Tiles
000839  2               
000839  2               ;animated_tiles_map
000839  2               ;   nb_animated_tiles
000839  2               ;   tile[0]
000839  2               ;        tick,
000839  2               ;        nb_frames
000839  2               ;        current_frame
000839  2               ;        @frame[0][0]
000839  2               ;        nb_tiles
000839  2               ;        @addr_tiles_list[0]
000839  2               ;   tile[1]
000839  2               ;   ....
000839  2               ;   tile[nb_animated_tiles-1]
000839  2               ;   frame[t0][0]: duration, tile_index
000839  2               ;   frame[t0][1]
000839  2               ;   .....
000839  2               ;   frame[t0][ tile[0].nb_frames - 1 ]
000839  2               ;   frame[t1][0]: duration, tile_index
000839  2               ;   frame[t1][1]
000839  2               ;   .....
000839  2               ;   frame[t1][ tile[1].nb_frames - 1 ]
000839  2               ;   .....
000839  2               ;   frame[tnb_animated_tiles-1][0]
000839  2               ;   .....
000839  2               ;   frame[tnb_animated_tiles-1][ tile[nb_animated_tiles-1].nb_frames - 1 ]
000839  2               ;   addr_tiles_list[0] : tile[0].nb_tiles word
000839  2               ;   addr_tiles_list[1] : tile[1].nb_tiles word
000839  2               ;   addr_tiles_list[nb_animated_times -1] : tile[1].nb_tiles word
000839  2               
000839  2               .struct ANIMATED_TILES
000839  2                   nb_animated_tiles   .byte
000839  2               
000839  2                   .struct ANIMATED_TILE
000839  2                       tick            .byte   ; number of 18ms frames until next animation
000839  2                       nb_frames       .byte
000839  2                       current_frame   .byte
000839  2                       addr_frames  .addr   ; offset of the list of animation
000839  2                       nb_tiles        .byte   ; numner of tiles on the tilemap
000839  2                       addr_tiles_list      .addr   ; offset of the list of tiles on the tilemap
000839  2                   .endstruct
000839  2               .endstruct
000839  2               
000839  2               .struct FRAME
000839  2                   duration    .byte
000839  2                   tile_index  .byte
000839  2               .endstruct
000839  2               
000839  2               animated_tiles_map = HIMEM + $400
000839  2               animated_tiles = HIMEM + $400 + 1
000839  2               
000839  2  74 69 6C 65  fsanimated_tiles: .literal "tilesani.bin"
00083D  2  73 61 6E 69  
000841  2  2E 62 69 6E  
000845  2               fsanimated_tiles_end:
000845  2               
000845  2               ;-----------------------------------------
000845  2               ; load static tiles
000845  2               ;
000845  2               load_static:
000845  2  A9 01 A2 08  	VLOAD_FILE fstile, (fstileend-fstile), ::VRAM_tiles
000849  2  A0 00 20 BA  
00084D  2  FF A9 09 A2  
000866  2  AD 2F 9F 29  	VTILEBASE 0, ::VRAM_tiles
00086A  2  03 09 08 8D  
00086E  2  2F 9F        
000870  2  AD 36 9F 29  	VTILEBASE 1, ::VRAM_tiles
000874  2  03 09 08 8D  
000878  2  36 9F        
00087A  2  AD 2F 9F 29  	VTILEMODE 0,VERA_TILE_16x16
00087E  2  FC 09 03 8D  
000882  2  2F 9F        
000884  2  AD 36 9F 29  	VTILEMODE 1,VERA_TILE_16x16
000888  2  FC 09 03 8D  
00088C  2  36 9F        
00088E  2  60               rts
00088F  2               
00088F  2               ;-----------------------------------------
00088F  2               ; load and fix the animated tiles data
00088F  2               ;
00088F  2               load_anim:
00088F  2  A9 00        	lda #0
000891  2  85 00        	sta $00
000893  2  A9 01 A2 08  	LOAD_FILE fsanimated_tiles, (fsanimated_tiles_end-fsanimated_tiles), animated_tiles_map
000897  2  A0 00 20 BA  
00089B  2  FF A9 0C A2  
0008B4  2               
0008B4  2                   ; convert offsets in the data structure to memory addr
0008B4  2  AC 00 A4         ldy animated_tiles_map + ANIMATED_TILES::nb_animated_tiles
0008B7  2  A2 00            ldx #0
0008B9  2               
0008B9  2               @next_tile:
0008B9  2  18               clc
0008BA  2  BD 04 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames, x
0008BD  2  69 00            adc #<animated_tiles_map
0008BF  2  9D 04 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames, x
0008C2  2  BD 05 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames + 1, x
0008C5  2  69 A4            adc #>animated_tiles_map
0008C7  2  9D 05 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames + 1, x
0008CA  2               
0008CA  2  18               clc
0008CB  2  BD 07 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list, x
0008CE  2  69 00            adc #<animated_tiles_map
0008D0  2  9D 07 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list, x
0008D3  2  BD 08 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list + 1, x
0008D6  2  69 A4            adc #>animated_tiles_map
0008D8  2  9D 08 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list + 1, x
0008DB  2               
0008DB  2  88               dey
0008DC  2  F0 07            beq @convert_tileslist_addr
0008DE  2               
0008DE  2  8A               txa
0008DF  2  18               clc
0008E0  2  69 08            adc #.sizeof(ANIMATED_TILES::ANIMATED_TILE)
0008E2  2  AA               tax
0008E3  2  80 D4            bra @next_tile
0008E5  2               
0008E5  2               @convert_tileslist_addr:
0008E5  2                   ; convert tilemap offset into vera offset
0008E5  2                   ; convert offsets in the data structure to memory addr
0008E5  2  AC 00 A4         ldy animated_tiles_map + ANIMATED_TILES::nb_animated_tiles
0008E8  2  A2 00            ldx #0
0008EA  2               @next_tile1:
0008EA  2                   ; setup the listf of memory offset in vera memory
0008EA  2  BD 07 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list, x
0008ED  2  85 02            sta r0L
0008EF  2  BD 08 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list + 1, x
0008F2  2  85 03            sta r0H
0008F4  2               
0008F4  2  5A               phy
0008F5  2  DA               phx
0008F6  2  BD 06 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::nb_tiles, x
0008F9  2  AA               tax
0008FA  2  A0 00            ldy #00
0008FC  2               
0008FC  2               @loop_tiles:
0008FC  2  18               clc
0008FD  2  B1 02            lda (r0),y
0008FF  2  69 00            adc #<VRAM_layer1_map
000901  2  91 02            sta (r0),y
000903  2  C8               iny
000904  2               
000904  2  B1 02            lda (r0),y
000906  2  69 08            adc #>VRAM_layer1_map
000908  2  91 02            sta (r0),y
00090A  2  C8               iny
00090B  2               
00090B  2  CA               dex
00090C  2  D0 EE            bne @loop_tiles
00090E  2  FA               plx
00090F  2  7A               ply
000910  2               
000910  2  88               dey
000911  2  F0 07            beq @init
000913  2               
000913  2  8A               txa
000914  2  18               clc
000915  2  69 08            adc #.sizeof(ANIMATED_TILES::ANIMATED_TILE)
000917  2  AA               tax
000918  2  80 D0            bra @next_tile1
00091A  2               
00091A  2               @init:
00091A  2                   ; init the timers
00091A  2  AC 00 A4         ldy animated_tiles_map + ANIMATED_TILES::nb_animated_tiles
00091D  2  A2 00            ldx #0
00091F  2               
00091F  2               @next_tile2:
00091F  2                   ; setup the list of frames
00091F  2  BD 04 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames, x
000922  2  85 02            sta r0L
000924  2  BD 05 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames + 1, x
000927  2  85 03            sta r0H
000929  2               
000929  2                   ; save new frame duration in the timer
000929  2  B2 02            lda (r0)
00092B  2  9D 01 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::tick, x
00092E  2               
00092E  2  88               dey
00092F  2  F0 07            beq @return
000931  2               
000931  2  8A               txa
000932  2  18               clc
000933  2  69 08            adc #.sizeof(ANIMATED_TILES::ANIMATED_TILE)
000935  2  AA               tax
000936  2  80 E7            bra @next_tile2
000938  2               
000938  2               @return:
000938  2  60               rts
000939  2               
000939  2               ;-----------------------------------------
000939  2               ; parse the animated tiles to update
000939  2               ;
000939  2               animate:
000939  2  AC 00 A4         ldy animated_tiles_map + ANIMATED_TILES::nb_animated_tiles
00093C  2  A2 00            ldx #0
00093E  2               
00093E  2               @next_tile:
00093E  2  DE 01 A4         dec animated_tiles + ANIMATED_TILES::ANIMATED_TILE::tick, x
000941  2  D0 03            bne :+
000943  2  20 51 09         jsr next_frame
000946  2               :
000946  2  88               dey
000947  2  F0 07            beq @return
000949  2               
000949  2  8A               txa
00094A  2  18               clc
00094B  2  69 08            adc #.sizeof(ANIMATED_TILES::ANIMATED_TILE)
00094D  2  AA               tax
00094E  2  80 EE            bra @next_tile
000950  2               
000950  2               @return:
000950  2  60               rts
000951  2               
000951  2               ;-----------------------------------------
000951  2               ; move to the next frame of an animated tile
000951  2               ; update tiles on the tilemap
000951  2               ; input X : offset of the anim_tile structure
000951  2               ;
000951  2               next_frame:
000951  2  BD 03 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::current_frame, x
000954  2  1A               inc
000955  2  DD 02 A4         cmp animated_tiles + ANIMATED_TILES::ANIMATED_TILE::nb_frames, x
000958  2  D0 02            bne :+
00095A  2  A9 00            lda #00         ; roll back to 0
00095C  2               :
00095C  2  9D 03 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::current_frame, x
00095F  2  DA               phx
000960  2  5A               phy
000961  2               
000961  2  0A               asl         ; the are 2 bytes per frame, so multiply the index by 2
000962  2  A8               tay         ; Y = current animation frame
000963  2               
000963  2                   ; setup the list of frames
000963  2  BD 04 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames, x
000966  2  85 02            sta r0L
000968  2  BD 05 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames + 1, x
00096B  2  85 03            sta r0H
00096D  2               
00096D  2  B1 02            lda (r0), y         ; save new frame duration in the timer
00096F  2  9D 01 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::tick, x
000972  2  C8               iny
000973  2  B1 02            lda (r0), y
000975  2  85 30            sta $30                 ; X = index of the new tile to store in VERA memory
000977  2               
000977  2                   ; setup the listf of memory offset in vera memory
000977  2  BD 07 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list, x
00097A  2  85 02            sta r0L
00097C  2  BD 08 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list + 1, x
00097F  2  85 03            sta r0H
000981  2               
000981  2                   ; push all tiles in vera memory
000981  2  BD 06 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::nb_tiles, x
000984  2  0A               asl         ; number of tiles in the list * 2 (these are addr)
000985  2  3A               dec         ; start at the end
000986  2  A8               tay
000987  2               
000987  2  A6 30            ldx $30
000989  2               
000989  2               @next_tile_index:
000989  2                   ; set the vera memory (as we start from the end of the list, vera gigh is first)
000989  2               
000989  2  A9 00        	lda #0
00098B  2  8D 25 9F     	sta veractl
00098E  2  A9 02          	lda #(^VRAM_layer1_map + 2)
000990  2  8D 22 9F     	sta verahi
000993  2  B1 02            lda (r0), y
000995  2  8D 21 9F     	sta veramid	                ; vera = $1fc00 + sprite index (X) * 8
000998  2  88               dey
000999  2  B1 02            lda (r0), y
00099B  2  8D 20 9F     	sta veralo
00099E  2  88               dey
00099F  2  8E 23 9F         stx veradat
0009A2  2               
0009A2  2  10 E5            bpl @next_tile_index
0009A4  2               
0009A4  2  7A               ply
0009A5  2  FA               plx
0009A6  2  60               rts
0009A7  2               .endscope
0009A7  2               
0009A7  1               .include "sprites.asm"
0009A7  2               ;-----------------------------------------------------------------------------
0009A7  2               ;/////////////////////////////////////////////////////////////////////////////
0009A7  2               ; START Sprite code
0009A7  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
0009A7  2               ;-----------------------------------------------------------------------------
0009A7  2               
0009A7  2               .struct VSPRITE
0009A7  2               	address125 .byte
0009A7  2               	mode_xxx_address1613 .byte
0009A7  2               	x70 .byte
0009A7  2               	x98 .byte
0009A7  2               	y70 .byte
0009A7  2               	y98 .byte
0009A7  2               	collision_zdepth_vflip_hflip .byte
0009A7  2               	height_width_offset .byte
0009A7  2               .endstruct
0009A7  2               
0009A7  2               .scope Sprite
0009A7  2               
0009A7  2               SPRITES_ZP = $0070	; memory reserved for Sprites
0009A7  2               
0009A7  2               ;-----------------------------------------
0009A7  2               ; sprites components collections
0009A7  2               MAX_SPRITES = 32
0009A7  2               
0009A7  2  xx xx xx xx  sprites_xL: .res MAX_SPRITES
0009AB  2  xx xx xx xx  
0009AF  2  xx xx xx xx  
0009C7  2  xx xx xx xx  sprites_xH: .res MAX_SPRITES
0009CB  2  xx xx xx xx  
0009CF  2  xx xx xx xx  
0009E7  2  xx xx xx xx  sprites_yL: .res MAX_SPRITES
0009EB  2  xx xx xx xx  
0009EF  2  xx xx xx xx  
000A07  2  xx xx xx xx  sprites_yH: .res MAX_SPRITES
000A0B  2  xx xx xx xx  
000A0F  2  xx xx xx xx  
000A27  2  xx xx xx xx  sprites_x1L: .res MAX_SPRITES
000A2B  2  xx xx xx xx  
000A2F  2  xx xx xx xx  
000A47  2  xx xx xx xx  sprites_x1H: .res MAX_SPRITES
000A4B  2  xx xx xx xx  
000A4F  2  xx xx xx xx  
000A67  2  xx xx xx xx  sprites_y1L: .res MAX_SPRITES
000A6B  2  xx xx xx xx  
000A6F  2  xx xx xx xx  
000A87  2  xx xx xx xx  sprites_y1H: .res MAX_SPRITES
000A8B  2  xx xx xx xx  
000A8F  2  xx xx xx xx  
000AA7  2  xx xx xx xx  sprites_aabb_x: .res MAX_SPRITES	; collision box INSIDE the sprite top-left corner
000AAB  2  xx xx xx xx  
000AAF  2  xx xx xx xx  
000AC7  2  xx xx xx xx  sprites_aabb_y: .res MAX_SPRITES
000ACB  2  xx xx xx xx  
000ACF  2  xx xx xx xx  
000AE7  2  xx xx xx xx  sprites_aabb_w: .res MAX_SPRITES	; collision box INSIDE the sprite height/width
000AEB  2  xx xx xx xx  
000AEF  2  xx xx xx xx  
000B07  2  xx xx xx xx  sprites_aabb_h: .res MAX_SPRITES
000B0B  2  xx xx xx xx  
000B0F  2  xx xx xx xx  
000B27  2  xx xx xx xx  sprites_collision_callback: .res (MAX_SPRITES * 2)
000B2B  2  xx xx xx xx  
000B2F  2  xx xx xx xx  
000B67  2               
000B67  2  xx xx xx xx  sprites: .res 256		; store VRAM 12:5 address of each of the 128 sprites
000B6B  2  xx xx xx xx  
000B6F  2  xx xx xx xx  
000C67  2  01           nb_sprites: .byte 1		; 1 reserved for the player
000C68  2  00 00        collisions: .word 0		; L = collision happened, H = collision mask
000C6A  2               
000C6A  2               ;************************************************
000C6A  2               ;  init sprites manager
000C6A  2               ; create a table with the VERA @addr for each sprite
000C6A  2               ;
000C6A  2               init_addr_table:
000C6A  2               	; clear the sprites components
000C6A  2  A6 20        	ldx MAX_SPRITES
000C6C  2  CA           	dex
000C6D  2               :
000C6D  2  9E A7 09     	stz sprites_xL,x
000C70  2  9E C7 09     	stz sprites_xH,x
000C73  2  9E E7 09     	stz sprites_yL,x
000C76  2  9E 07 0A     	stz sprites_yH,x
000C79  2  9E E7 0A     	stz sprites_aabb_w,x
000C7C  2  9E 07 0B     	stz sprites_aabb_h,x
000C7F  2  9E A7 0A     	stz sprites_aabb_x,x
000C82  2  9E C7 0A     	stz sprites_aabb_y,x
000C85  2  CA           	dex
000C86  2  10 E5        	bpl :-
000C88  2               
000C88  2               	; activate sprite colisions
000C88  2               	;lda veraien
000C88  2               	;ora #VERA_SPRCOL_BIT
000C88  2               	;sta veraien
000C88  2               
000C88  2               	; all sprites are availble but ZERO (reserved player)
000C88  2  A2 FF        	ldx #$ff
000C8A  2               :
000C8A  2  9E 67 0B     	stz sprites,X
000C8D  2  CA           	dex
000C8E  2  D0 FA        	bne :-
000C90  2  A9 01        	lda #01
000C92  2  8D 67 0B     	sta sprites
000C95  2               
000C95  2               	; start of the sprites in VERA memory
000C95  2  A9 00        	lda #<vram_sprd
000C97  2  85 02        	sta r0L
000C99  2  A9 FC        	lda #>vram_sprd
000C9B  2  85 03        	sta r0H
000C9D  2               
000C9D  2  A2 80        	ldx #128
000C9F  2  A0 00        	ldy #0
000CA1  2                @loop:
000CA1  2  A5 03        	lda r0H
000CA3  2  99 54 1D     	sta sprites_table,y
000CA6  2  C8           	iny
000CA7  2  A5 02        	lda r0L
000CA9  2  99 54 1D     	sta sprites_table,y
000CAC  2  C8           	iny
000CAD  2               
000CAD  2  18           	clc
000CAE  2  A5 02        	lda r0L
000CB0  2  69 08        	adc #8
000CB2  2  85 02        	sta r0L
000CB4  2  A5 03        	lda r0H
000CB6  2  69 00        	adc #0
000CB8  2  85 03        	sta r0H	; move to next sprite
000CBA  2               
000CBA  2  CA           	dex
000CBB  2  D0 E4        	bne @loop
000CBD  2               
000CBD  2  60           	rts
000CBE  2               
000CBE  2               ;************************************************
000CBE  2               ; get a new available vera sprite
000CBE  2               ;	output: X = index of the vera sprite
000CBE  2               ;			0 = no sprite available
000CBE  2               ;
000CBE  2               new:
000CBE  2  A2 01        	ldx #$01
000CC0  2               :
000CC0  2  BD 67 0B     	lda sprites,x
000CC3  2  F0 03        	beq @return
000CC5  2  E8           	inx
000CC6  2  D0 F8        	bne :-
000CC8  2               @return:
000CC8  2  A9 01        	lda #01
000CCA  2  9D 67 0B     	sta sprites,x
000CCD  2               
000CCD  2               	; count activated sprites
000CCD  2  EC 67 0C     	cpx nb_sprites
000CD0  2  90 03        	bcc :+
000CD2  2               
000CD2  2  EE 67 0C     	inc nb_sprites
000CD5  2               :
000CD5  2  60           	rts
000CD6  2               
000CD6  2               ;
000CD6  2               ; the the VERA memory pointer to sprite Y + attribute X
000CD6  2               ;	Y = sprite index
000CD6  2               ;	X = attribute offset
000CD6  2               ;
000CD6  2               vram:
000CD6  2  DA           	phx			; save X on the stack
000CD7  2               
000CD7  2  98           	tya			; index of the sprite
000CD8  2  0A           	asl
000CD9  2  A8           	tay			; index of the address of the sprite (y*2)
000CDA  2               
000CDA  2  A9 00        	lda #0
000CDC  2  8D 25 9F     	sta veractl
000CDF  2  A9 11        	lda #<(vram_sprd >> 16) | $10
000CE1  2  8D 22 9F     	sta verahi
000CE4  2  B9 54 1D     	lda sprites_table, y
000CE7  2  8D 21 9F     	sta veramid
000CEA  2  C8           	iny
000CEB  2  BA           	tsx
000CEC  2  BD 01 01     	lda $0101,x	; reload X from the stack
000CEF  2  79 54 1D     	adc sprites_table, y
000CF2  2  8D 20 9F     	sta veralo	; vera = $1fc00 + sprite index (X) * 8
000CF5  2  FA           	plx
000CF6  2  60           	rts
000CF7  2               
000CF7  2               ;************************************************
000CF7  2               ; configure the sprite
000CF7  2               ;	input: 	A = sprite collision mask
000CF7  2               ;			Y = sprite index
000CF7  2               ;		   	X = sprite size :
000CF7  2               ;		   	r0 = vram @ of the sprite data
000CF7  2               ;
000CF7  2  07 0F 1F 3F  sprites_size: .byte 7, 15, 31, 63	; count byte 0 as a byte, so width is not "8" pixel nut "0" + "7" pixels
000CFB  2               
000CFB  2               load:
000CFB  2  86 70        	stx SPRITES_ZP
000CFD  2  85 72        	sta SPRITES_ZP + 2
000CFF  2  84 73        	sty SPRITES_ZP + 3
000D01  2  20 74 0D     	jsr set_bitmap
000D04  2               
000D04  2  9C 23 9F     	stz veradat					; x = 0
000D07  2  9C 23 9F     	stz veradat
000D0A  2  9C 23 9F     	stz veradat					; y = 0
000D0D  2  9C 23 9F     	stz veradat
000D10  2  A5 72        	lda SPRITES_ZP + 2			; load collision mask
000D12  2  09 00        	ora #%00000000				; collision mask + sprite = disabled + vflip=none + hflip=none
000D14  2  8D 23 9F     	sta veradat
000D17  2  A5 70        	lda SPRITES_ZP				; 32x32 sprite
000D19  2  8D 23 9F     	sta veradat
000D1C  2               
000D1C  2  4A           	lsr
000D1D  2  4A           	lsr
000D1E  2  4A           	lsr
000D1F  2  4A           	lsr
000D20  2  85 70        	sta SPRITES_ZP				; focus on sprite_height, sprite_width
000D22  2               
000D22  2  A4 73        	ldy SPRITES_ZP + 3			; sprite index
000D24  2               
000D24  2  29 03        	and #%00000011				; sprite_width
000D26  2  AA           	tax
000D27  2  BD F7 0C     	lda sprites_size,x
000D2A  2  99 E7 0A     	sta sprites_aabb_w, y		; store width in pixels in the sprite attribute
000D2D  2  A9 00        	lda #00
000D2F  2  99 A7 0A     	sta sprites_aabb_x, y		; default collision box starts (0,0)
000D32  2               
000D32  2  A5 70        	lda SPRITES_ZP
000D34  2  4A           	lsr
000D35  2  4A           	lsr							; sprite_height
000D36  2  AA           	tax
000D37  2  BD F7 0C     	lda sprites_size,x
000D3A  2  99 07 0B     	sta sprites_aabb_h, y		; store height in pixels in the sprite attribute
000D3D  2  A9 00        	lda #00
000D3F  2  99 C7 0A     	sta sprites_aabb_y, y		; default collision box starts (0,0)
000D42  2               
000D42  2  60           	rts
000D43  2               
000D43  2               ;************************************************
000D43  2               ; set the collision box of the sprite
000D43  2               ;	input y = sprite index
000D43  2               ;		r0L = top-left corner X
000D43  2               ;		r0H = top-left corner Y
000D43  2               ;		r1L = width
000D43  2               ;		r1H = height
000D43  2               ;
000D43  2               set_aabb:
000D43  2  A5 02        	lda r0L
000D45  2  99 A7 0A     	sta sprites_aabb_x,y
000D48  2  A5 03        	lda r0H
000D4A  2  99 C7 0A     	sta sprites_aabb_y,y
000D4D  2  A5 04        	lda r1L
000D4F  2  99 E7 0A     	sta sprites_aabb_w,y
000D52  2  A5 05        	lda r1H
000D54  2  99 07 0B     	sta sprites_aabb_h,y
000D57  2  60           	rts
000D58  2               
000D58  2               ;************************************************
000D58  2               ; configure full veram memory (16:0) into optimized one (12:5)
000D58  2               ;	input: r0 = vram @ of the sprite data
000D58  2               ;	output: r1
000D58  2               ;
000D58  2               vram_to_16_5:
000D58  2               	; load full VERA memory (12:0) into R0
000D58  2  A5 02        	lda r0L
000D5A  2  85 04        	sta r1L
000D5C  2  A5 03        	lda r0H
000D5E  2  85 05        	sta r1H
000D60  2               
000D60  2               	; convert full addr to vera mode (bit shiting >> 5)
000D60  2  A5 05        	lda r1H
000D62  2  4A           	lsr
000D63  2  66 04        	ror r1L
000D65  2  4A           	lsr
000D66  2  66 04        	ror r1L
000D68  2  4A           	lsr
000D69  2  66 04        	ror r1L
000D6B  2  4A           	lsr
000D6C  2  66 04        	ror r1L						; bit shift 4x 16 bits vera memory
000D6E  2  4A           	lsr
000D6F  2  66 04        	ror r1L						; bit shift 4x 16 bits vera memory
000D71  2  85 05        	sta r1H
000D73  2  60           	rts
000D74  2               
000D74  2               ;************************************************
000D74  2               ; change the address of the bitmap for the sprite
000D74  2               ;	Y = sprite index
000D74  2               ;	r0 = vera memory (12:5)
000D74  2               ;
000D74  2               set_bitmap:
000D74  2  A2 00        	ldx #VSPRITE::address125
000D76  2  20 D6 0C     	jsr vram			; set very pointer to the address of the bitmap
000D79  2               
000D79  2  A5 02        	lda r0L
000D7B  2  8D 23 9F     	sta veradat
000D7E  2  A5 03        	lda r0H
000D80  2  09 80        	ora #$80						; M = 8 bits
000D82  2  8D 23 9F     	sta veradat
000D85  2               
000D85  2  60           	rts
000D86  2               
000D86  2               ;************************************************
000D86  2               ; change the display byte for a sprite
000D86  2               ;	Y = sprite index
000D86  2               ;	X = display value to set
000D86  2               ;
000D86  2               display:
000D86  2  86 02        	stx r0L		; save X for later
000D88  2  84 03        	sty r0H
000D8A  2               
000D8A  2               	; set vram memory on the X sprite
000D8A  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000D8C  2  20 D6 0C     	jsr vram
000D8F  2  AD 23 9F     	lda veradat
000D92  2  29 F3        	and #(<~SPRITE_ZDEPTH_TOP)
000D94  2  05 02        	ora r0L
000D96  2  85 02        	sta r0L
000D98  2               
000D98  2  A4 03        	ldy r0H
000D9A  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000D9C  2  20 D6 0C     	jsr vram
000D9F  2               
000D9F  2  A5 02        	lda r0L
000DA1  2  8D 23 9F     	sta veradat
000DA4  2  60           	rts
000DA5  2               
000DA5  2               ;************************************************
000DA5  2               ; define position of sprite
000DA5  2               ;	Y = sprite index
000DA5  2               ;	r0 = addr of word X & word Y
000DA5  2               ;
000DA5  2               position:
000DA5  2               	; set vram memory on the X sprite
000DA5  2  5A           	phy
000DA6  2  A2 02        	ldx #VSPRITE::x70
000DA8  2  20 D6 0C     	jsr vram
000DAB  2  FA           	plx
000DAC  2               
000DAC  2  A0 01        	ldy #1
000DAE  2  18           	clc
000DAF  2  B2 02        	lda (r0L)				; X low => vera X
000DB1  2  8D 23 9F     	sta veradat
000DB4  2  7D A7 0A     	adc sprites_aabb_x, x	; X + aabb.x => collision box.x
000DB7  2  9D A7 09     	sta sprites_xL, x
000DBA  2  B1 02        	lda (r0L),y				; X high => vera X hight
000DBC  2  8D 23 9F     	sta veradat
000DBF  2  69 00        	adc #00
000DC1  2  9D C7 09     	sta sprites_xH, x		; X + aabbx.x => collision box.x
000DC4  2               
000DC4  2  18           	clc
000DC5  2  BD A7 09     	lda sprites_xL, x
000DC8  2  7D E7 0A     	adc sprites_aabb_w, x
000DCB  2  9D 27 0A     	sta sprites_x1L, x
000DCE  2  BD C7 09     	lda sprites_xH, x
000DD1  2  69 00        	adc #0
000DD3  2  9D 47 0A     	sta sprites_x1H, x		;X1 = x + aabb.x + aabb.w
000DD6  2               
000DD6  2  18           	clc
000DD7  2  C8           	iny
000DD8  2  B1 02        	lda (r0L),y
000DDA  2  8D 23 9F     	sta veradat				; Y low => vera
000DDD  2  7D C7 0A     	adc sprites_aabb_y, x
000DE0  2  9D E7 09     	sta sprites_yL, x		; Y + aabb.y => collision box.y
000DE3  2  C8           	iny
000DE4  2  B1 02        	lda (r0L),y
000DE6  2  8D 23 9F     	sta veradat				; Y heigh  => vera Y high
000DE9  2  69 00        	adc #0
000DEB  2  9D 07 0A     	sta sprites_yH, x		; Y + aabb.y => collision box.y
000DEE  2               
000DEE  2  18           	clc
000DEF  2  BD E7 09     	lda sprites_yL, x
000DF2  2  7D 07 0B     	adc sprites_aabb_h, x
000DF5  2  9D 67 0A     	sta sprites_y1L, x
000DF8  2  BD 07 0A     	lda sprites_yH, x
000DFB  2  69 00        	adc #00
000DFD  2  9D 87 0A     	sta sprites_y1H, x		; Y1 = y + aabb.y + aabb.h
000E00  2               
000E00  2  60           	rts
000E01  2               
000E01  2               ;************************************************
000E01  2               ; Change the flipping of a sprite
000E01  2               ;	Y = sprite index
000E01  2               ;	A = value to set
000E01  2               ;
000E01  2               set_flip:
000E01  2  85 70        	sta SPRITES_ZP
000E03  2  84 71        	sty SPRITES_ZP + 1
000E05  2               
000E05  2               	; set vram memory on the X sprite
000E05  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000E07  2  20 D6 0C     	jsr vram
000E0A  2               
000E0A  2  AD 23 9F     	lda veradat				;get current value
000E0D  2  29 FC        	and #SPRITE_FLIP_CLEAR
000E0F  2  05 70        	ora SPRITES_ZP			; change only the flip value
000E11  2  85 70        	sta SPRITES_ZP
000E13  2               
000E13  2  A4 71        	ldy SPRITES_ZP + 1
000E15  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000E17  2  20 D6 0C     	jsr vram
000E1A  2  A5 70        	lda SPRITES_ZP
000E1C  2  8D 23 9F     	sta veradat
000E1F  2  60           	rts
000E20  2               
000E20  2               ;************************************************
000E20  2               ; register sprites collision
000E20  2               ; input: A = collision mask
000E20  2               ;
000E20  2               register_collision:
000E20  2  EE 68 0C     	inc collisions
000E23  2  8D 69 0C     	sta collisions + 1
000E26  2  60           	rts
000E27  2               
000E27  2               ;************************************************
000E27  2               ; Axis Aligned Bounding Box collision between 2 sprites
000E27  2               ; input: X = index of sprite 1
000E27  2               ;		 Y = index of sprite 2
000E27  2               ; return: Z = no collision
000E27  2               ;
000E27  2               aabb_collision:
000E27  2  BD C7 09     	lda sprites_xH, x
000E2A  2  D9 47 0A     	cmp sprites_x1H, y
000E2D  2  90 02        	bcc :+
000E2F  2  D0 49        	bne @false
000E31  2               :
000E31  2  BD A7 09     	lda sprites_xL, x
000E34  2  D9 27 0A     	cmp sprites_x1L, y
000E37  2  90 02        	bcc :+
000E39  2  D0 3F        	bne @false
000E3B  2               :						; s(x).left_x <= s(y).right_x
000E3B  2               
000E3B  2  B9 C7 09     	lda sprites_xH, y
000E3E  2  DD 47 0A     	cmp sprites_x1H, x
000E41  2  90 02        	bcc :+
000E43  2  D0 35        	bne @false
000E45  2               :
000E45  2  B9 A7 09     	lda sprites_xL, y
000E48  2  DD 27 0A     	cmp sprites_x1L, x
000E4B  2  90 02        	bcc :+
000E4D  2  D0 2B        	bne @false
000E4F  2               :						; AND s(y).left_x <= s(x).right_x
000E4F  2               
000E4F  2  BD 07 0A     	lda sprites_yH, x
000E52  2  D9 87 0A     	cmp sprites_y1H, y
000E55  2  90 02        	bcc :+
000E57  2  D0 21        	bne @false
000E59  2               :
000E59  2  BD E7 09     	lda sprites_yL, x
000E5C  2  D9 67 0A     	cmp sprites_y1L, y
000E5F  2  90 02        	bcc :+
000E61  2  D0 17        	bne @false
000E63  2               :						; AND s(x).bottom_y <= s(y).top_y
000E63  2               
000E63  2  B9 07 0A     	lda sprites_yH, y
000E66  2  DD 87 0A     	cmp sprites_y1H, x
000E69  2  90 02        	bcc :+
000E6B  2  D0 0D        	bne @false
000E6D  2               :
000E6D  2  B9 E7 09     	lda sprites_yL, y
000E70  2  DD 67 0A     	cmp sprites_y1L, x
000E73  2  90 02        	bcc :+
000E75  2  D0 03        	bne @false
000E77  2               :						; AND s(y).bottom_y <= s(x).top_y
000E77  2               
000E77  2               @true:
000E77  2  A9 01        	lda #01
000E79  2  60           	rts
000E7A  2               @false:
000E7A  2  A9 00        	lda #00
000E7C  2  60           	rts
000E7D  2               
000E7D  2               ;************************************************
000E7D  2               ; after a collision IRQ, test all sprites to find colliding ones
000E7D  2               ; return: a = no collision
000E7D  2               ;
000E7D  2               find_colliding:
000E7D  2  AD 67 0C     	lda nb_sprites
000E80  2  3A           	dec
000E81  2  85 70        	sta SPRITES_ZP
000E83  2  3A           	dec
000E84  2  85 71        	sta SPRITES_ZP + 1
000E86  2               
000E86  2               @inner_loop:
000E86  2  A6 70        	ldx SPRITES_ZP
000E88  2  A4 71        	ldy SPRITES_ZP + 1
000E8A  2  20 27 0E     	jsr aabb_collision
000E8D  2  D0 15        	bne @found
000E8F  2               
000E8F  2  C6 71        	dec SPRITES_ZP + 1
000E91  2  30 02        	bmi @try_next
000E93  2  80 F1        	bra @inner_loop
000E95  2               
000E95  2               @try_next:
000E95  2  A5 70        	lda SPRITES_ZP
000E97  2  3A           	dec
000E98  2  F0 07        	beq @not_found
000E9A  2  85 70        	sta SPRITES_ZP			; start comparison end - 1
000E9C  2  3A           	dec						; compare with start - 1 unless < 0
000E9D  2  85 71        	sta SPRITES_ZP + 1
000E9F  2  80 E5        	bra @inner_loop
000EA1  2               
000EA1  2               @not_found:
000EA1  2  A9 00        	lda #00
000EA3  2  60           	rts
000EA4  2               @found:
000EA4  2  A9 01        	lda #01
000EA6  2  60           	rts
000EA7  2               
000EA7  2               ;************************************************
000EA7  2               ; manage collisions after a collision IRQ
000EA7  2               ;
000EA7  2               check_irq_collision:
000EA7  2  AD 68 0C     	lda collisions
000EAA  2  F0 06        	beq @return
000EAC  2               
000EAC  2  9C 68 0C     	stz collisions		; clear the collision flag
000EAF  2               
000EAF  2  20 7D 0E     	jsr find_colliding
000EB2  2               
000EB2  2               @return:
000EB2  2  60           	rts
000EB3  2               
000EB3  2               ;************************************************
000EB3  2               ; check if sprite X collides with any of the others
000EB3  2               ; input : X = sprite index to test
000EB3  2               ; return: a = index of sprite in collision or $FF if no collision
000EB3  2               ;
000EB3  2               check_collision:
000EB3  2  86 70        	stx SPRITES_ZP
000EB5  2  AD 67 0C     	lda nb_sprites
000EB8  2  3A           	dec
000EB9  2  F0 11        	beq @no_collision		; if there is only 1 sprite, no_collision
000EBB  2  A8           	tay						; start with the last sprite
000EBC  2               @loop:
000EBC  2  C4 70        	cpy SPRITES_ZP
000EBE  2  F0 05        	beq @next				; ignore the input sprite
000EC0  2  20 27 0E     	jsr aabb_collision
000EC3  2  D0 05        	bne @collision
000EC5  2               @next:
000EC5  2  88           	dey
000EC6  2  30 04        	bmi @no_collision		; 0 has to be taked care off
000EC8  2  80 F2        	bra @loop
000ECA  2               
000ECA  2               @collision:
000ECA  2  98           	tya						; store index of the colliding sprite
000ECB  2  60           	rts
000ECC  2               
000ECC  2               @no_collision:
000ECC  2  A9 FF        	lda #$ff
000ECE  2  60           	rts
000ECF  2               
000ECF  2               ;************************************************
000ECF  2               ; simulate a sprite movement and check collision
000ECF  2               ;	input A = vertical (1) / horizontal (2)
000ECF  2               ;			  plus (4) / minus (8)
000ECF  2               ;		  X = sprite index
000ECF  2               ; 	return: a = index of colliding sprite, $ff if no collision
000ECF  2               ;
000ECF  2               precheck_collision:
000ECF  2  85 72        	sta SPRITES_ZP + 2
000ED1  2  86 73        	stx SPRITES_ZP + 3
000ED3  2               
000ED3  2  89 01        	bit #01
000ED5  2  D0 5D        	bne @vertical
000ED7  2  89 08        	bit #08
000ED9  2  D0 2D        	bne @horizontal_minus
000EDB  2               
000EDB  2               @horizontal_plus:
000EDB  2               	; save current X, X1 and add the delta
000EDB  2  18           	clc
000EDC  2  BD A7 09     	lda sprites_xL, x
000EDF  2  85 75        	sta SPRITES_ZP + 5
000EE1  2  69 01        	adc #01
000EE3  2  9D A7 09     	sta sprites_xL, x
000EE6  2               
000EE6  2  BD C7 09     	lda sprites_xH, x
000EE9  2  85 76        	sta SPRITES_ZP + 6
000EEB  2  69 00        	adc #00
000EED  2  9D C7 09     	sta sprites_xH, x
000EF0  2               @horizontal_plus_width:
000EF0  2  18           	clc
000EF1  2  BD 27 0A     	lda sprites_x1L, x
000EF4  2  85 77        	sta SPRITES_ZP + 7
000EF6  2  69 01        	adc #01
000EF8  2  9D 27 0A     	sta sprites_x1L, x
000EFB  2               
000EFB  2  BD 47 0A     	lda sprites_x1H, x
000EFE  2  85 78        	sta SPRITES_ZP + 8
000F00  2  69 00        	adc #00
000F02  2  9D 47 0A     	sta sprites_x1H, x
000F05  2  4C 8E 0F     	jmp @test
000F08  2               
000F08  2               @horizontal_minus:
000F08  2  38           	sec
000F09  2  BD A7 09     	lda sprites_xL, x
000F0C  2  85 75        	sta SPRITES_ZP + 5
000F0E  2  E9 01        	sbc #01
000F10  2  9D A7 09     	sta sprites_xL, x
000F13  2               
000F13  2  BD C7 09     	lda sprites_xH, x
000F16  2  85 76        	sta SPRITES_ZP + 6
000F18  2  E9 00        	sbc #00
000F1A  2  9D C7 09     	sta sprites_xH, x
000F1D  2               @horizontal_minus_width:
000F1D  2  38           	sec
000F1E  2  BD 27 0A     	lda sprites_x1L, x
000F21  2  85 77        	sta SPRITES_ZP + 7
000F23  2  E9 01        	sbc #01
000F25  2  9D 27 0A     	sta sprites_x1L, x
000F28  2               
000F28  2  BD 47 0A     	lda sprites_x1H, x
000F2B  2  85 78        	sta SPRITES_ZP + 8
000F2D  2  E9 00        	sbc #00
000F2F  2  9D 47 0A     	sta sprites_x1H, x
000F32  2  80 5A        	bra @test
000F34  2               
000F34  2               @vertical:
000F34  2  89 08        	bit #08
000F36  2  D0 2C        	bne @vertical_minus
000F38  2               @vertical_plus:
000F38  2               	; save current Y, Y1 and add delta
000F38  2  18           	clc
000F39  2  BD E7 09     	lda sprites_yL, x
000F3C  2  85 75        	sta SPRITES_ZP + 5
000F3E  2  69 01        	adc #01
000F40  2  9D E7 09     	sta sprites_yL, x
000F43  2               
000F43  2  BD 07 0A     	lda sprites_yH, x
000F46  2  85 76        	sta SPRITES_ZP + 6
000F48  2  69 00        	adc #00
000F4A  2  9D 07 0A     	sta sprites_yH, x
000F4D  2               
000F4D  2  18           	clc
000F4E  2  BD 67 0A     	lda sprites_y1L, x
000F51  2  85 77        	sta SPRITES_ZP + 7
000F53  2  69 01        	adc #01
000F55  2  9D 67 0A     	sta sprites_y1L, x
000F58  2               
000F58  2  BD 87 0A     	lda sprites_y1H, x
000F5B  2  85 78        	sta SPRITES_ZP + 8
000F5D  2  69 00        	adc #00
000F5F  2  9D 87 0A     	sta sprites_y1H, x
000F62  2  80 2A        	bra @test
000F64  2               @vertical_minus:
000F64  2               	; save current Y, Y1 and add delta
000F64  2  38           	sec
000F65  2  BD E7 09     	lda sprites_yL, x
000F68  2  85 75        	sta SPRITES_ZP + 5
000F6A  2  E9 01        	sbc #01
000F6C  2  9D E7 09     	sta sprites_yL, x
000F6F  2               
000F6F  2  BD 07 0A     	lda sprites_yH, x
000F72  2  85 76        	sta SPRITES_ZP + 6
000F74  2  E9 00        	sbc #00
000F76  2  9D 07 0A     	sta sprites_yH, x
000F79  2               
000F79  2  38           	sec
000F7A  2  BD 67 0A     	lda sprites_y1L, x
000F7D  2  85 77        	sta SPRITES_ZP + 7
000F7F  2  69 01        	adc #01
000F81  2  9D 67 0A     	sta sprites_y1L, x
000F84  2               
000F84  2  BD 87 0A     	lda sprites_y1H, x
000F87  2  85 78        	sta SPRITES_ZP + 8
000F89  2  E9 00        	sbc #00
000F8B  2  9D 87 0A     	sta sprites_y1H, x
000F8E  2               
000F8E  2               @test:
000F8E  2  20 B3 0E     	jsr check_collision
000F91  2  85 74        	sta SPRITES_ZP + 4		; save the result
000F93  2               
000F93  2               @restore:
000F93  2               	; and restore the data
000F93  2  A6 73        	ldx SPRITES_ZP + 3
000F95  2  A5 72        	lda SPRITES_ZP + 2
000F97  2  89 02        	bit #02
000F99  2  F0 16        	beq @vertical_restore
000F9B  2               @horizontal_restore:
000F9B  2  A5 75        	lda SPRITES_ZP + 5
000F9D  2  9D A7 09     	sta sprites_xL, x
000FA0  2  A5 76        	lda SPRITES_ZP + 6
000FA2  2  9D C7 09     	sta sprites_xH, x
000FA5  2  A5 77        	lda SPRITES_ZP + 7
000FA7  2  9D 27 0A     	sta sprites_x1L, x
000FAA  2  A5 78        	lda SPRITES_ZP + 8
000FAC  2  9D C7 09     	sta sprites_xH, x
000FAF  2  80 14        	bra @return
000FB1  2               
000FB1  2               @vertical_restore:
000FB1  2  A5 75        	lda SPRITES_ZP + 5
000FB3  2  9D E7 09     	sta sprites_yL, x
000FB6  2  A5 76        	lda SPRITES_ZP + 6
000FB8  2  9D 07 0A     	sta sprites_yH, x
000FBB  2  A5 77        	lda SPRITES_ZP + 7
000FBD  2  9D 67 0A     	sta sprites_y1L, x
000FC0  2  A5 78        	lda SPRITES_ZP + 8
000FC2  2  9D 07 0A     	sta sprites_yH, x
000FC5  2               
000FC5  2               @return:
000FC5  2  A5 74        	lda SPRITES_ZP + 4	; result of the collision
000FC7  2  60           	rts
000FC8  2               
000FC8  2               .endscope
000FC8  2               
000FC8  1               .include "entities.asm"
000FC8  2               ;-----------------------------------------------------------------------------
000FC8  2               ;/////////////////////////////////////////////////////////////////////////////
000FC8  2               ;           start ENTITY code
000FC8  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000FC8  2               ;-----------------------------------------------------------------------------
000FC8  2               
000FC8  2               .struct Entity
000FC8  2                   spriteID    .byte   ; ID of the vera sprite
000FC8  2               	status		.byte	; status of the player : IDLE, WALKING, CLIMBING, FALLING
000FC8  2                   levelx      .word   ; level position
000FC8  2                   levely      .word
000FC8  2                   px          .word   ; screen position
000FC8  2                   py          .word
000FC8  2               	falling_ticks .word	; ticks since the player is falling (thing t in gravity)
000FC8  2               	delta_x		.byte	; when driving by phisics, original delta_x value
000FC8  2               	collision_addr	.word	; cached @ of the collision equivalent of the center of the player
000FC8  2               .endstruct
000FC8  2               
000FC8  2               .scope Entities
000FC8  2               
000FC8  2               ;************************************************
000FC8  2               ; init all attributes of an entity
000FC8  2               ;   input: R3 = start of the object
000FC8  2               ;
000FC8  2               init:
000FC8  2  A9 00            lda #00
000FCA  2  A0 00            ldy #Entity::spriteID
000FCC  2  91 08        	sta (r3), y
000FCE  2  A0 01            ldy #Entity::status
000FD0  2  A9 00        	lda #STATUS_WALKING_IDLE
000FD2  2  91 08        	sta (r3), y
000FD4  2  A9 00            lda #00
000FD6  2  A0 0A            ldy #Entity::falling_ticks
000FD8  2  91 08        	sta (r3),y
000FDA  2  C8               iny
000FDB  2  91 08        	sta (r3),y
000FDD  2  A0 06            ldy #Entity::px
000FDF  2  91 08        	sta (r3),y
000FE1  2  C8               iny
000FE2  2  91 08        	sta (r3),y
000FE4  2  A0 08            ldy #Entity::py
000FE6  2  91 08        	sta (r3),y
000FE8  2  C8               iny
000FE9  2  91 08        	sta (r3),y
000FEB  2  A0 02            ldy #Entity::levelx
000FED  2  91 08        	sta (r3),y
000FEF  2  C8               iny
000FF0  2  91 08        	sta (r3),y
000FF2  2  A0 04            ldy #Entity::levely
000FF4  2  91 08        	sta (r3),y
000FF6  2  C8               iny
000FF7  2  91 08        	sta (r3),y
000FF9  2  60               rts
000FFA  2               
000FFA  2               ;************************************************
000FFA  2               ; change  position of the sprite (level view) => (screen view)
000FFA  2               ;   input: R3 = start of the object
000FFA  2               ;
000FFA  2               set_position:
000FFA  2                   ; screenX = levelX - layer1_scroll_x
000FFA  2  A0 02            ldy #(Entity::levelx)
000FFC  2  38               sec
000FFD  2  B1 08            lda (r3), y
000FFF  2  ED 37 9F         sbc VERA_L1_hscrolllo
001002  2  85 02            sta r0L
001004  2  C8               iny
001005  2  B1 08            lda (r3), y
001007  2  ED 38 9F         sbc VERA_L1_hscrolllo + 1
00100A  2  85 03            sta r0H
00100C  2               
00100C  2                   ; screenY = levelY - layer1_scroll_y
00100C  2  A0 04            ldy #(Entity::levely)
00100E  2  38               sec
00100F  2  B1 08            lda (r3), y
001011  2  ED 39 9F         sbc VERA_L1_vscrolllo
001014  2  85 04            sta r1L
001016  2  C8               iny
001017  2  B1 08            lda (r3), y
001019  2  ED 3A 9F         sbc VERA_L1_vscrolllo + 1
00101C  2  85 05            sta r1H
00101E  2               
00101E  2                   ; save the screen positions in the object
00101E  2  A0 06            ldy #(Entity::px)
001020  2  A5 02            lda r0L
001022  2  91 08            sta (r3), y
001024  2  C8               iny
001025  2  A5 03            lda r0H
001027  2  91 08            sta (r3), y
001029  2               
001029  2  A0 08            ldy #(Entity::py)
00102B  2  A5 04            lda r1L
00102D  2  91 08            sta (r3), y
00102F  2  C8               iny
001030  2  A5 05            lda r1H
001032  2  91 08            sta (r3), y
001034  2               
001034  2                   ; get the sprite ID
001034  2  B2 08        	lda (r3)                        ; sprite id
001036  2  A8               tay
001037  2               
001037  2                   ; adresse of the and px, py attributes
001037  2  18               clc
001038  2  A5 08            lda r3L
00103A  2  69 06            adc #(Entity::px)
00103C  2  85 02            sta r0L
00103E  2  A5 09            lda r3H
001040  2  69 00            adc #00
001042  2  85 03            sta r0H
001044  2  20 A5 0D     	jsr Sprite::position			; set position of the sprite
001047  2               
001047  2  60               rts
001048  2               
001048  2               ;************************************************
001048  2               ; increase entity X position
001048  2               ;   input: R3 = start of the object
001048  2               ;
001048  2               position_x_inc:
001048  2               	; move the absolute position levelx + 1
001048  2  A0 02        	ldy #Entity::levelx
00104A  2  B1 08            lda (r3),y
00104C  2  1A               inc
00104D  2  91 08            sta (r3),y
00104F  2  D0 06            bne :+
001051  2  C8               iny
001052  2  B1 08            lda (r3),y
001054  2  1A               inc
001055  2  91 08            sta (r3),y
001057  2               :
001057  2               
001057  2  A0 06        	ldy #Entity::px
001059  2  B1 08            lda (r3),y
00105B  2  1A               inc
00105C  2  91 08            sta (r3),y
00105E  2  D0 06            bne :+
001060  2  C8               iny
001061  2  B1 08        	lda (r3),y
001063  2  1A           	inc
001064  2  91 08        	sta (r3),y
001066  2               :
001066  2  60           	rts
001067  2               
001067  2               ;************************************************
001067  2               ; decrease entity X position
001067  2               ;   input: R3 = start of the object
001067  2               ;
001067  2               position_x_dec:
001067  2  A0 02        	ldy #Entity::levelx
001069  2  B1 08            lda (r3),y
00106B  2  3A               dec
00106C  2  91 08            sta (r3),y
00106E  2  C9 FF            cmp #$ff
001070  2  D0 06            bne :+
001072  2  C8               iny
001073  2  B1 08            lda (r3),y
001075  2  3A               dec
001076  2  91 08            sta (r3),y
001078  2               :
001078  2               
001078  2  A0 06        	ldy #Entity::px
00107A  2  B1 08            lda (r3),y
00107C  2  3A               dec
00107D  2  91 08            sta (r3),y
00107F  2  C9 FF            cmp #$ff
001081  2  D0 06            bne :+
001083  2  C8               iny
001084  2  B1 08        	lda (r3),y
001086  2  3A           	dec
001087  2  91 08        	sta (r3),y
001089  2               :
001089  2  60           	rts
00108A  2               
00108A  2               ;************************************************
00108A  2               ; increase entity Y position
00108A  2               ;   input: R3 = start of the object
00108A  2               ;
00108A  2               position_y_inc:
00108A  2               	; move the absolute position levelx + 1
00108A  2  A0 04        	ldy #Entity::levely
00108C  2  B1 08            lda (r3),y
00108E  2  1A               inc
00108F  2  91 08            sta (r3),y
001091  2  D0 06            bne :+
001093  2  C8               iny
001094  2  B1 08            lda (r3),y
001096  2  1A               inc
001097  2  91 08            sta (r3),y
001099  2               :
001099  2               
001099  2  A0 08        	ldy #Entity::py
00109B  2  B1 08            lda (r3),y
00109D  2  1A               inc
00109E  2  91 08            sta (r3),y
0010A0  2  D0 06            bne :+
0010A2  2  C8               iny
0010A3  2  B1 08        	lda (r3),y
0010A5  2  1A           	inc
0010A6  2  91 08        	sta (r3),y
0010A8  2               :
0010A8  2  60           	rts
0010A9  2               
0010A9  2               ;************************************************
0010A9  2               ; decrease entity X position
0010A9  2               ;   input: R3 = start of the object
0010A9  2               ;
0010A9  2               position_y_dec:
0010A9  2  A0 04        	ldy #Entity::levely
0010AB  2  B1 08            lda (r3),y
0010AD  2  3A               dec
0010AE  2  91 08            sta (r3),y
0010B0  2  C9 FF            cmp #$ff
0010B2  2  D0 06            bne :+
0010B4  2  C8               iny
0010B5  2  B1 08            lda (r3),y
0010B7  2  3A               dec
0010B8  2  91 08            sta (r3),y
0010BA  2               :
0010BA  2               
0010BA  2  A0 08        	ldy #Entity::py
0010BC  2  B1 08            lda (r3),y
0010BE  2  3A               dec
0010BF  2  91 08            sta (r3),y
0010C1  2  C9 FF            cmp #$ff
0010C3  2  D0 06            bne :+
0010C5  2  C8               iny
0010C6  2  B1 08        	lda (r3),y
0010C8  2  3A           	dec
0010C9  2  91 08        	sta (r3),y
0010CB  2               :
0010CB  2  60           	rts
0010CC  2               
0010CC  2               .endscope
0010CC  2               
0010CC  1               .include "objects.asm"
0010CC  2               ;-----------------------------------------------------------------------------
0010CC  2               ;/////////////////////////////////////////////////////////////////////////////
0010CC  2               ;           start OBJECT code
0010CC  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
0010CC  2               ;-----------------------------------------------------------------------------
0010CC  2               
0010CC  2               .scope Objects
0010CC  2               
0010CC  2               OBJECT_ZP = $0060	    ; memory reserved for objects
0010CC  2               
0010CC  2  00 00        objects_map: .word 0
0010CE  2  00 00        objects_sprites: .word 0    ; vera memory of the start of the sprites
0010D0  2               
0010D0  2               .enum Attribute
0010D0  2                   GRAB = 1
0010D0  2               .endenum
0010D0  2               
0010D0  2               .struct Object
0010D0  2               	entity		.tag Entity
0010D0  2                   imageID     .byte   ; ID of the image in the spritesheet
0010D0  2                   attribute   .byte
0010D0  2               .endstruct
0010D0  2               
0010D0  2               ;************************************************
0010D0  2               ; init the object data of the level
0010D0  2               ;
0010D0  2               init:
0010D0  2                   ; load the list of objects at the end of the previous load
0010D0  2  AD 10 08         lda current_load
0010D3  2  8D CC 10         sta objects_map
0010D6  2  AD 11 08         lda current_load + 1
0010D9  2  8D CD 10         sta objects_map + 1
0010DC  2  A9 01 A2 08  	LOAD_FILE_NEXT fsobjects, (fsobjects_end-fsobjects)
0010E0  2  A0 00 20 BA  
0010E4  2  FF A9 0B A2  
0010FF  2               
0010FF  2                   ; load the sprites  of objects at the end of the previous vload
0010FF  2  AD 12 08         lda Vera::vram_load
001102  2  8D CE 10         sta objects_sprites
001105  2  AD 13 08         lda Vera::vram_load + 1
001108  2  8D CF 10         sta objects_sprites + 1
00110B  2  A9 01 A2 08  	VLOAD_FILE_NEXT fssprites1, (fssprites1_end-fssprites1)
00110F  2  A0 00 20 BA  
001113  2  FF A9 0C A2  
00112E  2               
00112E  2                   ; add each available sprites on screen
00112E  2  AD CC 10         lda objects_map
001131  2  85 08            sta r3L
001133  2  AD CD 10         lda objects_map + 1
001136  2  85 09            sta r3H
001138  2               
001138  2  B2 08            lda (r3)
00113A  2  85 31            sta $31     ; number of objects
00113C  2  64 32            stz $32     ; object #0
00113E  2               
00113E  2  E6 08            inc r3L
001140  2               
001140  2               @loop:
001140  2                   ; get a free sprite
001140  2  20 BE 0C         jsr Sprite::new
001143  2  8A               txa
001144  2  92 08            sta (r3)
001146  2               
001146  2                   ; load the first object
001146  2  AD CE 10     	lda objects_sprites
001149  2  85 02        	sta r0L
00114B  2  AD CF 10     	lda objects_sprites + 1
00114E  2  85 03        	sta r0H
001150  2  20 58 0D         jsr Sprite::vram_to_16_5
001153  2  A5 04            lda r1L
001155  2  85 02            sta r0L
001157  2  A5 05            lda r1H
001159  2  85 03            sta r0H
00115B  2               
00115B  2  B2 08        	lda (r3)                        ; sprite id
00115D  2  A8               tay
00115E  2  A9 10           	lda #%00010000					; collision mask 1
001160  2  A2 50           	ldx #%01010000					; 16x16 sprite
001162  2  20 FB 0C     	jsr Sprite::load
001165  2               
001165  2                   ; display the object
001165  2  B2 08        	lda (r3)                        ; sprite id
001167  2  A8               tay
001168  2  A2 0C        	ldx #SPRITE_ZDEPTH_TOP
00116A  2  20 86 0D     	jsr Sprite::display
00116D  2               
00116D  2                   ; position the first object
00116D  2  20 FA 0F         jsr Entities::set_position
001170  2               
001170  2                   ; last object ?
001170  2  C6 31            dec $31
001172  2  F0 11            beq @return
001174  2               
001174  2                   ; move to the next object
001174  2  18               clc
001175  2  A5 08            lda r3L
001177  2  69 11            adc #.sizeof(Object)
001179  2  85 08            sta r3L
00117B  2  A5 09            lda r3H
00117D  2  69 00            adc #00
00117F  2  85 09            sta r3H
001181  2               
001181  2  E6 32            inc $32                     ; object #next
001183  2  80 BB            bra @loop
001185  2               
001185  2               @return:
001185  2  60               rts
001186  2               
001186  2               ;************************************************
001186  2               ; change  position of the sprite (level view) => (screen view)
001186  2               ;   input: X = index of the object
001186  2               ;   output: r3 = pointer to the object
001186  2               ;
001186  2               set_position_index:
001186  2  AD CC 10         lda objects_map
001189  2  85 08            sta r3L
00118B  2  AD CD 10         lda objects_map + 1
00118E  2  85 09            sta r3H
001190  2  E6 08            inc r3L
001192  2               
001192  2  E0 00            cpx #00                 ; ignore object 0
001194  2  F0 10            beq @next
001196  2               
001196  2               @mult:
001196  2  18               clc
001197  2  A5 08            lda r3L
001199  2  69 11            adc #.sizeof(Object)
00119B  2  85 08            sta r3L
00119D  2  A5 09            lda r3H
00119F  2  69 00            adc #00
0011A1  2  85 09            sta r3H
0011A3  2  CA               dex
0011A4  2  D0 F0            bne @mult               ; r2 = objects_map + X*sizeof(Object)
0011A6  2               
0011A6  2               @next:
0011A6  2               
0011A6  2               ;************************************************
0011A6  2               ; change position of all sprites when the layer moves (level view) => (screen view)
0011A6  2               ;
0011A6  2               fix_positions:
0011A6  2  AD CC 10         lda objects_map
0011A9  2  85 08            sta r3L
0011AB  2  AD CD 10         lda objects_map + 1
0011AE  2  85 09            sta r3H
0011B0  2               
0011B0  2  B2 08            lda (r3)
0011B2  2  85 31            sta $31     ; number of objects
0011B4  2  64 32            stz $32
0011B6  2  E6 08            inc r3L
0011B8  2               
0011B8  2               @loop:
0011B8  2                   ; position the first object
0011B8  2  20 FA 0F         jsr Entities::set_position
0011BB  2               
0011BB  2                   ; last object ?
0011BB  2  E6 32            inc $32
0011BD  2  C6 31            dec $31
0011BF  2  F0 0F            beq @return
0011C1  2               
0011C1  2                   ; move to the next object
0011C1  2  18               clc
0011C2  2  A5 08            lda r3L
0011C4  2  69 11            adc #.sizeof(Object)
0011C6  2  85 08            sta r3L
0011C8  2  A5 09            lda r3H
0011CA  2  69 00            adc #00
0011CC  2  85 09            sta r3H
0011CE  2               
0011CE  2  80 E8            bra @loop
0011D0  2               
0011D0  2               @return:
0011D0  2  60               rts
0011D1  2               
0011D1  2               ;************************************************
0011D1  2               ; find the object with a sprite ID
0011D1  2               ;   input: A = spriteID
0011D1  2               ;   output: (r3) start of the address of the objects
0011D1  2               ;           Y = memory index of the start of the object, $FF if no object
0011D1  2               ;
0011D1  2               get_by_spriteID:
0011D1  2  85 60            sta OBJECT_ZP
0011D3  2               
0011D3  2  AD CC 10         lda objects_map
0011D6  2  85 08            sta r3L
0011D8  2  AD CD 10         lda objects_map + 1
0011DB  2  85 09            sta r3H
0011DD  2               
0011DD  2  B2 08            lda (r3)            ; number of objects
0011DF  2  AA               tax
0011E0  2  E6 08            inc r3L             ; move to the first object
0011E2  2               
0011E2  2  A0 00            ldy #00
0011E4  2               @loop:
0011E4  2  B1 08            lda (r3), y
0011E6  2  C5 60            cmp OBJECT_ZP
0011E8  2  F0 0A            beq @found
0011EA  2               
0011EA  2                   ; last object ?
0011EA  2  CA               dex
0011EB  2  F0 08            beq @no_object
0011ED  2               
0011ED  2                   ; move to the next object
0011ED  2  98               tya
0011EE  2  18               clc
0011EF  2  69 11            adc #.sizeof(Object)
0011F1  2  A8               tay
0011F2  2  80 F0            bra @loop
0011F4  2               
0011F4  2               @found:
0011F4  2  60               rts
0011F5  2               
0011F5  2               @no_object:
0011F5  2  A0 FF            ldy #$ff
0011F7  2  60               rts
0011F8  2               
0011F8  2               .endscope
0011F8  2               
0011F8  1               .include "layers.asm"
0011F8  2               ;-----------------------------------------------------------------------------
0011F8  2               ;/////////////////////////////////////////////////////////////////////////////
0011F8  2               ; START Layers code
0011F8  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
0011F8  2               ;-----------------------------------------------------------------------------
0011F8  2               
0011F8  2               .scope Layers
0011F8  2               
0011F8  2               HSCROLL = 0
0011F8  2               VSCROLL = 2
0011F8  2               
0011F8  2               ;************************************************
0011F8  2               ; increase layer scrolling with a 8bits limit
0011F8  2               ;	X: : 0 = horizontal
0011F8  2               ;	   : 2 = vertical
0011F8  2               ;	Y: limit
0011F8  2               ;
0011F8  2               scroll_inc_8:
0011F8  2  84 02        	sty r0L
0011FA  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
0011FD  2  C5 02        	cmp r0L
0011FF  2  F0 0F        	beq @noscroll
001201  2               @scrollinc:
001201  2  1A           	inc
001202  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
001205  2  D0 03        	bne @scrolled
001207  2  FE 38 9F     	inc VERA_L1_hscrollhi, x
00120A  2               @scrolled:
00120A  2               	; fix the objects position now that the layers scrolled
00120A  2  20 A6 11     	jsr Objects::fix_positions
00120D  2  A9 01        	lda #01		; clear ZERO => scrolled
00120F  2  60           	rts
001210  2               @noscroll:
001210  2  A9 00        	lda #00		; set ZERO => noscroll
001212  2  60           	rts
001213  2               
001213  2               ;************************************************
001213  2               ; increase layer scrolling with a 16bits limit
001213  2               ;	X: : 0 = horizontal
001213  2               ;	   : 2 = vertical
001213  2               ;	r0L: limit
001213  2               ;
001213  2               scroll_inc_16:
001213  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
001216  2  C5 02        	cmp r0L
001218  2  D0 09        	bne @scrollinc								; if low bits are not equals to the limit low bits => safe to increase
00121A  2  A8           	tay
00121B  2  BD 38 9F     	lda VERA_L1_hscrollhi, x
00121E  2  C5 03        	cmp r0H
001220  2  F0 10        	beq @noscroll								; if high bits are equals to the limit high bits => we reached the limit
001222  2  98           	tya
001223  2               @scrollinc:
001223  2  1A           	inc
001224  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
001227  2  D0 03        	bne @scrolled
001229  2  FE 38 9F     	inc VERA_L1_hscrollhi, x
00122C  2               @scrolled:
00122C  2               	; fix the objects position now that the layers scrolled
00122C  2  20 A6 11     	jsr Objects::fix_positions
00122F  2  A9 01        	lda #01	; clear ZERO => scrolled
001231  2  60           	rts
001232  2               @noscroll:
001232  2  A9 00        	lda #00	; set ZERO => noscroll
001234  2  60           	rts
001235  2               
001235  2               ; increase a layer scroll offset but do NOT overlap
001235  2               .macro VSCROLL_INC direction,limit
001235  2               .if limit > 255
001235  2               	LOAD_r0 limit
001235  2               	ldx #direction
001235  2               	jsr Layers::scroll_inc_16
001235  2               .else
001235  2               	ldy #limit
001235  2               	ldx #direction
001235  2               	jsr Layers::scroll_inc_8
001235  2               .endif
001235  2               .endmacro
001235  2               
001235  2               ;
001235  2               ;
001235  2               ; decrease a layer scroll offset
001235  2               ;	X : 0 = horizontal
001235  2               ;	  : 2 = vertical
001235  2               ;
001235  2               scroll_dec:
001235  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
001238  2  F0 06        	beq @scrollHI			; 00 => decrease high bits
00123A  2  3A           	dec
00123B  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
00123E  2  80 0E        	bra @scrolled
001240  2               @scrollHI:
001240  2  BC 38 9F     	ldy VERA_L1_hscrollhi, x
001243  2  F0 0F        	beq @noscroll		; 0000 => no scrolling
001245  2  3A           	dec
001246  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
001249  2  88           	dey
00124A  2  98           	tya
00124B  2  9D 38 9F     	sta VERA_L1_hscrollhi, x
00124E  2               
00124E  2               @scrolled:
00124E  2               	; fix the objects position now that the layers scrolled
00124E  2  20 A6 11     	jsr Objects::fix_positions
001251  2  A9 01        	lda #01		; clear ZERO => scrolled
001253  2  60           	rts
001254  2               
001254  2               @noscroll:
001254  2  A9 00        	lda #00		; set ZERO => noscroll
001256  2  60           	rts
001257  2               
001257  2               ;
001257  2               ; force layer0 scrolling to be half of the layer1 scrolling
001257  2               ;
001257  2               scroll_l0:
001257  2  BD 38 9F     	lda VERA_L1_hscrollhi, x	; layer0 hScroll is layer 1 / 2
00125A  2  4A           	lsr
00125B  2  9D 31 9F     	sta VERA_L0_hscrollhi, x
00125E  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
001261  2  6A           	ror
001262  2  9D 30 9F     	sta VERA_L0_hscrolllo, x
001265  2  60           	rts
001266  2               .endscope
001266  2               
001266  1               .include "tilemap.asm"
001266  2               ;-----------------------------------------------------------------------------
001266  2               ;/////////////////////////////////////////////////////////////////////////////
001266  2               ; START Tilemap code
001266  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
001266  2               ;-----------------------------------------------------------------------------
001266  2               
001266  2               .scope Tilemap
001266  2               
001266  2               COLLISION_MAP = HIMEM
001266  2               
001266  2               ;************************************************
001266  2               ; load the layers and the collision map
001266  2               ;
001266  2               load:
001266  2               	; load tilemap into layer 0
001266  2  AD 2D 9F 29  	VCONFIG_TILES 0,VERA_CONFIG_32x32
00126A  2  0F 09 00 8D  
00126E  2  2D 9F        
001270  2  AD 2D 9F 29  	VCONFIG_DEPTH 0,VERA_CONFIG_8BPP
001274  2  0F 09 03 8D  
001278  2  2D 9F        
00127A  2  A9 00 8D 2E  	VMAPBASE 0, VRAM_layer0_map
00127E  2  9F           
00127F  2  A9 01 A2 08  	VLOAD_FILE fsbackground, (fsbackground_end-fsbackground), VRAM_layer0_map
001283  2  A0 00 20 BA  
001287  2  FF A9 0B A2  
0012A0  2               
0012A0  2               	; load tilemap into layer 1
0012A0  2  AD 34 9F 29  	VCONFIG_TILES 1,VERA_CONFIG_32x32
0012A4  2  0F 09 00 8D  
0012A8  2  34 9F        
0012AA  2  AD 34 9F 29  	VCONFIG_DEPTH 1,VERA_CONFIG_8BPP
0012AE  2  0F 09 03 8D  
0012B2  2  34 9F        
0012B4  2  A9 04 8D 35  	VMAPBASE 1, VRAM_layer1_map
0012B8  2  9F           
0012B9  2  A9 01 A2 08  	VLOAD_FILE fslevel, (fslevel_end-fslevel), VRAM_layer1_map
0012BD  2  A0 00 20 BA  
0012C1  2  FF A9 09 A2  
0012DA  2               
0012DA  2               	; load collisionmap into ram
0012DA  2  A9 00        	lda #0
0012DC  2  85 00        	sta $00
0012DE  2  A9 01 A2 08  	LOAD_FILE fscollision, (fscollision_end-fscollision), COLLISION_MAP
0012E2  2  A0 00 20 BA  
0012E6  2  FF A9 0D A2  
0012FF  2               
0012FF  2               
0012FF  2  60               rts
001300  2               
001300  2               ;************************************************
001300  2               ; convert (x,y) position into a collision memory address
001300  2               ;	input: r0  = X
001300  2               ;            r1 = Y
001300  2               ;	output : r0
001300  2               ;
001300  2               get_collision_addr:
001300  2  A5 02        	lda r0L
001302  2  29 F0        	and #%11110000
001304  2  0A           	asl
001305  2  26 03        	rol r0H
001307  2  85 02        	sta r0L 					; r0 = first tile of the tilemap in the row
001309  2               								; spriteY / 16 (convert to tile Y) * 32 (number of tiles per row in the tile map)
001309  2               
001309  2  A5 05            lda r1H
00130B  2  4A           	lsr
00130C  2  66 04        	ror r1L
00130E  2  4A           	lsr
00130F  2  66 04        	ror r1L
001311  2  4A           	lsr
001312  2  66 04        	ror r1L
001314  2  4A           	lsr
001315  2  66 04        	ror r1L
001317  2  85 05        	sta r1H 					; r1 = tile X in the row
001319  2               								; sprite X /16 (convert to tile X)
001319  2               
001319  2  18           	clc
00131A  2  A5 02        	lda r0L
00131C  2  65 04        	adc r1L
00131E  2  85 02        	sta r0L
001320  2  A5 03        	lda r0H
001322  2  65 05        	adc r1H
001324  2  85 03        	sta r0H						; r0 = tile position in the tilemap
001326  2               
001326  2  18           	clc
001327  2  A5 02        	lda r0L
001329  2  69 00        	adc #<COLLISION_MAP
00132B  2  85 02        	sta r0L						; r0 = tile position in the memory tilemap
00132D  2  A5 03        	lda r0H
00132F  2  69 A0        	adc #>COLLISION_MAP
001331  2  85 03        	sta r0H						; r0 = tile position in the memory tilemap
001333  2  60           	rts
001334  2               
001334  2               .endscope
001334  2               
001334  1               .include "player.asm"
001334  2               ;-----------------------------------------------------------------------------
001334  2               ;/////////////////////////////////////////////////////////////////////////////
001334  2               ; START player code
001334  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
001334  2               ;-----------------------------------------------------------------------------
001334  2               
001334  2               PLAYER_SPRITE_ANIMATION = 3
001334  2               
001334  2               JUMP_LO_TICKS = 10
001334  2               JUMP_HI_TICKS = 2
001334  2               FALL_LO_TICKS = 8
001334  2               FALL_HI_TICKS = 2
001334  2               
001334  2               PLAYER_ZP = $0050
001334  2               
001334  2               .enum
001334  2               	STATUS_WALKING_IDLE
001334  2               	STATUS_WALKING
001334  2               	STATUS_CLIMBING
001334  2               	STATUS_CLIMBING_IDLE
001334  2               	STATUS_FALLING
001334  2               	STATUS_JUMPING
001334  2               	STATUS_JUMPING_IDLE
001334  2               .endenum
001334  2               
001334  2               .enum
001334  2               	SITTING_NO_SLOP
001334  2               	SITTING_ON_SLOPE
001334  2               	SITTING_ABOVE_SLOPE
001334  2               .endenum
001334  2               
001334  2               .struct PLAYER
001334  2               	entity			.tag Entity
001334  2               	animation_tick	.byte
001334  2               	frameID 		.byte	; current animation loop start
001334  2               	frame 		.byte	; current frame
001334  2               	frameDirection .byte ; direction of the animation
001334  2               	flip 			.byte
001334  2               	grab_object		.word	; address of the object currently grabbed
001334  2               	vera_bitmaps    .res 	2*12	; 9 words to store vera bitmaps address
001334  2               .endstruct
001334  2               
001334  2               .macro m_status value
001334  2               	lda #(value)
001334  2               	sta player0 + PLAYER::entity + Entity::status
001334  2               .endmacro
001334  2               
001334  2               .scope Player
001334  2               
001334  2               .macro SET_SPRITE id, frameval
001334  2               	lda #id
001334  2               	sta player0 + PLAYER::frameID
001334  2               	lda #frameval
001334  2               	sta player0 + PLAYER::frame
001334  2               	jsr set_bitmap
001334  2               .endmacro
001334  2               
001334  2               ;************************************************
001334  2               ; player sprites status
001334  2               ;
001334  2               .enum Sprites
001334  2               	FRONT = 0
001334  2               	LEFT = 3
001334  2               	CLIMB = 6
001334  2               	HANG = 9
001334  2               .endenum
001334  2               
001334  2               ;************************************************
001334  2               ; local variables
001334  2               ;
001334  2               
001334  2  00           player_on_slop: .byte 0
001335  2  00           ladders: .byte 0
001336  2  00           test_right_left: .byte 0
001337  2               
001337  2               ;************************************************
001337  2               ; init the player data
001337  2               ;
001337  2               init:
001337  2  A9 54        	lda #<player0
001339  2  85 08        	sta r3L
00133B  2  A9 1E        	lda #>player0
00133D  2  85 09        	sta r3H
00133F  2               
00133F  2  20 C8 0F     	jsr Entities::init
001342  2               
001342  2  A9 0A        	lda #10
001344  2  A0 0F        	ldy #PLAYER::animation_tick
001346  2  91 08        	sta (r3), y
001348  2  A9 03        	lda #Player::Sprites::LEFT
00134A  2  A0 10        	ldy #PLAYER::frameID
00134C  2  91 08        	sta (r3), y
00134E  2  A9 00        	lda #00
001350  2  A0 11        	ldy #PLAYER::frame
001352  2  91 08        	sta (r3), y
001354  2  A9 01        	lda #1
001356  2  A0 12        	ldy #PLAYER::frameDirection
001358  2  91 08        	sta (r3), y
00135A  2  A9 00        	lda #00
00135C  2  A0 13        	ldy #PLAYER::flip
00135E  2  91 08        	sta (r3), y
001360  2               
001360  2               	; load sprites data at the end of the tiles
001360  2  A9 01 A2 08  	VLOAD_FILE fssprite, (fsspriteend-fssprite), (::VRAM_tiles + tiles * tile_size)
001364  2  A0 00 20 BA  
001368  2  FF A9 0B A2  
001381  2               
001381  2  AD 6A 1E     	lda player0 + PLAYER::vera_bitmaps
001384  2  85 02        	sta r0L
001386  2  AD 6B 1E     	lda player0 + PLAYER::vera_bitmaps+1
001389  2  85 03        	sta r0H
00138B  2               
00138B  2  B2 08        	lda (r3)
00138D  2  A8           	tay
00138E  2  A9 10        	lda #%00010000					; collision mask 1
001390  2  A2 A0        	ldx #%10100000					; 32x32 sprite
001392  2  20 FB 0C     	jsr Sprite::load
001395  2               
001395  2  A9 08        	lda #08
001397  2  85 02        	sta r0L
001399  2  A9 00        	lda #00
00139B  2  85 03        	sta r0H
00139D  2  A9 0F        	lda #15
00139F  2  85 04        	sta r1L
0013A1  2  A9 1F        	lda #31
0013A3  2  85 05        	sta r1H
0013A5  2               
0013A5  2  B2 08        	lda (r3)
0013A7  2  A8           	tay
0013A8  2  20 43 0D     	jsr Sprite::set_aabb			; collision box (8,0) -> (24, 32)
0013AB  2               
0013AB  2               	; turn sprite 0 on
0013AB  2  B2 08        	lda (r3)
0013AD  2  A8           	tay
0013AE  2  A2 0C        	ldx #SPRITE_ZDEPTH_TOP
0013B0  2  20 86 0D     	jsr Sprite::display
0013B3  2               
0013B3  2               	; register the vera simplified memory 12:5
0013B3  2  A0 0C        	ldy #(3*4)
0013B5  2  84 50        	sty PLAYER_ZP
0013B7  2  A0 16        	ldy #PLAYER::vera_bitmaps
0013B9  2  A9 00 85 04  	LOAD_r1 (::VRAM_tiles + tiles * tile_size)
0013BD  2  A9 41 85 05  
0013C1  2               
0013C1  2               @loop:
0013C1  2               	; load full VERA memory (12:0) into R0
0013C1  2  A5 04        	lda r1L
0013C3  2  85 02        	sta r0L
0013C5  2  A5 05        	lda r1H
0013C7  2  85 03        	sta r0H
0013C9  2               
0013C9  2               	; convert full addr to vera mode (bit shiting >> 5)
0013C9  2  A5 03        	lda r0H
0013CB  2  4A           	lsr
0013CC  2  66 02        	ror r0L
0013CE  2  4A           	lsr
0013CF  2  66 02        	ror r0L
0013D1  2  4A           	lsr
0013D2  2  66 02        	ror r0L
0013D4  2  4A           	lsr
0013D5  2  66 02        	ror r0L						; bit shift 4x 16 bits vera memory
0013D7  2  4A           	lsr
0013D8  2  66 02        	ror r0L						; bit shift 4x 16 bits vera memory
0013DA  2               
0013DA  2               	; store 12:5 into our cache
0013DA  2  91 08        	sta (r3), y
0013DC  2  C8           	iny
0013DD  2  A5 02        	lda r0L
0013DF  2  91 08        	sta (r3), y
0013E1  2  C8           	iny
0013E2  2               
0013E2  2               	; increase the vram (+4 r1H = +1024 r1)
0013E2  2  18           	clc
0013E3  2  A5 05        	lda r1H
0013E5  2  69 04        	adc #4
0013E7  2  85 05        	sta r1H
0013E9  2               
0013E9  2  C6 50        	dec PLAYER_ZP
0013EB  2  D0 D4        	bne @loop
0013ED  2               
0013ED  2               	; set first bitmap
0013ED  2  20 00 14     	jsr set_bitmap
0013F0  2  60           	rts
0013F1  2               
0013F1  2               ;************************************************
0013F1  2               ; force the current player sprite at its position
0013F1  2               ;
0013F1  2               position_set:
0013F1  2  AC 54 1E     	ldy player0 + PLAYER::entity + Entity::spriteID
0013F4  2  A9 5A 85 02  	LOAD_r0 (player0 + PLAYER::entity + Entity::px)
0013F8  2  A9 1E 85 03  
0013FC  2  20 A5 0D     	jsr Sprite::position			; set position of the sprite
0013FF  2  60           	rts
001400  2               
001400  2               ;************************************************
001400  2               ; change the player bitmap
001400  2               ;
001400  2               set_bitmap:
001400  2  18           	clc
001401  2  AD 65 1E     	lda player0 + PLAYER::frame
001404  2  6D 64 1E     	adc player0 + PLAYER::frameID
001407  2  0A           	asl						; convert sprite index to work position
001408  2  AA           	tax
001409  2               
001409  2               	; extract the vera bitmap address in vera format (12:5 bits)
001409  2  BD 6A 1E     	lda player0 + PLAYER::vera_bitmaps, x
00140C  2  85 03        	sta r0H
00140E  2  BD 6B 1E     	lda player0 + PLAYER::vera_bitmaps + 1, x
001411  2  85 02        	sta r0L
001413  2               
001413  2  AC 54 1E     	ldy player0 + PLAYER::entity + Entity::spriteID
001416  2  20 74 0D     	jsr Sprite::set_bitmap
001419  2  60           	rts
00141A  2               
00141A  2               ;************************************************
00141A  2               ; increase player X position
00141A  2               ;	modify r0
00141A  2               ;
00141A  2               position_x_inc:
00141A  2               	; move the absolute position levelx + 1
00141A  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx
00141D  2  AE 57 1E     	ldx player0 + PLAYER::entity + Entity::levelx + 1
001420  2  C9 E0        	cmp #<(LEVEL_WIDTH - 32)
001422  2  D0 04        	bne @incLOW1
001424  2  E0 01        	cpx #>(LEVEL_WIDTH - 32)
001426  2  F0 48        	beq @no_move						; we are at the level limit
001428  2               @incLOW1:
001428  2  1A           	inc
001429  2  8D 56 1E     	sta player0 + PLAYER::entity + Entity::levelx
00142C  2  D0 04        	bne @inc_screen_x
00142E  2               @incHi:
00142E  2  E8           	inx
00142F  2  8E 57 1E     	stx player0 + PLAYER::entity + Entity::levelx + 1
001432  2               
001432  2               @inc_screen_x:
001432  2               	; distance from layer border to sprite absolute position
001432  2  38           	sec
001433  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx
001436  2  ED 37 9F     	sbc VERA_L1_hscrolllo
001439  2  85 02        	sta r0L
00143B  2  AD 57 1E     	lda player0 + PLAYER::entity + Entity::levelx + 1
00143E  2  ED 38 9F     	sbc VERA_L1_hscrollhi
001441  2  85 03        	sta r0H
001443  2               
001443  2  D0 17        	bne @move_sprite_upper
001445  2  A6 03        	ldx r0H
001447  2  A5 02        	lda r0L
001449  2  C9 E0        	cmp #<(SCREEN_WIDTH	- 96)
00144B  2  90 19        	bcc @move_sprite
00144D  2               
00144D  2               @move_layers:
00144D  2               	; keep the sprite onscreen 224, for level 224->416
00144D  2  A0 BF A2 00  	VSCROLL_INC Layers::HSCROLL,(32*16-320 - 1)	; 32 tiles * 16 pixels per tiles - 320 screen pixels
001451  2  20 F8 11     
001454  2  F0 06        	beq @move_sprite_upper
001456  2  A2 00        	ldx #Layers::HSCROLL
001458  2  20 57 12     	jsr Layers::scroll_l0
00145B  2  60           	rts
00145C  2               
00145C  2               @move_sprite_upper:
00145C  2  AD 5A 1E     	lda player0 + PLAYER::entity + Entity::px
00145F  2  AE 5B 1E     	ldx player0 + PLAYER::entity + Entity::px + 1
001462  2  1A           	inc
001463  2  D0 01        	bne @move_sprite
001465  2  E8           	inx
001466  2               
001466  2               @move_sprite:
001466  2  8D 5A 1E     	sta player0 + PLAYER::entity + Entity::px
001469  2  8E 5B 1E     	stx player0 + PLAYER::entity + Entity::px + 1
00146C  2  20 F1 13     	jsr Player::position_set
00146F  2  60           	rts
001470  2               
001470  2               @no_move:
001470  2  60           	rts
001471  2               
001471  2               ;************************************************
001471  2               ; decrease player position X unless at 0
001471  2               ;
001471  2               position_x_dec:
001471  2               	; move the absolute position levelx + 1
001471  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx
001474  2  D0 05        	bne @decLOW
001476  2  AE 57 1E     	ldx player0 + PLAYER::entity + Entity::levelx + 1
001479  2  F0 49        	beq @no_move						; we are at Y == 0
00147B  2               @decLOW:
00147B  2  3A           	dec
00147C  2  8D 56 1E     	sta player0 + PLAYER::entity + Entity::levelx
00147F  2  C9 FF        	cmp #$ff
001481  2  D0 04        	bne @dec_screen_x
001483  2               @decHi:
001483  2  CA           	dex
001484  2  8E 57 1E     	stx player0 + PLAYER::entity + Entity::levelx + 1
001487  2               
001487  2               @dec_screen_x:
001487  2               	; distance from layer border to sprite absolute position
001487  2  38           	sec
001488  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx
00148B  2  ED 37 9F     	sbc VERA_L1_hscrolllo
00148E  2  85 02        	sta r0L
001490  2  AD 57 1E     	lda player0 + PLAYER::entity + Entity::levelx + 1
001493  2  ED 38 9F     	sbc VERA_L1_hscrollhi
001496  2  85 03        	sta r0H
001498  2               
001498  2  D0 15        	bne @move_sprite_lower				; > 256, we are far off from the border, so move the sprite
00149A  2               
00149A  2  A5 02        	lda r0L
00149C  2  30 11        	bmi @move_sprite_lower					; > 127, move the sprites
00149E  2  C9 40        	cmp #64
0014A0  2  B0 0D        	bcs @move_sprite_lower					; if > 64, move the sprites
0014A2  2               
0014A2  2               @move_layers:
0014A2  2               	; keep the sprite onscreen 224, for level 224->416
0014A2  2  A2 00        	ldx #Layers::HSCROLL
0014A4  2  20 35 12     	jsr Layers::scroll_dec
0014A7  2  F0 06        	beq @move_sprite_lower
0014A9  2  A2 00        	ldx #Layers::HSCROLL
0014AB  2  20 57 12     	jsr Layers::scroll_l0
0014AE  2  60           	rts
0014AF  2               
0014AF  2               @move_sprite_lower:
0014AF  2  AD 5A 1E     	lda player0 + PLAYER::entity + Entity::px
0014B2  2  AE 5B 1E     	ldx player0 + PLAYER::entity + Entity::px + 1
0014B5  2  3A           	dec
0014B6  2  C9 FF        	cmp #$ff
0014B8  2  D0 01        	bne @move_sprite
0014BA  2  CA           	dex
0014BB  2               
0014BB  2               @move_sprite:
0014BB  2  8D 5A 1E     	sta player0 + PLAYER::entity + Entity::px
0014BE  2  8E 5B 1E     	stx player0 + PLAYER::entity + Entity::px + 1
0014C1  2  20 F1 13     	jsr Player::position_set
0014C4  2               
0014C4  2               @no_move:
0014C4  2  60           	rts
0014C5  2               
0014C5  2               ;************************************************
0014C5  2               ; increase player Y position
0014C5  2               ;
0014C5  2               position_y_inc:
0014C5  2               	; move the absolute position levelx + 1
0014C5  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely
0014C8  2  AE 59 1E     	ldx player0 + PLAYER::entity + Entity::levely + 1
0014CB  2  C9 E0        	cmp #<(LEVEL_HEIGHT - 32)
0014CD  2  D0 04        	bne @incLOW1
0014CF  2  E0 01        	cpx #>(LEVEL_HEIGHT - 32)
0014D1  2  F0 4E        	beq @no_move						; we are at the level limit
0014D3  2               @incLOW1:
0014D3  2  1A           	inc
0014D4  2  8D 58 1E     	sta player0 + PLAYER::entity + Entity::levely
0014D7  2  D0 04        	bne @inc_screen_y
0014D9  2               @incHi:
0014D9  2  E8           	inx
0014DA  2  8E 59 1E     	stx player0 + PLAYER::entity + Entity::levely + 1
0014DD  2               
0014DD  2               @inc_screen_y:
0014DD  2               	; distance from layer border to sprite absolute position
0014DD  2  38           	sec
0014DE  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely
0014E1  2  ED 39 9F     	sbc VERA_L1_vscrolllo
0014E4  2  85 02        	sta r0L
0014E6  2  AD 59 1E     	lda player0 + PLAYER::entity + Entity::levely + 1
0014E9  2  ED 3A 9F     	sbc VERA_L1_vscrollhi
0014EC  2  85 03        	sta r0H
0014EE  2               
0014EE  2  D0 1D        	bne @move_sprite_upper
0014F0  2  A6 03        	ldx r0H
0014F2  2  A5 02        	lda r0L
0014F4  2  C9 B0        	cmp #<(SCREEN_HEIGHT - 64)
0014F6  2  90 1F        	bcc @move_sprite
0014F8  2               
0014F8  2               @move_layers:
0014F8  2               	; keep the sprite onscreen 224, for level 224->416
0014F8  2  A9 0F 85 02  	VSCROLL_INC Layers::VSCROLL,(32*16-240 - 1)	; 32 tiles * 16 pixels per tiles - 240 screen pixels
0014FC  2  A9 01 85 03  
001500  2  A2 02 20 13  
001505  2  F0 06        	beq @move_sprite_upper
001507  2  A2 02        	ldx #Layers::VSCROLL
001509  2  20 57 12     	jsr Layers::scroll_l0
00150C  2  60           	rts
00150D  2               
00150D  2               @move_sprite_upper:
00150D  2  AD 5C 1E     	lda player0 + PLAYER::entity + Entity::py
001510  2  AE 5D 1E     	ldx player0 + PLAYER::entity + Entity::py + 1
001513  2  1A           	inc
001514  2  D0 01        	bne @move_sprite
001516  2  E8           	inx
001517  2               
001517  2               @move_sprite:
001517  2  8D 5C 1E     	sta player0 + PLAYER::entity + Entity::py
00151A  2  8E 5D 1E     	stx player0 + PLAYER::entity + Entity::py + 1
00151D  2  20 F1 13     	jsr Player::position_set
001520  2  60           	rts
001521  2               
001521  2               @no_move:
001521  2  60           	rts
001522  2               
001522  2               ;;
001522  2  AD 5C 1E     	lda player0 + PLAYER::entity + Entity::py
001525  2  C9 D0        	cmp #(SCREEN_HEIGHT-32)
001527  2  F0 09        	beq @moveleftP0
001529  2  1A           	inc
00152A  2  8D 5C 1E     	sta player0 + PLAYER::entity + Entity::py
00152D  2  D0 03        	bne @moveleftP0
00152F  2  EE 5D 1E     	inc player0 + PLAYER::entity + Entity::py + 1
001532  2               @moveleftP0:
001532  2  20 F1 13     	jsr Player::position_set
001535  2  60           	rts
001536  2               
001536  2               ;************************************************
001536  2               ; decrease player position X unless at 0
001536  2               ;
001536  2               position_y_dec:
001536  2               	; move the absolute position levelx + 1
001536  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely
001539  2  D0 05        	bne @decLOW
00153B  2  AE 59 1E     	ldx player0 + PLAYER::entity + Entity::levely + 1
00153E  2  F0 49        	beq @no_move						; we are at Y == 0
001540  2               @decLOW:
001540  2  3A           	dec
001541  2  8D 58 1E     	sta player0 + PLAYER::entity + Entity::levely
001544  2  C9 FF        	cmp #$ff
001546  2  D0 04        	bne @dec_screen_y
001548  2               @decHi:
001548  2  CA           	dex
001549  2  8E 59 1E     	stx player0 + PLAYER::entity + Entity::levely + 1
00154C  2               
00154C  2               @dec_screen_y:
00154C  2               	; distance from layer border to sprite absolute position
00154C  2  38           	sec
00154D  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely
001550  2  ED 39 9F     	sbc VERA_L1_vscrolllo
001553  2  85 02        	sta r0L
001555  2  AD 59 1E     	lda player0 + PLAYER::entity + Entity::levely + 1
001558  2  ED 3A 9F     	sbc VERA_L1_vscrollhi
00155B  2  85 03        	sta r0H
00155D  2               
00155D  2  D0 15        	bne @move_sprite_lower				; > 256, we are far off from the border, so move the sprite
00155F  2               
00155F  2  A5 02        	lda r0L
001561  2  30 11        	bmi @move_sprite_lower					; > 127, move the sprites
001563  2  C9 20        	cmp #32
001565  2  B0 0D        	bcs @move_sprite_lower					; if > 32, move the sprites
001567  2               
001567  2               @move_layers:
001567  2               	; keep the sprite onscreen 224, for level 224->416
001567  2  A2 02        	ldx #Layers::VSCROLL
001569  2  20 35 12     	jsr Layers::scroll_dec
00156C  2  F0 06        	beq @move_sprite_lower
00156E  2  A2 02        	ldx #Layers::VSCROLL
001570  2  20 57 12     	jsr Layers::scroll_l0
001573  2  60           	rts
001574  2               
001574  2               @move_sprite_lower:
001574  2  AD 5C 1E     	lda player0 + PLAYER::entity + Entity::py
001577  2  AE 5D 1E     	ldx player0 + PLAYER::entity + Entity::py + 1
00157A  2  3A           	dec
00157B  2  C9 FF        	cmp #$ff
00157D  2  D0 01        	bne @move_sprite
00157F  2  CA           	dex
001580  2               
001580  2               @move_sprite:
001580  2  8D 5C 1E     	sta player0 + PLAYER::entity + Entity::py
001583  2  8E 5D 1E     	stx player0 + PLAYER::entity + Entity::py + 1
001586  2  20 F1 13     	jsr Player::position_set
001589  2               
001589  2               @no_move:
001589  2  60           	rts
00158A  2               
00158A  2               ;************************************************
00158A  2               ; hide the current sprite
00158A  2               ;
00158A  2               hide1:
00158A  2  DB           	stp
00158B  2  18           	clc
00158C  2  AD 65 1E     	lda player0 + PLAYER::frame
00158F  2  6D 64 1E     	adc player0 + PLAYER::frameID
001592  2  A8           	tay		; sprite index
001593  2  A2 00        	ldx #SPRITE_ZDEPTH_DISABLED
001595  2  20 86 0D     	jsr Sprite::display			; turn current sprite off
001598  2  60           	rts
001599  2               
001599  2               ;************************************************
001599  2               ; Animate the player if needed
001599  2               ;
001599  2               animate:
001599  2  AD 55 1E     	lda player0 + PLAYER::entity + Entity::status
00159C  2  C9 00        	cmp #STATUS_WALKING_IDLE
00159E  2  F0 3A        	beq @end
0015A0  2  C9 04        	cmp #STATUS_FALLING
0015A2  2  F0 36        	beq @end
0015A4  2  C9 03        	cmp #STATUS_CLIMBING_IDLE
0015A6  2  F0 32        	beq @end
0015A8  2               
0015A8  2  CE 63 1E     	dec player0 + PLAYER::animation_tick
0015AB  2  D0 2D        	bne @end
0015AD  2               
0015AD  2  A9 0A        	lda #10
0015AF  2  8D 63 1E     	sta player0 + PLAYER::animation_tick	; reset animation tick counter
0015B2  2               
0015B2  2  18           	clc
0015B3  2  AD 65 1E     	lda player0 + PLAYER::frame
0015B6  2  6D 66 1E     	adc player0 + PLAYER::frameDirection
0015B9  2  F0 06        	beq @set_sprite_anim_increase					; reached 0
0015BB  2  C9 03        	cmp #3
0015BD  2  F0 0B        	beq @set_sprite_anim_decrease
0015BF  2  80 10        	bra @set_sprite_on
0015C1  2               @set_sprite_anim_increase:
0015C1  2  A9 01        	lda #01
0015C3  2  8D 66 1E     	sta player0 + PLAYER::frameDirection
0015C6  2  A9 00        	lda #0
0015C8  2  80 07        	bra @set_sprite_on
0015CA  2               @set_sprite_anim_decrease:
0015CA  2  A9 FF        	lda #$ff
0015CC  2  8D 66 1E     	sta player0 + PLAYER::frameDirection
0015CF  2  A9 02        	lda #2
0015D1  2               @set_sprite_on:
0015D1  2  8D 65 1E     	sta player0 + PLAYER::frame	; turn next sprite on
0015D4  2  20 00 14     	jsr Player::set_bitmap
0015D7  2  20 F1 13     	jsr Player::position_set
0015DA  2               @end:
0015DA  2  60           	rts
0015DB  2               
0015DB  2               ;************************************************
0015DB  2               ; force player status to be idle
0015DB  2               ;
0015DB  2               set_idle:
0015DB  2  AD 55 1E     	lda player0 + PLAYER::entity + Entity::status
0015DE  2  C9 01        	cmp #STATUS_WALKING
0015E0  2  F0 06        	beq @set_idle_walking
0015E2  2  C9 02        	cmp #STATUS_CLIMBING
0015E4  2  F0 08        	beq @set_idle_climbing
0015E6  2  60           	rts							; keep the current value
0015E7  2               @set_idle_jump:
0015E7  2  60           	rts
0015E8  2               @set_idle_walking:
0015E8  2  A9 00 8D 55  	m_status STATUS_WALKING_IDLE
0015EC  2  1E           
0015ED  2  60           	rts
0015EE  2               @set_idle_climbing:
0015EE  2  A9 03 8D 55  	m_status STATUS_CLIMBING_IDLE
0015F2  2  1E           
0015F3  2  60           	rts
0015F4  2               
0015F4  2               ;************************************************
0015F4  2               ; check if the player sits on a solid tile
0015F4  2               ;
0015F4  2               physics:
0015F4  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely		; sprite screen position
0015F7  2  85 02        	sta r0L
0015F9  2  AD 59 1E     	lda player0 + PLAYER::entity + Entity::levely + 1
0015FC  2  85 03        	sta r0H							; r0 = sprite absolute position Y in the level
0015FE  2               
0015FE  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx		; sprite screen position
001601  2  85 04        	sta r1L
001603  2  AD 57 1E     	lda player0 + PLAYER::entity + Entity::levelx + 1
001606  2  85 05        	sta r1H							; r1 = sprite absolute position X in the level
001608  2               
001608  2  20 00 13     	jsr Tilemap::get_collision_addr
00160B  2  A5 02 8D 61  	SAVE_r0 player0 + PLAYER::entity + Entity::collision_addr	; cache the collision @
00160F  2  1E A5 03 8D  
001613  2  62 1E        
001615  2               
001615  2  AD 55 1E     	lda player0 + PLAYER::entity + Entity::status
001618  2  C9 02        	cmp #STATUS_CLIMBING
00161A  2  F0 0B        	beq @return1
00161C  2  C9 03        	cmp #STATUS_CLIMBING_IDLE
00161E  2  F0 07        	beq @return1
001620  2  C9 05        	cmp #STATUS_JUMPING
001622  2  D0 04        	bne @fall
001624  2  4C E0 16     	jmp @jump
001627  2               @return1:
001627  2  60           	rts
001628  2               
001628  2               	;
001628  2               	; deal with gravity driven falling
001628  2               	;
001628  2               @fall:
001628  2               .ifdef DEBUG
001628  2               	CHECK_DEBUG
001628  2               .endif
001628  2  20 FB 17     	jsr check_collision_down
00162B  2  F0 03        	beq @check_on_slope				; no solid tile below the player, still check if the player is ON a slope
00162D  2  4C D3 16     	jmp @sit_on_solid				; solid tile below the player that is not a slope
001630  2               
001630  2               @check_on_slope:
001630  2  20 9A 18     	jsr check_player_on_slop
001633  2  F0 23        	beq @no_collision_down			; not ON a slope, and not ABOVE a solid tile => fall
001635  2               
001635  2               @on_slope:
001635  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
001637  2  F0 0B        	beq @slope_left
001639  2               @slope_right:
001639  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx	; X position defines how far down Y can go
00163C  2  29 0F        	and #%00001111
00163E  2  49 0F        	eor #%00001111					; X = 0 => Y can go up to 15
001640  2  85 30        	sta $30
001642  2  80 09        	bra @slope_y
001644  2               @slope_left:
001644  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx	; X position defines how far down Y can go
001647  2  29 0F        	and #%00001111
001649  2  85 30        	sta $30
00164B  2  80 00        	bra @slope_y
00164D  2               @slope_y:
00164D  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely
001650  2  29 0F        	and #%00001111
001652  2  C5 30        	cmp $30
001654  2  30 02        	bmi @no_collision_down
001656  2  80 7B        	bra @sit_on_solid
001658  2               
001658  2               @no_collision_down:
001658  2               	; if the player is already falling, increase t
001658  2  AD 55 1E     	lda player0 + PLAYER::entity + Entity::status
00165B  2  C9 04        	cmp #STATUS_FALLING
00165D  2  F0 0D        	beq @increase_ticks
00165F  2               
00165F  2               	; let the player fall
00165F  2  A9 04        	lda #STATUS_FALLING
001661  2  8D 55 1E     	sta player0 + PLAYER::entity + Entity::status
001664  2  A9 08        	lda #FALL_LO_TICKS
001666  2  8D 5E 1E     	sta player0 + PLAYER::entity + Entity::falling_ticks	; reset t
001669  2  9C 5F 1E     	stz player0 + PLAYER::entity + Entity::falling_ticks + 1
00166C  2               @increase_ticks:
00166C  2  CE 5E 1E     	dec player0 + PLAYER::entity + Entity::falling_ticks	; increase HI every 10 refresh
00166F  2  D0 08        	bne @drive_fall
001671  2  A9 08        	lda #FALL_LO_TICKS
001673  2  8D 5E 1E     	sta player0 + PLAYER::entity + Entity::falling_ticks	; reset t
001676  2  EE 5F 1E     	inc player0 + PLAYER::entity + Entity::falling_ticks + 1
001679  2               
001679  2               @drive_fall:
001679  2  AD 5F 1E     	lda player0 + PLAYER::entity + Entity::falling_ticks + 1
00167C  2  F0 50        	beq @fall_once
00167E  2  85 14        	sta r9L
001680  2               @loop_fall:
001680  2  20 C5 14     	jsr position_y_inc
001683  2               
001683  2               	; refresh the collision addre
001683  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely		; sprite screen position
001686  2  85 02        	sta r0L
001688  2  AD 59 1E     	lda player0 + PLAYER::entity + Entity::levely + 1
00168B  2  85 03        	sta r0H							; r0 = sprite absolute position Y in the level
00168D  2               
00168D  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx		; sprite screen position
001690  2  85 04        	sta r1L
001692  2  AD 57 1E     	lda player0 + PLAYER::entity + Entity::levelx + 1
001695  2  85 05        	sta r1H							; r1 = sprite absolute position X in the level
001697  2               
001697  2  20 00 13     	jsr Tilemap::get_collision_addr
00169A  2  A5 02 8D 61  	SAVE_r0 player0 + PLAYER::entity + Entity::collision_addr
00169E  2  1E A5 03 8D  
0016A2  2  62 1E        
0016A4  2               
0016A4  2               	; test reached solid ground
0016A4  2  20 FB 17     	jsr check_collision_down
0016A7  2  D0 2A        	bne @sit_on_solid
0016A9  2               
0016A9  2               @loop_fall_no_collision:
0016A9  2  C6 14        	dec r9L
0016AB  2  D0 D3        	bne @loop_fall						; take t in count for gravity
0016AD  2               
0016AD  2               @apply_delta_x:
0016AD  2  AD 60 1E     	lda player0 + PLAYER::entity + Entity::delta_x		; apply delatx
0016B0  2  F0 2D        	beq @return
0016B2  2  30 0D        	bmi @fall_left
0016B4  2               @fall_right:
0016B4  2  20 C3 17     	jsr check_collision_right
0016B7  2  F0 04        	beq @no_fcollision_right
0016B9  2               @fcollision_right:
0016B9  2  9C 60 1E     	stz player0 + PLAYER::entity + Entity::delta_x		; cancel deltaX to transform to vertical movement
0016BC  2  60           	rts
0016BD  2               @no_fcollision_right:
0016BD  2  20 1A 14     	jsr position_x_inc
0016C0  2  60           	rts
0016C1  2               @fall_left:
0016C1  2  20 DF 17     	jsr check_collision_left
0016C4  2  F0 04        	beq @no_fcollision_left
0016C6  2               @fcollision_left:
0016C6  2  9C 60 1E     	stz player0 + PLAYER::entity + Entity::delta_x		; cancel deltaX to transform to vertical movement
0016C9  2  60           	rts
0016CA  2               @no_fcollision_left:
0016CA  2  20 71 14     	jsr position_x_dec
0016CD  2  60           	rts
0016CE  2               
0016CE  2               @fall_once:
0016CE  2  20 C5 14     	jsr position_y_inc
0016D1  2  80 DA        	bra @apply_delta_x
0016D3  2               
0016D3  2               @sit_on_solid:
0016D3  2               	; change the status if falling
0016D3  2  AD 55 1E     	lda player0 + PLAYER::entity + Entity::status
0016D6  2  C9 04        	cmp #STATUS_FALLING
0016D8  2  D0 05        	bne @return
0016DA  2  A9 00        	lda #STATUS_WALKING_IDLE
0016DC  2  8D 55 1E     	sta player0 + PLAYER::entity + Entity::status
0016DF  2               @return:
0016DF  2  60           	rts
0016E0  2               
0016E0  2               	;
0016E0  2               	; deal with gravity driven jumping
0016E0  2               	;
0016E0  2               @jump:
0016E0  2               @decrease_ticks:
0016E0  2  CE 5E 1E     	dec player0 + PLAYER::entity + Entity::falling_ticks	; decrease  HI every 10 refresh
0016E3  2  D0 0A        	bne @drive_jump
0016E5  2  CE 5F 1E     	dec player0 + PLAYER::entity + Entity::falling_ticks	+ 1
0016E8  2  F0 5F        	beq @apex							; reached the apex of the jump
0016EA  2               
0016EA  2  A9 0A        	lda #JUMP_LO_TICKS
0016EC  2  8D 5E 1E     	sta player0 + PLAYER::entity + Entity::falling_ticks	; reset t
0016EF  2               
0016EF  2               @drive_jump:
0016EF  2  AD 5F 1E     	lda player0 + PLAYER::entity + Entity::falling_ticks + 1
0016F2  2  85 14        	sta r9L
0016F4  2               @loop_jump:
0016F4  2  20 36 15     	jsr position_y_dec
0016F7  2               
0016F7  2               	; refresh the collision address
0016F7  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely		; sprite screen position
0016FA  2  85 02        	sta r0L
0016FC  2  AD 59 1E     	lda player0 + PLAYER::entity + Entity::levely + 1
0016FF  2  85 03        	sta r0H							; r0 = sprite absolute position Y in the level
001701  2               
001701  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx		; sprite screen position
001704  2  85 04        	sta r1L
001706  2  AD 57 1E     	lda player0 + PLAYER::entity + Entity::levelx + 1
001709  2  85 05        	sta r1H							; r1 = sprite absolute position X in the level
00170B  2  20 00 13     	jsr Tilemap::get_collision_addr
00170E  2  A5 02 8D 61  	SAVE_r0 player0 + PLAYER::entity + Entity::collision_addr
001712  2  1E A5 03 8D  
001716  2  62 1E        
001718  2               
001718  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely
00171B  2  29 0F        	and #%00001111
00171D  2  D0 05        	bne @no_collision_up				; if player is not on a multiple of 16 (tile size)
00171F  2               
00171F  2               	; test hit a ceiling
00171F  2  20 4E 18     	jsr check_collision_up
001722  2  D0 04        	bne @collision_up
001724  2               @no_collision_up:
001724  2  C6 14        	dec r9L
001726  2  D0 CC        	bne @loop_jump						; loop to take t in count for gravity
001728  2               
001728  2               @collision_up:
001728  2  AD 60 1E     	lda player0 + PLAYER::entity + Entity::delta_x		; deal with deltax
00172B  2  F0 B2        	beq @return
00172D  2  30 0D        	bmi @jump_left
00172F  2               @jump_right:
00172F  2  20 C3 17     	jsr check_collision_right
001732  2  F0 04        	beq @no_collision_right
001734  2               @collision_right:
001734  2  9C 60 1E     	stz player0 + PLAYER::entity + Entity::delta_x		; cancel deltaX to transform to vertical movement
001737  2  60           	rts
001738  2               @no_collision_right:
001738  2  20 1A 14     	jsr position_x_inc
00173B  2  60           	rts
00173C  2               @jump_left:
00173C  2  20 DF 17     	jsr check_collision_left
00173F  2  F0 04        	beq @no_collision_left
001741  2               @collision_left:
001741  2  9C 60 1E     	stz player0 + PLAYER::entity + Entity::delta_x		; cancel deltaX to transform to vertical movement
001744  2  60           	rts
001745  2               @no_collision_left:
001745  2  20 71 14     	jsr position_x_dec
001748  2  60           	rts
001749  2               
001749  2               @apex:
001749  2  A9 06 8D 55  	m_status STATUS_JUMPING_IDLE
00174D  2  1E           
00174E  2  60           	rts
00174F  2               
00174F  2               ;************************************************
00174F  2               ;	compute the number of tiles covered by the boundingbox
00174F  2               ;	return: r1L : number of tiles height
00174F  2               ;			X = r1H : number of tiles width
00174F  2               ;			Y = r2L : index of the first tile to test
00174F  2               ;
00174F  2               bbox_coverage:
00174F  2               	; X = how many column of tiles to test
00174F  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx
001752  2  29 0F        	and #%00001111
001754  2  C9 08        	cmp #8
001756  2  F0 08        	beq @one_tile
001758  2  30 0C        	bmi @two_tiles_straight				; if X < 8, test as if int
00175A  2               @two_tiles_right:
00175A  2  A2 02        	ldx #02								; test 2 column ( y % 16 <> 0)
00175C  2  A0 01        	ldy #01								; starting on row +1
00175E  2  80 0A        	bra @test_lines
001760  2               @one_tile:
001760  2  A2 01        	ldx #01								; test 1 column ( y % 16  == 8)
001762  2  A0 01        	ldy #01								; starting on row +1
001764  2  80 04        	bra @test_lines
001766  2               @two_tiles_straight:
001766  2  A2 02        	ldx #02								; test 2 columns ( y % 16 == 0)
001768  2  A0 00        	ldy #00								; test on row  0 ( x % 16 != 0)
00176A  2               
00176A  2               @test_lines:
00176A  2               	; X = how many lines of tiles to test
00176A  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely
00176D  2  29 0F        	and #%00001111
00176F  2  D0 09        	bne @yfloat				; if player is not on a multiple of 16 (tile size)
001771  2               @yint:
001771  2  A9 02        	lda #02					; test 2 lines ( y % 16 == 0)
001773  2  85 04        	sta r1L
001775  2  86 05        	stx r1H
001777  2  84 06        	sty r2L
001779  2  60           	rts
00177A  2               @yfloat:
00177A  2  A9 03        	lda #03					; test 3 rows ( y % 16 <> 0)
00177C  2  85 04        	sta r1L
00177E  2  86 05        	stx r1H
001780  2  84 06        	sty r2L
001782  2  60           	rts
001783  2               
001783  2               ;************************************************
001783  2               ; check collision on the height
001783  2               ;	A = vaule of the collision
001783  2               ;	ZERO = no collision
001783  2               ;
001783  2               check_collision_height:
001783  2               	; only test if we are 'centered'
001783  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx
001786  2  29 0F        	and #%00001111
001788  2  C9 08        	cmp #08
00178A  2  D0 34        	bne @no_collision
00178C  2               
00178C  2  AD 61 1E     	lda player0 + PLAYER::entity + Entity::collision_addr
00178F  2  85 02        	sta r0L
001791  2  AD 62 1E     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
001794  2  85 03        	sta r0H
001796  2               
001796  2  20 4F 17     	jsr bbox_coverage
001799  2  A6 04        	ldx r1L				; tiles height
00179B  2  98           	tya
00179C  2  18           	clc
00179D  2  6D 36 13     	adc test_right_left
0017A0  2  A8           	tay
0017A1  2               
0017A1  2               @test_line:
0017A1  2  B1 02        	lda (r0L),y
0017A3  2  F0 11        	beq @test_next_line
0017A5  2               
0017A5  2               	; some tiles are not real collision
0017A5  2  84 30        	sty $30
0017A7  2  A8           	tay
0017A8  2  B9 4A 1D     	lda tiles_attributes,y
0017AB  2  89 02        	bit #TILE_ATTR::SOLID_WALL
0017AD  2  F0 05        	beq @test_next_line1
0017AF  2  A4 30        	ldy $30
0017B1  2  B1 02        	lda (r0L),y
0017B3  2  60           	rts
0017B4  2               
0017B4  2               @test_next_line1:
0017B4  2  A4 30        	ldy $30
0017B6  2               
0017B6  2               @test_next_line:
0017B6  2  CA           	dex
0017B7  2  F0 07        	beq @no_collision
0017B9  2  98           	tya
0017BA  2  18           	clc
0017BB  2  69 20        	adc #LEVEL_TILES_WIDTH			; test the tile on the right of the player (hip position)
0017BD  2  A8           	tay
0017BE  2  80 E1        	bra @test_line					; LADDERS can be traversed
0017C0  2               
0017C0  2               @no_collision:						; force a no collision
0017C0  2  A9 00        	lda #00
0017C2  2               @return:
0017C2  2  60           	rts
0017C3  2               
0017C3  2               ;************************************************
0017C3  2               ; check collision on the right
0017C3  2               ;	return: A = value of the collision, or 00/01 for sprites
0017C3  2               ;			ZERO = no collision
0017C3  2               ;
0017C3  2               check_collision_right:
0017C3  2  A9 01        	lda #$01
0017C5  2  8D 36 13     	sta test_right_left
0017C8  2  20 83 17     	jsr check_collision_height
0017CB  2  D0 11        	bne @return						; if tile collision, return the tile value
0017CD  2               
0017CD  2  A9 06        	lda #(02 | 04)
0017CF  2  AE 54 1E     	ldx player0 + PLAYER::entity + Entity::spriteID
0017D2  2  A0 01        	ldy #01
0017D4  2  20 CF 0E     	jsr Sprite::precheck_collision	; precheck 1 pixel right, if a=$ff => nocollision
0017D7  2  30 03        	bmi @no_collision
0017D9  2  A9 01        	lda #01
0017DB  2  60           	rts
0017DC  2               
0017DC  2               @no_collision:
0017DC  2  A9 00        	lda #00
0017DE  2               @return:
0017DE  2  60           	rts
0017DF  2               
0017DF  2               ;************************************************
0017DF  2               ; check collision on the left
0017DF  2               ;	return: A = value of the collision, or 00/01 for sprites
0017DF  2               ;			ZERO = no collision
0017DF  2               ;
0017DF  2               check_collision_left:
0017DF  2  A9 FF        	lda #$ff
0017E1  2  8D 36 13     	sta test_right_left
0017E4  2  20 83 17     	jsr check_collision_height
0017E7  2  D0 11        	bne @return
0017E9  2               
0017E9  2  A9 0A        	lda #(02 | 08)
0017EB  2  AE 54 1E     	ldx player0 + PLAYER::entity + Entity::spriteID
0017EE  2  A0 01        	ldy #01
0017F0  2  20 CF 0E     	jsr Sprite::precheck_collision	; precheck 1 pixel right
0017F3  2  30 03        	bmi @no_collision
0017F5  2  A9 01        	lda #01
0017F7  2  60           	rts
0017F8  2               
0017F8  2               @no_collision:
0017F8  2  A9 00        	lda #00
0017FA  2               @return:
0017FA  2  60           	rts
0017FB  2               
0017FB  2               ;************************************************
0017FB  2               ; check collision down
0017FB  2               ;	collision surface to test is 16 pixels around the mid X
0017FB  2               ; 	output : Z = no collision
0017FB  2               ;
0017FB  2               check_collision_down:
0017FB  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely	; if the player is inbetween 2 tiles there can be no collision
0017FE  2  29 0F        	and #%00001111
001800  2  F0 12        	beq @real_test
001802  2               
001802  2  A9 05        	lda #(01 | 04)
001804  2  AE 54 1E     	ldx player0 + PLAYER::entity + Entity::spriteID
001807  2  A0 01        	ldy #01
001809  2  20 CF 0E     	jsr Sprite::precheck_collision	; precheck 1 pixel right
00180C  2  30 03        	bmi @no_collision
00180E  2  A9 01        	lda #01
001810  2  60           	rts
001811  2               @no_collision:
001811  2  A9 00        	lda #00
001813  2  60           	rts
001814  2               @real_test:
001814  2  AD 61 1E     	lda player0 + PLAYER::entity + Entity::collision_addr
001817  2  85 02        	sta r0L
001819  2  AD 62 1E     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
00181C  2  85 03        	sta r0H
00181E  2               
00181E  2  20 4F 17     	jsr bbox_coverage
001821  2  98           	tya
001822  2  18           	clc
001823  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)	; check below the player
001825  2  A8           	tay
001826  2               
001826  2               @test_colum:
001826  2  B1 02        	lda (r0L),y
001828  2  F0 0C        	beq @next_colum							; empty tile, test the next one
00182A  2               
00182A  2  84 30        	sty $30
00182C  2  A8           	tay
00182D  2  B9 4A 1D     	lda tiles_attributes,y
001830  2  89 01        	bit #TILE_ATTR::SOLID_GROUND
001832  2  D0 08        	bne @collision							; considere slopes as empty
001834  2  A4 30        	ldy $30
001836  2               
001836  2               @next_colum:
001836  2  CA           	dex
001837  2  F0 06        	beq @return
001839  2  C8           	iny
00183A  2  80 EA        	bra @test_colum
00183C  2               @collision:
00183C  2  A9 01        	lda #01
00183E  2  60           	rts
00183F  2               @return:
00183F  2  A9 05        	lda #(01 | 04)
001841  2  AE 54 1E     	ldx player0 + PLAYER::entity + Entity::spriteID
001844  2  A0 01        	ldy #01
001846  2  20 CF 0E     	jsr Sprite::precheck_collision	; precheck 1 pixel right
001849  2  30 C6        	bmi @no_collision
00184B  2  A9 01        	lda #01
00184D  2  60           	rts
00184E  2               
00184E  2               ;************************************************
00184E  2               ; check collision up
00184E  2               ;	collision surface to test is 16 pixels around the mid X
00184E  2               ;	input :
00184E  2               ;		r0 : @ of current tile the top-left corner of the player sprite
00184E  2               ; 	output : Z = no collision
00184E  2               ;
00184E  2               check_collision_up:
00184E  2  38           	sec
00184F  2  AD 61 1E     	lda player0 + PLAYER::entity + Entity::collision_addr
001852  2  E9 20        	sbc #LEVEL_TILES_WIDTH
001854  2  85 02        	sta r0L
001856  2  AD 62 1E     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
001859  2  E9 00        	sbc #0
00185B  2  85 03        	sta r0H
00185D  2               
00185D  2               	; X = how many column of tiles to test
00185D  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx
001860  2  29 0F        	and #%00001111
001862  2  F0 0A        	beq @xint				; if player is not on a multiple of 16 (tile size)
001864  2               @xfloat:
001864  2  C9 08        	cmp #8
001866  2  30 06        	bmi @xint
001868  2  A2 01        	ldx #1					; test 1 column ( y % 16 <> 0)
00186A  2  A0 01        	ldy #1					; starting at colum + 1
00186C  2  80 13        	bra @test_colum
00186E  2               @xint:
00186E  2  A2 02        	ldx #2					; test 2 columns ( y % 16 == 0)
001870  2  A0 00        	ldy #0					; starting at colum
001872  2  80 00        	bra @test_y
001874  2               
001874  2               @test_y:
001874  2               	; Y = how tile rows to test
001874  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely
001877  2  29 0F        	and #%00001111
001879  2  F0 06        	beq @yint				; if player is not on a multiple of 16 (tile size)
00187B  2               @yfloat:
00187B  2  98           	tya
00187C  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)	; test on (row -1) +1 ( x % 16 != 0) + column
00187E  2  A8           	tay
00187F  2  80 00        	bra @test_colum
001881  2               @yint:
001881  2               
001881  2               @test_colum:
001881  2  B1 02        	lda (r0L),y							; left side
001883  2  F0 0C        	beq @next_column
001885  2               
001885  2  84 30        	sty $30
001887  2  A8           	tay
001888  2  B9 4A 1D     	lda tiles_attributes,y
00188B  2  89 04        	bit #TILE_ATTR::SOLID_CEILING
00188D  2  D0 08        	bne @return1
00188F  2  A4 30        	ldy $30
001891  2               
001891  2               @next_column:
001891  2  CA           	dex
001892  2  F0 05        	beq @return
001894  2  C8           	iny
001895  2  80 EA        	bra @test_colum
001897  2               @return1:
001897  2  A9 01        	lda #01
001899  2               @return:
001899  2  60           	rts
00189A  2               
00189A  2               ;************************************************
00189A  2               ; check if the player feet is exactly on a slope tile
00189A  2               ;	modify: player_on_slop
00189A  2               ;	return: Z = slop
00189A  2               ;			Y = feet position tested (vs r0)
00189A  2               ;
00189A  2               check_player_on_slop:
00189A  2  9C 34 13     	stz player_on_slop				; no slope
00189D  2               
00189D  2  20 4F 17     	jsr bbox_coverage
0018A0  2               
0018A0  2  18           	clc
0018A1  2  98           	tya
0018A2  2  A6 04        	ldx r1L
0018A4  2  CA           	dex
0018A5  2               :
0018A5  2  69 20        	adc #LEVEL_TILES_WIDTH
0018A7  2  CA           	dex
0018A8  2  D0 FB        	bne :-
0018AA  2  A8           	tay								; position of the feet tiles
0018AB  2               
0018AB  2  AD 56 1E     	lda player0 + PLAYER::entity + Entity::levelx
0018AE  2  29 0F        	and #%00001111
0018B0  2  C9 08        	cmp #08
0018B2  2  10 01        	bpl :+
0018B4  2  C8           	iny
0018B5  2               :
0018B5  2               
0018B5  2               	; check if player feet is ON a slop
0018B5  2  B1 02        	lda (r0),y						; test ON feet level
0018B7  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
0018B9  2  F0 04        	beq @on_slope
0018BB  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
0018BD  2  D0 06        	bne @no_slope
0018BF  2               @on_slope:
0018BF  2  B1 02        	lda (r0),y						; test ON feet level
0018C1  2  8D 34 13     	sta player_on_slop
0018C4  2  60           	rts
0018C5  2               
0018C5  2               @no_slope:
0018C5  2  A9 00        	lda #0
0018C7  2  8D 34 13     	sta player_on_slop
0018CA  2  60           	rts
0018CB  2               
0018CB  2               ;************************************************
0018CB  2               ; check if the player feet is ABOVE a slope tile
0018CB  2               ;	input: 	Y = feet position tested (vs r0)
0018CB  2               ;	modify: player_on_slop
0018CB  2               ;	return: Z = slop
0018CB  2               ;
0018CB  2               is_player_above_slop:
0018CB  2  9C 34 13     	stz player_on_slop				; no slope
0018CE  2               
0018CE  2  98           	tya
0018CF  2  18           	clc
0018D0  2  69 20        	adc #LEVEL_TILES_WIDTH
0018D2  2  A8           	tay								; test BELOW feet level
0018D3  2  B1 02        	lda (r0),y
0018D5  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
0018D7  2  F0 0A        	beq @above_slope
0018D9  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
0018DB  2  F0 06        	beq @above_slope
0018DD  2               @no_slope:
0018DD  2  A9 00        	lda #0
0018DF  2  8D 34 13     	sta player_on_slop
0018E2  2  60           	rts
0018E3  2               @above_slope:
0018E3  2  8D 34 13     	sta player_on_slop
0018E6  2  60           	rts
0018E7  2               
0018E7  2               ;************************************************
0018E7  2               ; status to ignore while moving
0018E7  2               ;
0018E7  2               ignore_move_request:
0018E7  2  00           	.byte	00	;	STATUS_WALKING_IDLE
0018E8  2  00           	.byte	00	;	STATUS_WALKING
0018E9  2  02           	.byte	02	;	STATUS_CLIMBING
0018EA  2  02           	.byte	02	;	STATUS_CLIMBING_IDLE
0018EB  2  01           	.byte	01	;	STATUS_FALLING
0018EC  2  01           	.byte	01	;	STATUS_JUMPING
0018ED  2  01           	.byte	01	;	STATUS_JUMPING_IDLE
0018EE  2               
0018EE  2               ;************************************************
0018EE  2               ; Try to move player to the right, walk up if facing a slope
0018EE  2               ;
0018EE  2               move_right:
0018EE  2  AC 55 1E     	ldy player0 + PLAYER::entity + Entity::status
0018F1  2  B9 E7 18     	lda ignore_move_request, y
0018F4  2  F0 06        	beq @walk_right					; if 0 => can move
0018F6  2  C9 02        	cmp #02
0018F8  2  F0 6E        	beq @climb_right				; if 2 => has to climb
0018FA  2  80 6B        	bra @return1					; else block the move
0018FC  2               
0018FC  2               @walk_right:
0018FC  2  20 9A 18     	jsr check_player_on_slop
0018FF  2  D0 0A        	bne @no_collision
001901  2               
001901  2  20 CB 18     	jsr is_player_above_slop
001904  2  D0 05        	bne @no_collision
001906  2               
001906  2  20 C3 17     	jsr Player::check_collision_right
001909  2  D0 5C        	bne @return1					; block is collision on the right  and there is no slope on the right
00190B  2               
00190B  2               @no_collision:
00190B  2  A9 01        	lda #01
00190D  2  8D 60 1E     	sta player0 + PLAYER::entity + Entity::delta_x
001910  2               
001910  2               @set_walking_sprite:
001910  2  A9 01        	lda #SPRITE_FLIP_H
001912  2  8D 67 1E     	sta player0 + PLAYER::flip
001915  2  AC 54 1E     	ldy player0 + PLAYER::entity + Entity::spriteID
001918  2  20 01 0E     	jsr Sprite::set_flip				; force sprite to look right
00191B  2               
00191B  2  A9 01 8D 55  	m_status STATUS_WALKING
00191F  2  1E           
001920  2               
001920  2               	;change player sprite
001920  2  A9 03        	lda #Player::Sprites::LEFT
001922  2  CD 64 1E     	cmp player0 + PLAYER::frameID
001925  2  F0 08        	beq @move_x
001927  2               
001927  2  A9 03        	lda #Player::Sprites::LEFT
001929  2  8D 64 1E     	sta player0 + PLAYER::frameID
00192C  2  20 00 14     	jsr set_bitmap
00192F  2               
00192F  2               @move_x:
00192F  2  20 1A 14     	jsr Player::position_x_inc		; move the player in the level, and the screen layers and sprite
001932  2               
001932  2               	; if sitting on a slop
001932  2  AD 34 13     	lda player_on_slop
001935  2  F0 2D        	beq @set_position
001937  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
001939  2  F0 26        	beq @move_y_up
00193B  2               @try_move_y_dow:
00193B  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely
00193E  2  29 0F        	and #%00001111
001940  2  D0 1A        	bne @move_y_down
001942  2  AD 61 1E     	lda player0 + PLAYER::entity + Entity::collision_addr
001945  2  85 02        	sta r0L
001947  2  AD 62 1E     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
00194A  2  85 03        	sta r0H
00194C  2  A5 06        	lda r2L
00194E  2  18           	clc
00194F  2  69 41        	adc #(LEVEL_TILES_WIDTH * 2 + 1)	; check on the 2nd block
001951  2  A8           	tay
001952  2  B1 02        	lda (r0), y							; check if the tile below as an attribute SOLID_GROUND
001954  2  A8           	tay
001955  2  B9 4A 1D     	lda tiles_attributes,y
001958  2  89 01        	bit #TILE_ATTR::SOLID_GROUND
00195A  2  D0 61        	bne @return							; do not change Y if the tile below the player is a solid one
00195C  2               @move_y_down:
00195C  2  20 C5 14     	jsr position_y_inc
00195F  2  80 03        	bra @set_position
001961  2               @move_y_up:
001961  2  20 36 15     	jsr position_y_dec
001964  2               
001964  2               @set_position:
001964  2  20 F1 13     	jsr position_set
001967  2               @return1:
001967  2  60           	rts
001968  2               
001968  2               @climb_right:
001968  2  20 C3 17     	jsr Player::check_collision_right
00196B  2  F0 05        	beq @climb_right_1
00196D  2  C9 04        	cmp #TILE_SOLID_LADER
00196F  2  F0 01        	beq @climb_right_1
001971  2  60           	rts
001972  2               @climb_right_1:
001972  2  20 4F 17     	jsr bbox_coverage
001975  2               @get_tile:
001975  2  B1 02        	lda (r0),y
001977  2  F0 0E        	beq @no_grab					; no tile on right
001979  2  85 31        	sta $31
00197B  2  84 30        	sty $30
00197D  2  A8           	tay
00197E  2  B9 4A 1D     	lda tiles_attributes,y
001981  2  89 08        	bit #TILE_ATTR::GRABBING
001983  2  D0 08        	bne @climb_right_2				; tile on right with a GRAB attribute
001985  2  A4 30        	ldy $30
001987  2               @no_grab:							; test the tile on the right on next line
001987  2  C8           	iny
001988  2  CA           	dex
001989  2  D0 EA        	bne @get_tile
00198B  2  80 1E        	bra @climb_right_drop			; no grab tile on the right of the player
00198D  2               @climb_right_2:
00198D  2  A5 31        	lda $31							; tile index with grab attribute
00198F  2  C9 05        	cmp #TILE_LEDGE
001991  2  D0 04        	bne @set_climb_sprite
001993  2               @set_hang_sprite:
001993  2  A9 09        	lda #Player::Sprites::HANG
001995  2  80 02        	bra @next
001997  2               @set_climb_sprite:
001997  2  A9 06        	lda #Player::Sprites::CLIMB
001999  2               @next:
001999  2  8D 64 1E     	sta player0 + PLAYER::frameID
00199C  2  20 00 14     	jsr set_bitmap
00199F  2  A9 02 8D 55  	m_status STATUS_CLIMBING
0019A3  2  1E           
0019A4  2  20 1A 14     	jsr Player::position_x_inc		; move the player sprite, if the
0019A7  2  20 F1 13     	jsr position_set
0019AA  2  60           	rts
0019AB  2               @climb_right_drop:
0019AB  2  A9 01 8D 55  	m_status STATUS_WALKING
0019AF  2  1E           
0019B0  2  A9 03 8D 64  	SET_SPRITE Player::Sprites::LEFT, 1
0019B4  2  1E A9 01 8D  
0019B8  2  65 1E 20 00  
0019BD  2               
0019BD  2               @return:
0019BD  2  60           	rts
0019BE  2               
0019BE  2               ;************************************************
0019BE  2               ; try to move the player to the left
0019BE  2               ;
0019BE  2               move_left:
0019BE  2  AC 55 1E     	ldy player0 + PLAYER::entity + Entity::status
0019C1  2  B9 E7 18     	lda ignore_move_request, y
0019C4  2  F0 06        	beq @walk_left					; if 0 => can move
0019C6  2  C9 02        	cmp #02
0019C8  2  F0 6E        	beq @climb_left				; if 2 => has to climb
0019CA  2  80 6B        	bra @return					; else block the move
0019CC  2               
0019CC  2               @walk_left:
0019CC  2  20 9A 18     	jsr check_player_on_slop
0019CF  2  D0 0A        	bne @no_collision				; ignore right collision left if on a slope
0019D1  2               
0019D1  2  20 CB 18     	jsr is_player_above_slop
0019D4  2  D0 05        	bne @no_collision
0019D6  2               
0019D6  2  20 DF 17     	jsr Player::check_collision_left
0019D9  2  D0 5C        	bne @return						; block is collision on the right  and there is no slope on the right
0019DB  2               
0019DB  2               @no_collision:
0019DB  2  A9 FF        	lda #$ff
0019DD  2  8D 60 1E     	sta player0 + PLAYER::entity + Entity::delta_x
0019E0  2               
0019E0  2               @set_walking_sprite:
0019E0  2  A9 00        	lda #SPRITE_FLIP_NONE
0019E2  2  8D 67 1E     	sta player0 + PLAYER::flip
0019E5  2  AC 54 1E     	ldy player0 + PLAYER::entity + Entity::spriteID
0019E8  2  20 01 0E     	jsr Sprite::set_flip				; force sprite to loop right
0019EB  2               
0019EB  2  A9 01 8D 55  	m_status STATUS_WALKING
0019EF  2  1E           
0019F0  2               
0019F0  2  A9 03        	lda #Player::Sprites::LEFT
0019F2  2  CD 64 1E     	cmp player0 + PLAYER::frameID
0019F5  2  F0 08        	beq @move_x
0019F7  2               
0019F7  2               	;change player sprite
0019F7  2  A9 03        	lda #Player::Sprites::LEFT
0019F9  2  8D 64 1E     	sta player0 + PLAYER::frameID
0019FC  2  20 00 14     	jsr set_bitmap
0019FF  2               
0019FF  2               @move_x:
0019FF  2  20 71 14     	jsr Player::position_x_dec
001A02  2               
001A02  2  AD 34 13     	lda player_on_slop				; if walking a slop also increase Y
001A05  2  F0 2D        	beq @set_position
001A07  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
001A09  2  F0 26        	beq @move_y_up
001A0B  2               @try_move_y_dow:
001A0B  2  AD 58 1E     	lda player0 + PLAYER::entity + Entity::levely
001A0E  2  29 0F        	and #%00001111
001A10  2  D0 1A        	bne @move_y_down
001A12  2  AD 61 1E     	lda player0 + PLAYER::entity + Entity::collision_addr
001A15  2  85 02        	sta r0L
001A17  2  AD 62 1E     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
001A1A  2  85 03        	sta r0H
001A1C  2  A5 06        	lda r2L
001A1E  2  18           	clc
001A1F  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)
001A21  2  A8           	tay
001A22  2  B1 02        	lda (r0), y							; check if the tile below as an attribute TILE_SOLID_GROUND
001A24  2  A8           	tay
001A25  2  B9 4A 1D     	lda tiles_attributes,y
001A28  2  89 01        	bit #TILE_ATTR::SOLID_GROUND
001A2A  2  D0 0B        	bne @return							; do not change Y if the tile below the player is a solid one
001A2C  2               @move_y_down:
001A2C  2  20 C5 14     	jsr position_y_inc
001A2F  2  80 03        	bra @set_position
001A31  2               @move_y_up:
001A31  2  20 36 15     	jsr position_y_dec
001A34  2               
001A34  2               @set_position:
001A34  2  20 F1 13     	jsr position_set
001A37  2               
001A37  2               @return:
001A37  2  60           	rts
001A38  2               
001A38  2               @climb_left:
001A38  2  20 DF 17     	jsr Player::check_collision_left
001A3B  2  F0 01        	beq @climb_left_1
001A3D  2  60           	rts								; collision on left, block the move
001A3E  2               @climb_left_1:
001A3E  2  20 4F 17     	jsr bbox_coverage				; what tiles is the player covering
001A41  2               @get_tile:
001A41  2  B1 02        	lda (r0),y
001A43  2  F0 0E        	beq @no_grab					; no tile on right
001A45  2  85 31        	sta $31
001A47  2  84 30        	sty $30
001A49  2  A8           	tay
001A4A  2  B9 4A 1D     	lda tiles_attributes,y
001A4D  2  89 08        	bit #TILE_ATTR::GRABBING
001A4F  2  D0 08        	bne @climb_left_2				; tile on left with a GRAB attribute
001A51  2  A4 30        	ldy $30
001A53  2               @no_grab:							; test the tile on the left on next line
001A53  2  C8           	iny
001A54  2  CA           	dex
001A55  2  D0 EA        	bne @get_tile
001A57  2  80 1E        	bra @climb_left_drop			; no grab tile on the right of the player
001A59  2               @climb_left_2:
001A59  2  A5 31        	lda $31							; tile index with grab attribute
001A5B  2  C9 05        	cmp #TILE_LEDGE
001A5D  2  D0 04        	bne @set_climb_sprite
001A5F  2               @set_hang_sprite:
001A5F  2  A9 09        	lda #Player::Sprites::HANG
001A61  2  80 02        	bra @next
001A63  2               @set_climb_sprite:
001A63  2  A9 06        	lda #Player::Sprites::CLIMB
001A65  2               @next:
001A65  2  8D 64 1E     	sta player0 + PLAYER::frameID
001A68  2  20 00 14     	jsr set_bitmap
001A6B  2  A9 02 8D 55  	m_status STATUS_CLIMBING
001A6F  2  1E           
001A70  2  20 71 14     	jsr Player::position_x_dec		; move the player sprite, if the
001A73  2  20 F1 13     	jsr position_set
001A76  2  60           	rts
001A77  2               @climb_left_drop:					; no ladder to stick to
001A77  2  A9 01 8D 55  	m_status STATUS_WALKING
001A7B  2  1E           
001A7C  2  A9 03 8D 64  	SET_SPRITE Player::Sprites::LEFT, 1
001A80  2  1E A9 01 8D  
001A84  2  65 1E 20 00  
001A89  2  60           	rts
001A8A  2               
001A8A  2               ;************************************************
001A8A  2               ; try to move the player down (crouch, hide, move down a ladder)
001A8A  2               ;
001A8A  2               move_down:
001A8A  2  AD 55 1E     	lda player0 + PLAYER::entity + Entity::status
001A8D  2  C9 04        	cmp #STATUS_FALLING
001A8F  2  D0 01        	bne @try_move_down						; cannot move when falling
001A91  2  60           	rts
001A92  2               
001A92  2               @try_move_down:
001A92  2               	; custom collision down
001A92  2  AD 61 1E     	lda player0 + PLAYER::entity + Entity::collision_addr
001A95  2  85 02        	sta r0L
001A97  2  AD 62 1E     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
001A9A  2  85 03        	sta r0H
001A9C  2               
001A9C  2  20 4F 17     	jsr bbox_coverage
001A9F  2  8E 35 13     	stx ladders						; width of the player in tiles = number of ladders to find below
001AA2  2  98           	tya
001AA3  2  18           	clc
001AA4  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)	; check below the player
001AA6  2  A8           	tay
001AA7  2               
001AA7  2               @test_colum:
001AA7  2  B1 02        	lda (r0L),y
001AA9  2  C9 04        	cmp #TILE_SOLID_LADER
001AAB  2  D0 05        	bne @check_solid_ground
001AAD  2               @ladder_down:
001AAD  2  CE 35 13     	dec ladders
001AB0  2  80 0C        	bra @next_column
001AB2  2               @check_solid_ground:
001AB2  2  84 30        	sty $30
001AB4  2  A8           	tay
001AB5  2  B9 4A 1D     	lda tiles_attributes,y
001AB8  2  89 01        	bit #TILE_ATTR::SOLID_GROUND
001ABA  2  D0 45        	bne @cannot_move_down
001ABC  2  A4 30        	ldy $30
001ABE  2               @next_column:
001ABE  2  CA           	dex
001ABF  2  F0 03        	beq @end
001AC1  2  C8           	iny
001AC2  2  80 E3        	bra @test_colum
001AC4  2               @end:
001AC4  2               
001AC4  2  AD 35 13     	lda ladders
001AC7  2  F0 1C        	beq @move_down						; correct number of ladder tiles below the player
001AC9  2               
001AC9  2               	; if there player is covering ANY ladders (accros the boundingbox)
001AC9  2  A4 06        	ldy r2L
001ACB  2               @check_line:							; already climbing down is player grabbing no ladder
001ACB  2  A6 05        	ldx r1H
001ACD  2               @check_row:
001ACD  2  B1 02        	lda (r0L),y
001ACF  2  C9 04        	cmp #TILE_SOLID_LADER
001AD1  2  F0 12        	beq @move_down
001AD3  2  C8           	iny
001AD4  2  CA           	dex
001AD5  2  D0 F6        	bne @check_row
001AD7  2  C6 04        	dec r1L
001AD9  2  F0 26        	beq @cannot_move_down
001ADB  2               
001ADB  2  98           	tya
001ADC  2  18           	clc
001ADD  2  69 20        	adc #LEVEL_TILES_WIDTH
001ADF  2  38           	sec
001AE0  2  E5 05        	sbc r1H
001AE2  2  A8           	tay
001AE3  2  80 E6        	bra @check_line
001AE5  2               
001AE5  2               @move_down:
001AE5  2  20 C5 14     	jsr Player::position_y_inc		; move down the ladder
001AE8  2  20 F1 13     	jsr position_set
001AEB  2               
001AEB  2  A9 02 8D 55  	m_status STATUS_CLIMBING
001AEF  2  1E           
001AF0  2               
001AF0  2  A9 06        	lda #Player::Sprites::CLIMB
001AF2  2  CD 64 1E     	cmp player0 + PLAYER::frameID
001AF5  2  D0 01        	bne @change_sprite
001AF7  2  60           	rts
001AF8  2               
001AF8  2               @change_sprite:
001AF8  2               	;change player sprite
001AF8  2  A9 06        	lda #Player::Sprites::CLIMB
001AFA  2  8D 64 1E     	sta player0 + PLAYER::frameID
001AFD  2  20 00 14     	jsr set_bitmap
001B00  2  60           	rts
001B01  2               
001B01  2               @cannot_move_down:
001B01  2  A9 00        	lda #STATUS_WALKING_IDLE
001B03  2  8D 55 1E     	sta player0 + PLAYER::entity + Entity::status
001B06  2  A9 01        	lda #01
001B08  2  8D 65 1E     	sta player0 + PLAYER::frame
001B0B  2  20 00 14     	jsr set_bitmap
001B0E  2  9C 60 1E     	stz player0 + PLAYER::entity + Entity::delta_x
001B11  2  60           	rts
001B12  2               
001B12  2               ;************************************************
001B12  2               ; try to move the player up (move up a ladder)
001B12  2               ;	only climb a ladder if the 16 pixels mid-X are fully enclosed in the ladder
001B12  2               ;	modify: r0, r1, r2
001B12  2               ;
001B12  2               move_up:
001B12  2  AD 55 1E     	lda player0 + PLAYER::entity + Entity::status
001B15  2  C9 04        	cmp #STATUS_FALLING
001B17  2  D0 01        	bne @try_move_up				; cannot move when falling
001B19  2  60           	rts
001B1A  2               @try_move_up:
001B1A  2               	; custom collision up
001B1A  2  20 4F 17     	jsr bbox_coverage
001B1D  2  8E 35 13     	stx ladders						; width of the player in tiles = number of ladders to find below
001B20  2               
001B20  2               	; check the situation ABOVE the player
001B20  2  38           	sec
001B21  2  AD 61 1E     	lda player0 + PLAYER::entity + Entity::collision_addr
001B24  2  E9 20        	sbc #LEVEL_TILES_WIDTH
001B26  2  85 02        	sta r0L
001B28  2  AD 62 1E     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
001B2B  2  E9 00        	sbc #0
001B2D  2  85 03        	sta r0H
001B2F  2               
001B2F  2               	; if there the right numbers of ladder tiles above the player
001B2F  2               @test_colum:
001B2F  2  B1 02        	lda (r0L),y
001B31  2  C9 04        	cmp #TILE_SOLID_LADER
001B33  2  D0 05        	bne @check_solid_ceiling
001B35  2  CE 35 13     	dec ladders
001B38  2  80 0C        	bra @next_column
001B3A  2               @check_solid_ceiling:
001B3A  2  84 30        	sty $30
001B3C  2  A8           	tay
001B3D  2  B9 4A 1D     	lda tiles_attributes,y
001B40  2  89 04        	bit #TILE_ATTR::SOLID_CEILING
001B42  2  D0 4F        	bne @cannot_move_up
001B44  2  A4 30        	ldy $30
001B46  2               @next_column:
001B46  2  CA           	dex
001B47  2  F0 03        	beq @end
001B49  2  C8           	iny
001B4A  2  80 E3        	bra @test_colum
001B4C  2               @end:
001B4C  2               
001B4C  2  AD 35 13     	lda ladders
001B4F  2  F0 26        	beq @climb_down						; correct number of ladder tiles above the player
001B51  2               
001B51  2               	; if there player is covering ANY LADER (accros the boundingbox)
001B51  2  AD 61 1E     	lda player0 + PLAYER::entity + Entity::collision_addr
001B54  2  85 02        	sta r0L
001B56  2  AD 62 1E     	lda player0 + PLAYER::entity + Entity::collision_addr + 1
001B59  2  85 03        	sta r0H
001B5B  2               
001B5B  2  A4 06        	ldy r2L
001B5D  2               @check_line:							; already climbing up is player grabbing no ladder
001B5D  2  A6 05        	ldx r1H
001B5F  2               @check_row:
001B5F  2  B1 02        	lda (r0L),y
001B61  2  C9 04        	cmp #TILE_SOLID_LADER
001B63  2  F0 12        	beq @climb_down
001B65  2  C8           	iny
001B66  2  CA           	dex
001B67  2  D0 F6        	bne @check_row
001B69  2  C6 04        	dec r1L
001B6B  2  F0 26        	beq @cannot_move_up
001B6D  2               
001B6D  2  98           	tya
001B6E  2  18           	clc
001B6F  2  69 20        	adc #LEVEL_TILES_WIDTH
001B71  2  38           	sec
001B72  2  E5 05        	sbc r1H
001B74  2  A8           	tay
001B75  2  80 E6        	bra @check_line
001B77  2               
001B77  2               @climb_down:
001B77  2  20 36 15     	jsr Player::position_y_dec		; move up the ladder
001B7A  2  20 F1 13     	jsr position_set
001B7D  2               
001B7D  2  A9 02 8D 55  	m_status STATUS_CLIMBING
001B81  2  1E           
001B82  2               
001B82  2  A9 06        	lda #Player::Sprites::CLIMB
001B84  2  CD 64 1E     	cmp player0 + PLAYER::frameID
001B87  2  D0 01        	bne @set_sprite
001B89  2  60           	rts
001B8A  2               @set_sprite:						;change player sprite
001B8A  2  A9 06        	lda #Player::Sprites::CLIMB
001B8C  2  8D 64 1E     	sta player0 + PLAYER::frameID
001B8F  2  20 00 14     	jsr set_bitmap
001B92  2  60           	rts
001B93  2               
001B93  2               @cannot_move_up:
001B93  2  A9 00        	lda #STATUS_WALKING_IDLE
001B95  2  8D 55 1E     	sta player0 + PLAYER::entity + Entity::status
001B98  2  60           	rts
001B99  2               
001B99  2               ;************************************************
001B99  2               ; jump
001B99  2               ;	A = delta X value
001B99  2               ;
001B99  2               jump:
001B99  2  AA           	tax
001B9A  2  AC 55 1E         ldy player0 + PLAYER::entity + Entity::status
001B9D  2  B9 E7 18     	lda ignore_move_request,y
001BA0  2  D0 17        	bne @return
001BA2  2  8E 60 1E     	stx player0 + PLAYER::entity + Entity::delta_x
001BA5  2               
001BA5  2               	; ensure there is no ceiling over the player
001BA5  2  20 4E 18     	jsr check_collision_up
001BA8  2  D0 0F        	bne @return
001BAA  2               
001BAA  2  A9 0A        	lda #JUMP_LO_TICKS
001BAC  2  8D 5E 1E     	sta player0 + PLAYER::entity + Entity::falling_ticks	; decrease  HI every 10 refresh
001BAF  2  A9 02        	lda #JUMP_HI_TICKS
001BB1  2  8D 5F 1E     	sta player0 + PLAYER::entity + Entity::falling_ticks	+ 1
001BB4  2               
001BB4  2  A9 05 8D 55  	m_status STATUS_JUMPING
001BB8  2  1E           
001BB9  2               @return:
001BB9  2  60           	rts
001BBA  2               
001BBA  2               ;************************************************
001BBA  2               ; grab the object if front of the player, if there is an object
001BBA  2               ;
001BBA  2               grab_object:
001BBA  2  AD 67 1E     	lda player0 + PLAYER::flip
001BBD  2  D0 04        	bne @right
001BBF  2               @left:
001BBF  2  A9 0A        	lda #(02 | 08)
001BC1  2  80 02        	bra @cont
001BC3  2               @right:
001BC3  2  A9 06        	lda #(02 | 04)
001BC5  2               @cont:
001BC5  2  AE 54 1E     	ldx player0 + PLAYER::entity + Entity::spriteID
001BC8  2  20 CF 0E     	jsr Sprite::precheck_collision	; get the frameID in Y
001BCB  2  30 22        	bmi @return						; no object
001BCD  2               
001BCD  2  20 D1 11     	jsr Objects::get_by_spriteID	; find the object that has frameID Y
001BD0  2  C0 FF        	cpy #$ff
001BD2  2  F0 1B        	beq @return						; no object with this ID
001BD4  2               
001BD4  2  98           	tya
001BD5  2  69 0F        	adc #Objects::Object::imageID
001BD7  2  98           	tya
001BD8  2  B1 08        	lda (r3), y
001BDA  2  89 01        	bit #Objects::Attribute::GRAB
001BDC  2  F0 11        	beq @return						; object cannot be grabbed
001BDE  2               
001BDE  2  84 50        	sty PLAYER_ZP					; save the pointer to the grabbed object
001BE0  2  18           	clc
001BE1  2  A5 08        	lda r3L
001BE3  2  65 50        	adc PLAYER_ZP
001BE5  2  8D 68 1E     	sta player0 + PLAYER::grab_object
001BE8  2  A5 09        	lda r3H
001BEA  2  69 00        	adc #00
001BEC  2  8D 69 1E     	sta player0 + PLAYER::grab_object + 1
001BEF  2               
001BEF  2               @return:
001BEF  2  60           	rts
001BF0  2               
001BF0  2               ;************************************************
001BF0  2               ; release the object the player is moving
001BF0  2               ;
001BF0  2               release_object:
001BF0  2  9C 68 1E     	stz player0 + PLAYER::grab_object
001BF3  2  9C 69 1E     	stz player0 + PLAYER::grab_object + 1
001BF6  2  60           	rts
001BF7  2               
001BF7  2               .endscope
001BF7  2               
001BF7  1               
001BF7  1               ;-----------------------------------------------------------------------------
001BF7  1               ;/////////////////////////////////////////////////////////////////////////////
001BF7  1               ; main code
001BF7  1               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
001BF7  1               ;-----------------------------------------------------------------------------
001BF7  1               
001BF7  1  00 00        objects: .word 0
001BF9  1               
001BF9  1               start:
001BF9  1               	; 320x240
001BF9  1  A9 40        	lda #64
001BFB  1  8D 2A 9F     	sta veradchscale
001BFE  1  8D 2B 9F     	sta veradcvscale
001C01  1               
001C01  1               	; activate layer0
001C01  1  A9 71        	lda #%01110001
001C03  1               ;	and #(255-VERA_LAYER0)
001C03  1               ;	ora #(VERA_LAYER1)             ; Read Video Register
001C03  1  8D 29 9F     	sta veradcvideo             ; Store new value to Video Register
001C06  1               
001C06  1               	;---------------------------------
001C06  1               	; load tiles file into vram
001C06  1               	;---------------------------------
001C06  1  20 45 08     	jsr Tiles::load_static
001C09  1               
001C09  1               	;---------------------------------
001C09  1               	;---------------------------------
001C09  1               	; load tilemaps into vram
001C09  1               	;---------------------------------
001C09  1  20 66 12     	jsr Tilemap::load
001C0C  1               
001C0C  1               	; load animated tiles into ram
001C0C  1               	;---------------------------------
001C0C  1  20 8F 08     	jsr Tiles::load_anim
001C0F  1               
001C0F  1               	;---------------------------------
001C0F  1               	; load sprite 0,1,2 into vram
001C0F  1               	;---------------------------------
001C0F  1               load_sprites:
001C0F  1               	; prepare VERA sprites
001C0F  1  20 6A 0C     	jsr Sprite::init_addr_table
001C12  1               
001C12  1  A9 00 85 02  	LOAD_r0 (::VRAM_tiles + tiles * tile_size)	; base for the sprites
001C16  1  A9 41 85 03  
001C1A  1  20 37 13     	jsr Player::init
001C1D  1               
001C1D  1               	;---------------------------------
001C1D  1               	; load objects list into ram
001C1D  1               	;---------------------------------
001C1D  1  20 D0 10     	jsr Objects::init
001C20  1               
001C20  1               setirq:
001C20  1                  ; backup default RAM IRQ vector
001C20  1  AD 14 03        lda IRQVec
001C23  1  8D 47 1D        sta default_irq_vector
001C26  1  AD 15 03        lda IRQVec+1
001C29  1  8D 48 1D        sta default_irq_vector+1
001C2C  1               
001C2C  1                  ; overwrite RAM IRQ vector with custom handler address
001C2C  1  78              sei ; disable IRQ while vector is changing
001C2D  1  A9 44           lda #<custom_irq_handler
001C2F  1  8D 14 03        sta IRQVec
001C32  1  A9 1C           lda #>custom_irq_handler
001C34  1  8D 15 03        sta IRQVec+1
001C37  1  AD 26 9F        lda veraien
001C3A  1  09 01           ora #VERA_VSYNC_BIT ; make VERA only generate VSYNC IRQs
001C3C  1  8D 26 9F        sta veraien
001C3F  1  58              cli ; enable IRQ now that vector is properly set
001C40  1               
001C40  1               mainloop:
001C40  1  CB           	wai
001C41  1  80 FD        	bra mainloop
001C43  1               
001C43  1  60           	rts
001C44  1               
001C44  1               ;-----------------------------------------------------------------------------
001C44  1               ;/////////////////////////////////////////////////////////////////////////////
001C44  1               ; deal with IRQ"s
001C44  1               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
001C44  1               ;-----------------------------------------------------------------------------
001C44  1               custom_irq_handler:
001C44  1  AD 27 9F     	lda veraisr
001C47  1  AA           	tax
001C48  1  29 04        	and #VERA_SPRCOL_BIT
001C4A  1  F0 0B        	beq @check_vsync
001C4C  1               
001C4C  1               @sprite_collision:
001C4C  1  8D 27 9F     	sta veraisr						; acknowled the SPRCOL IRQ
001C4F  1  8A           	txa
001C50  1  4A           	lsr
001C51  1  4A           	lsr
001C52  1  4A           	lsr
001C53  1  4A           	lsr								; extract the collision mask (4:7)
001C54  1  20 20 0E     	jsr Sprite::register_collision
001C57  1               
001C57  1               @check_vsync:
001C57  1  8A           	txa
001C58  1  29 01        	and #VERA_VSYNC_BIT
001C5A  1  F0 6F        	beq @continue
001C5C  1               
001C5C  1               @frame_update:
001C5C  1  8D 27 9F     	sta veraisr						; acknowled the VSYNC IRQ
001C5F  1               
001C5F  1               	;---------------------------------
001C5F  1               	; animate sprite
001C5F  1               	;---------------------------------
001C5F  1  20 99 15     	jsr Player::animate
001C62  1               
001C62  1               	;---------------------------------
001C62  1               	; swap animated tiles
001C62  1               	;---------------------------------
001C62  1  20 39 09     	jsr Tiles::animate
001C65  1               
001C65  1               	;---------------------------------
001C65  1               	; sprite collisions management
001C65  1               	;---------------------------------
001C65  1  20 A7 0E     	jsr Sprite::check_irq_collision
001C68  1               
001C68  1               	;---------------------------------
001C68  1               	; player physics
001C68  1               	;---------------------------------
001C68  1  20 F4 15     	jsr Player::physics
001C6B  1               
001C6B  1               	;---------------------------------
001C6B  1               	; check keyboard
001C6B  1               	;---------------------------------
001C6B  1               @check_keyboard:
001C6B  1               	; get fake-joystick data from keyboard
001C6B  1  A9 00        	lda #0
001C6D  1  20 56 FF     	jsr joystick_get
001C70  1  8D 50 1D     	sta joystick_data
001C73  1  8E 51 1D     	stx joystick_data + 1
001C76  1               
001C76  1               	; get real joystick data
001C76  1  A9 01        	lda #1
001C78  1  20 56 FF     	jsr joystick_get
001C7B  1  C0 00        	cpy #0
001C7D  1  D0 0D        	bne @check_buttons
001C7F  1               
001C7F  1               	; if there is a joystick, mix the data
001C7F  1  2D 50 1D     	and joystick_data
001C82  1  8D 50 1D     	sta joystick_data
001C85  1               
001C85  1  8A           	txa
001C86  1  2D 51 1D     	and joystick_data + 1
001C89  1  8D 51 1D     	sta joystick_data + 1
001C8C  1               
001C8C  1               @check_buttons:
001C8C  1               	; check button A press/release
001C8C  1  4D 53 1D     	eor joystick_data_old + 1
001C8F  1               
001C8F  1  89 80        	bit #JOY_A
001C91  1  F0 10        	beq @save_data				; no change for the A
001C93  1               
001C93  1  AD 51 1D     	lda joystick_data + 1
001C96  1  89 80        	bit #JOY_A
001C98  1  D0 06        	bne @grab
001C9A  1               @release:
001C9A  1  DB           	stp
001C9B  1  20 F0 1B     	jsr Player::release_object
001C9E  1  80 03        	bra @save_data
001CA0  1               @grab:
001CA0  1  20 BA 1B     	jsr Player::grab_object
001CA3  1               @save_data:
001CA3  1  AD 51 1D     	lda joystick_data + 1
001CA6  1  8D 53 1D     	sta joystick_data_old + 1
001CA9  1               
001CA9  1               ;  .A, byte 0:      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
001CA9  1               ;              NES  | A | B |SEL|STA|UP |DN |LT |RT |
001CA9  1               ;              SNES | B | Y |SEL|STA|UP |DN |LT |RT |
001CA9  1               ;
001CA9  1               ;  .X, byte 1:      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
001CA9  1               ;              NES  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | X |
001CA9  1               ;              SNES | A | X | L | R | 1 | 1 | 1 | 1 |
001CA9  1               ;  .Y, byte 2:
001CA9  1               ;              $00 = joystick present
001CA9  1               ;              $FF = joystick not present
001CA9  1               
001CA9  1               @other_check:
001CA9  1  AD 50 1D     	lda joystick_data
001CAC  1               
001CAC  1  89 81        	bit #(JOY_RIGHT|JOY_B)
001CAE  1  F0 1E        	beq @jump_right
001CB0  1  89 82        	bit #(JOY_LEFT|JOY_B)
001CB2  1  F0 21        	beq @jump_left
001CB4  1  89 01        	bit #JOY_RIGHT
001CB6  1  F0 29        	beq @joystick_right
001CB8  1  89 02        	bit #JOY_LEFT
001CBA  1  F0 20        	beq @joystick_left
001CBC  1  89 04        	bit #JOY_DOWN
001CBE  1  F0 2B        	beq @movedown
001CC0  1  89 08        	bit #JOY_UP
001CC2  1  F0 22        	beq @moveup
001CC4  1  89 80        	bit #JOY_B
001CC6  1  F0 28        	beq @jump
001CC8  1               
001CC8  1  20 DB 15     	jsr Player::set_idle
001CCB  1               
001CCB  1               @continue:
001CCB  1                  ; continue to default IRQ handler
001CCB  1  6C 47 1D        jmp (default_irq_vector)
001CCE  1                  ; RTI will happen after jump
001CCE  1               
001CCE  1               @jump_right:
001CCE  1  A9 01        	lda #$01					; jump right
001CD0  1  20 99 1B     	jsr Player::jump
001CD3  1  80 F6        	bra @continue
001CD5  1               
001CD5  1               @jump_left:
001CD5  1  A9 FF        	lda #$ff					; jump left
001CD7  1  20 99 1B     	jsr Player::jump
001CDA  1  80 EF        	bra @continue
001CDC  1               
001CDC  1               @joystick_left:
001CDC  1  20 BE 19     	jsr Player::move_left
001CDF  1  80 EA        	bra @continue
001CE1  1               
001CE1  1               @joystick_right:
001CE1  1  20 EE 18     	jsr Player::move_right
001CE4  1  80 E5        	bra @continue
001CE6  1               
001CE6  1               @moveup:
001CE6  1  20 12 1B     	jsr Player::move_up
001CE9  1  80 E0        	bra @continue
001CEB  1               
001CEB  1               @movedown:
001CEB  1  20 8A 1A     	jsr Player::move_down
001CEE  1  80 DB        	bra @continue
001CF0  1               
001CF0  1               @jump:
001CF0  1  A9 00        	lda #0				; jump up
001CF2  1  20 99 1B     	jsr Player::jump
001CF5  1  80 D4        	bra @continue
001CF7  1               
001CF7  1               .segment "DATA"
001CF7  1               .include "tilemap.inc"
001CF7  2               map:
001CF7  2  20 20        	.byte 32,32
001CF9  2  6C 65 76 65  fslevel: .literal "level.bin"
001CFD  2  6C 2E 62 69  
001D01  2  6E           
001D02  2               fslevel_end:
001D02  2  73 63 65 6E  fsbackground: .literal "scenery.bin"
001D06  2  65 72 79 2E  
001D0A  2  62 69 6E     
001D0D  2               fsbackground_end:
001D0D  2  63 6F 6C 6C  fscollision: .literal "collision.bin"
001D11  2  69 73 69 6F  
001D15  2  6E 2E 62 69  
001D1A  2               fscollision_end:
001D1A  2  6F 62 6A 65  fsobjects: .literal "objects.bin"
001D1E  2  63 74 73 2E  
001D22  2  62 69 6E     
001D25  2               fsobjects_end:
001D25  2  73 70 72 69  fssprites1: .literal "sprites1.bin"
001D29  2  74 65 73 31  
001D2D  2  2E 62 69 6E  
001D31  2               fssprites1_end:
001D31  2               tileset:
001D31  2  10 10        	.byte 16,16
001D33  2               tiles = 49
001D33  2               tile_size = 256
001D33  2  74 69 6C 65  fstile: .literal "tiles.bin"
001D37  2  73 2E 62 69  
001D3B  2  6E           
001D3C  2               fstileend:
001D3C  2               
001D3C  1               .include "sprite.inc"
001D3C  2  73 70 72 69  fssprite:	.literal "sprites.bin"
001D40  2  74 65 73 2E  
001D44  2  62 69 6E     
001D47  2               fsspriteend:
001D47  2               sprites = 12
001D47  2               sprite_size = 1024
001D47  2               
001D47  1               
001D47  1  00 00        default_irq_vector: .addr 0
001D49  1  00           trigger_debug: .byte 0
001D4A  1               tiles_attributes:
001D4A  1  00           	.byte %00000000	;	TILE_NO_COLLISION
001D4B  1  07           	.byte %00000111	;	TILE_SOLID_GROUND
001D4C  1  04           	.byte %00000100	;	TILE_SOLD_SLOP_LEFT
001D4D  1  04           	.byte %00000100	;	TILE_SOLD_SLOP_RIGHT
001D4E  1  09           	.byte %00001001	;	TILE_SOLID_LADER
001D4F  1  09           	.byte %00001001	;	TILE_LEDGE
001D50  1               
001D50  1               .segment "BSS"
001D50  1  00 00        	joystick_data: .byte 0, 0
001D52  1  00 00        	joystick_data_old: .byte 0, 0
001D54  1  xx xx xx xx  	sprites_table: .res 256		; VERA memory of each of the 256 sprites
001D58  1  xx xx xx xx  
001D5C  1  xx xx xx xx  
001E54  1  xx xx xx xx  	player0: .tag PLAYER
001E58  1  xx xx xx xx  
001E5C  1  xx xx xx xx  
001E54  1               
