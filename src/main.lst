ca65 V2.19 - Git e4f01a2
Main file   : main.asm
Current file: main.asm

000000r 1               .org $080D
00080D  1               .segment "STARTUP"
00080D  1               .segment "INIT"
00080D  1               .segment "ONCE"
00080D  1               .segment "CODE"
00080D  1               
00080D  1  4C 54 18        jmp start
000810  1               
000810  1               .macro LOAD_r0 addr16
000810  1               	lda #<addr16
000810  1               	sta r0L
000810  1               	lda #>addr16
000810  1               	sta r0H
000810  1               .endmacro
000810  1               .macro SAVE_r0 addr16
000810  1               	lda r0L
000810  1               	sta addr16
000810  1               	lda r0H
000810  1               	sta addr16 + 1
000810  1               .endmacro
000810  1               .macro LOAD_r1 addr16
000810  1               	lda #<addr16
000810  1               	sta r1L
000810  1               	lda #>addr16
000810  1               	sta r1H
000810  1               .endmacro
000810  1               .macro LOAD_r3 addr16
000810  1               	lda #<addr16
000810  1               	sta r3L
000810  1               	lda #>addr16
000810  1               	sta r3H
000810  1               .endmacro
000810  1               
000810  1               .include "x16.inc"
000810  2               .ifndef X16_INC
000810  2               X16_INC = 1
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Commodore 64 API
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               ; Channel I/O
000810  2               SETMSG		= $FF90 ; set verbosity
000810  2               READST		= $FFB7 ; return status byte
000810  2               SETLFS		= $FFBA ; set LA, FA and SA
000810  2               SETNAM		= $FFBD ; set filename
000810  2               OPEN		= $FFC0 ; open a channel
000810  2               CLOSE		= $FFC3 ; close a channel
000810  2               CHKIN		= $FFC6 ; set channel for character input
000810  2               CHKOUT		= $FFC9 ; set channel for character output
000810  2               CLRCHN		= $FFCC ; restore character I/O to screen/keyboard
000810  2               BASIN		= $FFCF ; get character
000810  2               BSOUT		= $FFD2 ; write character
000810  2               LOAD		= $FFD5 ; load a file into memory
000810  2               SAVE		= $FFD8 ; save a file from memory
000810  2               CLALL		= $FFE7 ; close all channels
000810  2               
000810  2               ; Commodore Peripheral Bus
000810  2               TALK		= $FFB4 ; send TALK command
000810  2               LISTEN		= $FFB1 ; send LISTEN command
000810  2               UNLSN		= $FFAE ; send UNLISTEN command
000810  2               UNTLK		= $FFAB ; send UNTALK command
000810  2               IECOUT		= $FFA8 ; send byte to serial bus
000810  2               IECIN		= $FFA5 ; read byte from serial bus
000810  2               SETTMO		= $FFA2 ; set timeout
000810  2               TKSA		= $FF96 ; send TALK secondary address
000810  2               SECOND		= $FF93 ; send LISTEN secondary address
000810  2               
000810  2               ; Memory
000810  2               MEMBOT		= $FF9C ; read/write address of start of usable RAM
000810  2               MEMTOP		= $FF99 ; read/write address of end of usable RAM
000810  2               
000810  2               ; Time
000810  2               RDTIM		= $FFDE ; read system clock
000810  2               SETTIM		= $FFDB ; write system clock
000810  2               UDTIM		= $FFEA ; advance clock
000810  2               
000810  2               ; Other:
000810  2               STOP		= $FFE1 ; test for STOP key
000810  2               GETIN		= $FFE4 ; get character from keyboard
000810  2               SCREEN		= $FFED ; get the screen resolution
000810  2               PLOT		= $FFF0 ; read/write cursor position
000810  2               IOBASE		= $FFF3 ; return start of I/O area
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Commodore 128 API
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               CLOSE_ALL		= $FF4A ; close all files on a device
000810  2               LKUPLA		= $FF8D ; search tables for given LA
000810  2               LKUPSA		= $FF8A ; search tables for given SA
000810  2               DLCHR		= $FF62 ; activate a text mode font in the video hardware [not yet implemented]
000810  2               PFKEY		= $FF65 ; program a function key [not yet implemented]
000810  2               FETCH		= $FF74 ; LDA (fetvec),Y from any bank
000810  2               STASH		= $FF77 ; STA (stavec),Y to any bank
000810  2               CMPARE		= $FF7A ; CMP (cmpvec),Y to any bank
000810  2               PRIMM		= $FF7D ; print string following the callerâ€™s code
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Commander X16 API
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               ; Clock
000810  2               clock_set_date_time		= $FF4D ; set date and time
000810  2               clock_get_date_time		= $FF50 ; get date and time
000810  2               
000810  2               ; Mouse
000810  2               mouse_config			= $FF68 ; configure mouse pointer
000810  2               mouse_get				= $FF6B ; get state of mouse
000810  2               
000810  2               ; Joystick
000810  2               joystick_scan			= $FF53 ; query joysticks
000810  2               joystick_get			= $FF56 ; get state of one joystick
000810  2               
000810  2               ; Sprites
000810  2               sprite_set_image		= $FEF0 ; set the image of a sprite
000810  2               sprite_set_position		= $FEF3 ; set the position of a sprite
000810  2               
000810  2               ; Framebuffer
000810  2               FB_init					= $FEF6 ; enable graphics mode
000810  2               FB_get_info				= $FEF9 ; get screen size and color depth
000810  2               FB_set_palette			= $FEFC ; set (parts of) the palette
000810  2               FB_cursor_position		= $FEFF ; position the direct;access cursor
000810  2               FB_cursor_next_line		= $FF02 ; move direct;access cursor to next line
000810  2               FB_get_pixel			= $FF05 ; read one pixel, update cursor
000810  2               FB_get_pixels			= $FF08 ; copy pixels into RAM, update cursor
000810  2               FB_set_pixel			= $FF0B ; set one pixel, update cursor
000810  2               FB_set_pixels			= $FF0E ; copy pixels from RAM, update cursor
000810  2               FB_set_8_pixels			= $FF11 ; set 8 pixels from bit mask (transparent), update cursor
000810  2               FB_set_8_pixels_opaque	= $FF14 ; set 8 pixels from bit mask (opaque), update cursor
000810  2               FB_fill_pixels			= $FF17 ; fill pixels with constant color, update cursor
000810  2               FB_filter_pixels		= $FF1A ; apply transform to pixels, update cursor
000810  2               FB_move_pixels			= $FF1D ; copy horizontally consecutive pixels to a different position
000810  2               
000810  2               ; Graphics
000810  2               GRAPH_init				= $FF20 ; initialize graphics
000810  2               GRAPH_clear				= $FF23 ; clear screen
000810  2               GRAPH_set_window		= $FF26 ; set clipping region
000810  2               GRAPH_set_colors		= $FF29 ; set stroke, fill and background colors
000810  2               GRAPH_draw_line			= $FF2C ; draw a line
000810  2               GRAPH_draw_rect			= $FF2F ; draw a rectangle (optionally filled)
000810  2               GRAPH_move_rect			= $FF32 ; move pixels
000810  2               GRAPH_draw_oval			= $FF35 ; draw an oval or circle
000810  2               GRAPH_draw_image		= $FF38 ; draw a rectangular image
000810  2               GRAPH_set_font			= $FF3B ; set the current font
000810  2               GRAPH_get_char_size		= $FF3E ; get size and baseline of a character
000810  2               GRAPH_put_char			= $FF41 ; print a character
000810  2               
000810  2               ; Console
000810  2               CONSOLE_init					= $FEDB ; initialize console mode
000810  2               CONSOLE_put_char				= $FEDE ; print character to console
000810  2               CONSOLE_put_image				= $FED8 ; draw image as if it was a character
000810  2               CONSOLE_get_char				= $FEE1 ; get character from console
000810  2               CONSOLE_set_paging_message		= $FED5 ; set paging message or disable paging
000810  2               
000810  2               ; Other
000810  2               memory_fill				= $FEE4 ; fill memory region with a byte value
000810  2               memory_copy				= $FEE7 ; copy memory region
000810  2               memory_crc				= $FEEA ; calculate CRC16 of memory region
000810  2               memory_decompress		= $FEED ; decompress LZSA2 block
000810  2               entropy_get				= $FECF ; Get 24 random bits
000810  2               monitor					= $FF44 ; enter machine language monitor
000810  2               restore_basic			= $FF47 ; enter BASIC
000810  2               screen_set_mode			= $FF5F ; set screen mode
000810  2               screen_set_charset		= $FF62 ; activate 8x8 text mode charset
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; VRAM Addresses
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               VRAM_composer		= $F0000
000810  2               VRAM_hscale			= VRAM_composer+1
000810  2               VRAM_vscale			= VRAM_composer+2
000810  2               VRAM_palette		= $F1000
000810  2               VRAM_layer0			= $F2000
000810  2               VRAM_layer1			= $F3000
000810  2               VRAM_sprreg			= $F4000
000810  2               VRAM_sprattr		= $F5000
000810  2               VRAM_audio			= $F6000
000810  2               VRAM_spi			= $F7000
000810  2               VRAM_uart			= $F8000
000810  2               
000810  2               VROM_petscii				= $1F000
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; IRQs
000810  2               ; ------------------------------------------------------------
000810  2               
000810  2               IRQVec		= $0314
000810  2               BRKVec		= $0316
000810  2               NMIVec		= $0318
000810  2               
000810  2               
000810  2               ; ------------------------------------------------------------
000810  2               ; Virtual registers
000810  2               ; ------------------------------------------------------------
000810  2               r0			= $02
000810  2               r0L			= $02
000810  2               r0H			= $03
000810  2               r1			= $04
000810  2               r1L			= $04
000810  2               r1H			= $05
000810  2               r2			= $06
000810  2               r2L			= $06
000810  2               r2H			= $07
000810  2               r3			= $08
000810  2               r3L			= $08
000810  2               r3H			= $09
000810  2               r4			= $0a
000810  2               r4L			= $0a
000810  2               r4H			= $0b
000810  2               r5			= $0c
000810  2               r5L			= $0c
000810  2               r5H			= $0d
000810  2               r6			= $0e
000810  2               r6L			= $0e
000810  2               r6H			= $0f
000810  2               r7			= $10
000810  2               r7L			= $10
000810  2               r7H			= $11
000810  2               r8			= $12
000810  2               r8L			= $12
000810  2               r8H			= $13
000810  2               r9			= $14
000810  2               r9L			= $14
000810  2               r9H			= $15
000810  2               r10			= $16
000810  2               r10L		= $16
000810  2               r10H		= $17
000810  2               r11			= $18
000810  2               r11L		= $18
000810  2               r11H		= $19
000810  2               r12			= $1a
000810  2               r12L		= $1a
000810  2               r12H		= $1b
000810  2               r13			= $1c
000810  2               r13L		= $1c
000810  2               r13H		= $1d
000810  2               r14			= $1e
000810  2               r14L		= $1e
000810  2               r14H		= $1f
000810  2               r15			= $20
000810  2               r15L		= $20
000810  2               r15H		= $21
000810  2               
000810  2               
000810  2               .endif
000810  2               
000810  1               .include "vera.inc"
000810  2               ; License: Public Domain
000810  2               .ifndef VERA_INC
000810  2               VERA_INC = 1
000810  2               
000810  2               verareg =$9f20
000810  2               
000810  2               veralo  		= verareg+$0
000810  2               veramid 		= verareg+$1
000810  2               verahi  		= verareg+$2
000810  2               veradat 		= verareg+$3
000810  2               veradat2		= verareg+$4
000810  2               veractl 		= verareg+$5
000810  2               veraien 		= verareg+$6
000810  2               veraisr 		= verareg+$7
000810  2               verairqlo 		= verareg+$8
000810  2               
000810  2               ; DCSEl = 0
000810  2               veradcvideo		= verareg+$9
000810  2               
000810  2               VERA_VGA		= %00000001
000810  2               VERA_LAYER0		= %00010000
000810  2               VERA_LAYER1		= %00100000
000810  2               VERA_SPRITE		= %01000000
000810  2               
000810  2               veradchscale	= verareg+$a
000810  2               veradcvscale	= verareg+$b
000810  2               veradcborder	= verareg+$c
000810  2               
000810  2               ; DCSEl = 1
000810  2               veradchstart	= verareg+$9
000810  2               veradchstop		= verareg+$a
000810  2               veradcvstart	= verareg+$b
000810  2               veradcvstop		= verareg+$c
000810  2               
000810  2               ; L0
000810  2               veral0config	= verareg+$d
000810  2               veral0mapbase	= verareg+$e
000810  2               veral0tilebase	= verareg+$f
000810  2               VERA_L0_hscrolllo	= verareg+$10
000810  2               VERA_L0_hscrollhi	= verareg+$11
000810  2               veral0vscrolllo	= verareg+$12
000810  2               veral0vscrollhi	= verareg+$13
000810  2               
000810  2               ; L1
000810  2               veral1config	= verareg+$14
000810  2               veral1mapbase	= verareg+$15
000810  2               veral1tilebase	= verareg+$16
000810  2               VERA_L1_hscrolllo	= verareg+$17
000810  2               VERA_L1_hscrollhi	= verareg+$18
000810  2               VERA_L1_vscrolllo	= verareg+$19
000810  2               VERA_L1_vscrollhi	= verareg+$1a
000810  2               
000810  2               VERA_CONFIG_CLEAR_TILES=%00001111
000810  2               VERA_CONFIG_32x32 = 	%00000000
000810  2               VERA_CONFIG_32x64 = 	%00010000
000810  2               VERA_CONFIG_32x128 = 	%00100000
000810  2               VERA_CONFIG_32x256 = 	%00110000
000810  2               VERA_CONFIG_64x32 = 	%01000000
000810  2               VERA_CONFIG_128x32 = 	%10000000
000810  2               VERA_CONFIG_256x32 = 	%11000000
000810  2               VERA_CONFIG_64x64 = 	%01010000
000810  2               VERA_CONFIG_64x128 = 	%01100000
000810  2               VERA_CONFIG_64x256 = 	%01110000
000810  2               VERA_CONFIG_128x64 = 	%10010000
000810  2               VERA_CONFIG_128x128 = 	%10100000
000810  2               VERA_CONFIG_128x256 = 	%10110000
000810  2               VERA_CONFIG_256x64 = 	%11010000
000810  2               VERA_CONFIG_256x128 = 	%11100000
000810  2               VERA_CONFIG_256x256 = 	%11110000
000810  2               
000810  2               VERA_CONFIG_CLEAR_DEPTH=%00001111
000810  2               VERA_CONFIG_1BPP	=	%00000000
000810  2               VERA_CONFIG_2BPP	=	%00000001
000810  2               VERA_CONFIG_4BPP	=	%00000010
000810  2               VERA_CONFIG_8BPP	=	%00000011
000810  2               
000810  2               VERA_CLEAR_TILE_SIZE= %11111100
000810  2               VERA_TILE_8x8 		= %00000000
000810  2               VERA_TILE_8x16 		= %00000010
000810  2               VERA_TILE_16x8 		= %00000001
000810  2               VERA_TILE_16x16 	= %00000011
000810  2               
000810  2               VERA_TILEBASE_CLEAR_ADR = %00000011
000810  2               
000810  2               ; audio
000810  2               veraaudioctl	= verareg+$1b
000810  2               veraaudiorate	= verareg+$1c
000810  2               veraaudiodata	= verareg+$1d
000810  2               veraspidata		= verareg+$1e
000810  2               veraspictl		= verareg+$1f
000810  2               
000810  2               vram_sprd  = $1fc00
000810  2               
000810  2               AUTO_INC_0 		= $000000
000810  2               AUTO_INC_1 		= $100000
000810  2               AUTO_INC_2 		= $200000
000810  2               AUTO_INC_4 		= $300000
000810  2               AUTO_INC_8 		= $400000
000810  2               AUTO_INC_16		= $500000
000810  2               AUTO_INC_32		= $600000
000810  2               AUTO_INC_64		= $700000
000810  2               AUTO_INC_128	= $800000
000810  2               AUTO_INC_256	= $900000
000810  2               AUTO_INC_512	= $A00000
000810  2               AUTO_INC_40		= $B00000
000810  2               AUTO_INC_80		= $C00000
000810  2               AUTO_INC_160	= $C00000
000810  2               AUTO_INC_320	= $E00000
000810  2               AUTO_INC_640	= $F00000
000810  2               
000810  2               SPRITE_SIZE_8	= $0
000810  2               SPRITE_SIZE_16	= $1
000810  2               SPRITE_SIZE_32	= $2
000810  2               SPRITE_SIZE_64	= $3
000810  2               
000810  2               SPRITE_ZDEPTH_DISABLED = %00000000
000810  2               SPRITE_ZDEPTH_BGto0 = %00000100
000810  2               SPRITE_ZDEPTH_0to1 = %00001000
000810  2               SPRITE_ZDEPTH_TOP = %00001100
000810  2               
000810  2               SPRITE_FLIP_CLEAR = %11111100
000810  2               SPRITE_FLIP_NONE = %00000000
000810  2               SPRITE_FLIP_H = %00000001
000810  2               SPRITE_FLIP_V = %00000010
000810  2               
000810  2               veral0mode = %00010000
000810  2               VERA_VSYNC_BIT         = $01
000810  2               VERA_LINE_BIT        = $04
000810  2               VERA_SPRCOL_BIT        = $04
000810  2               
000810  2               .macro vset addr
000810  2               	lda #0
000810  2               	sta veractl
000810  2               	lda #<(addr >> 16) | $10
000810  2               	sta verahi
000810  2               	lda #<(addr >> 8)
000810  2               	sta veramid
000810  2               	lda #<(addr)
000810  2               	sta veralo
000810  2               .endmacro
000810  2               
000810  2               .macro vset2 addr
000810  2               	lda #1
000810  2               	sta veractl
000810  2               	lda #<(addr >> 16) | $10
000810  2               	sta verahi
000810  2               	lda #<(addr >> 8)
000810  2               	sta veramid
000810  2               	lda #<(addr)
000810  2               	sta veralo
000810  2               .endmacro
000810  2               
000810  2               .macro vstore addr
000810  2               	pha
000810  2               	vset addr
000810  2               	pla
000810  2               	sta veradat
000810  2               .endmacro
000810  2               
000810  2               .macro vstore2 addr
000810  2               	pha
000810  2               	vset addr
000810  2               	pla
000810  2               	sta veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro vload addr
000810  2               	vset addr
000810  2               	lda veradat
000810  2               .endmacro
000810  2               
000810  2               .macro vload2 addr
000810  2               	vset addr
000810  2               	lda veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro sprset offset
000810  2               	lda #<(vram_sprd >> 16) | $10
000810  2               	sta verahi
000810  2               	txa
000810  2               	lsr
000810  2               	lsr
000810  2               	lsr
000810  2               	lsr
000810  2               	lsr
000810  2               	clc
000810  2               	adc #<((vram_sprd + offset) >> 8)
000810  2               	sta veramid
000810  2               	txa
000810  2               	asl
000810  2               	asl
000810  2               	asl
000810  2               	clc
000810  2               	adc #<(vram_sprd + offset)
000810  2               	sta veralo
000810  2               .endmacro
000810  2               
000810  2               .macro sprload offset
000810  2               	sprset offset
000810  2               	lda veradat
000810  2               .endmacro
000810  2               
000810  2               .macro sprload2 offset
000810  2               	sprset offset
000810  2               	lda veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro sprstore offset
000810  2               	pha
000810  2               	sprset offset
000810  2               	pla
000810  2               	sta veradat
000810  2               .endmacro
000810  2               
000810  2               .macro sprstore2 offset
000810  2               	pha
000810  2               	sprset offset
000810  2               	pla
000810  2               	sta veradat2
000810  2               .endmacro
000810  2               
000810  2               .macro video_init
000810  2               	lda #0
000810  2               	sta veractl ; set ADDR1 active
000810  2               	sta veramid
000810  2               	lda #$1F    ; $F0000 increment 1
000810  2               	sta verahi
000810  2               	lda #$00
000810  2               	sta veralo
000810  2               	lda #1
000810  2               	sta veradat ; VGA output
000810  2               .endmacro
000810  2               
000810  2               .endif
000810  2               
000810  1               
000810  1               ; VRAM Addresses
000810  1               VRAM_layer0_map   = $00000
000810  1               VRAM_layer1_map   = $00800
000810  1               VRAM_tiles        = $01000
000810  1               
000810  1               HIMEM = $a000
000810  1               
000810  1               SCREEN_WIDTH = 320
000810  1               SCREEN_HEIGHT = 240
000810  1               LEVEL_TILES_WIDTH = 32
000810  1               LEVEL_WIDTH = LEVEL_TILES_WIDTH*16
000810  1               LEVEL_HEIGHT = 32*16
000810  1               
000810  1               .enum
000810  1               	TILE_NO_COLLISION
000810  1               	TILE_SOLID_GROUND
000810  1               	TILE_SOLD_SLOP_LEFT
000810  1               	TILE_SOLD_SLOP_RIGHT
000810  1               	TILE_SOLID_LADER
000810  1               	TILE_LEDGE
000810  1               .endenum
000810  1               
000810  1               .macro SET_DEBUG
000810  1               	inc trigger_debug
000810  1               .endmacro
000810  1               
000810  1               .macro CHECK_DEBUG
000810  1               	pha
000810  1               	lda trigger_debug
000810  1               	beq @no_debug
000810  1               	dec trigger_debug
000810  1               	stp
000810  1               @no_debug:
000810  1               	pla
000810  1               .endmacro
000810  1               
000810  1               ;---------------------------------
000810  1               ; joystick management
000810  1               ;---------------------------------
000810  1               
000810  1               JOY_RIGHT 	= %00000001
000810  1               JOY_LEFT 	= %00000010
000810  1               JOY_DOWN 	= %00000100
000810  1               JOY_UP 		= %00001000
000810  1               JOY_START	= %00010000
000810  1               JOY_SEL		= %00100000
000810  1               JOY_Y		= %01000000
000810  1               JOY_B		= %10000000
000810  1               
000810  1               .macro VCOPY from, to, blocks
000810  1               	LOAD_r0 from
000810  1               	LOAD_r1 (to & $00ffff)
000810  1               	ldy #(to >> 16)
000810  1               	ldx #(blocks)
000810  1               	jsr Vera::vcopy
000810  1               .endmacro
000810  1               
000810  1               ;-----------------------------------------------------------------------------
000810  1               ;/////////////////////////////////////////////////////////////////////////////
000810  1               ; START Vera code
000810  1               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000810  1               ;-----------------------------------------------------------------------------
000810  1               
000810  1  00 00        current_load: .word 0		; end of the last memory load
000812  1               
000812  1               .macro LOAD_FILE filename, length, ram
000812  1               	lda #1
000812  1               	ldx #8
000812  1               	ldy #0
000812  1               	jsr SETLFS
000812  1               	lda #length
000812  1               	ldx #<filename
000812  1               	ldy #>filename
000812  1               	jsr SETNAM
000812  1               	lda #0
000812  1               	ldx #<ram
000812  1               	ldy #>ram
000812  1               	jsr LOAD
000812  1               	stx current_load
000812  1               	sty current_load + 1
000812  1               .endmacro
000812  1               
000812  1               .macro LOAD_FILE_NEXT filename, length
000812  1               	lda #1
000812  1               	ldx #8
000812  1               	ldy #0
000812  1               	jsr SETLFS
000812  1               	lda #length
000812  1               	ldx #<filename
000812  1               	ldy #>filename
000812  1               	jsr SETNAM
000812  1               	lda #0
000812  1               	ldx current_load
000812  1               	ldy current_load + 1
000812  1               	jsr LOAD
000812  1               	stx current_load
000812  1               	sty current_load + 1
000812  1               .endmacro
000812  1               
000812  1               .scope Vera
000812  1               
000812  1  00 00        vram_load: .word 0		; end of the last memory load
000814  1               
000814  1               .macro VLOAD_FILE filename, length, vram
000814  1               	lda #1
000814  1               	ldx #8
000814  1               	ldy #0
000814  1               	jsr SETLFS
000814  1               	lda #length
000814  1               	ldx #<filename
000814  1               	ldy #>filename
000814  1               	jsr SETNAM
000814  1               	lda #(^vram + 2)
000814  1               	ldx #<vram
000814  1               	ldy #>vram
000814  1               	jsr LOAD
000814  1               	stx Vera::vram_load
000814  1               	sty Vera::vram_load + 1
000814  1               .endmacro
000814  1               
000814  1               .macro VLOAD_FILE_NEXT filename, length
000814  1               	lda #1
000814  1               	ldx #8
000814  1               	ldy #0
000814  1               	jsr SETLFS
000814  1               	lda #length
000814  1               	ldx #<filename
000814  1               	ldy #>filename
000814  1               	jsr SETNAM
000814  1               	lda #(^Vera::vram_load + 2)
000814  1               	ldx Vera::vram_load
000814  1               	ldy Vera::vram_load + 1
000814  1               	jsr LOAD
000814  1               	stx Vera::vram_load
000814  1               	sty Vera::vram_load + 1
000814  1               .endmacro
000814  1               
000814  1               ;
000814  1               ; copy from rom to vram
000814  1               ;	r0 : from
000814  1               ;	r1 : to (first 16 bites)
000814  1               ;   	y : vera bank (0, 1)
000814  1               ;	X: blocks
000814  1               ;
000814  1               vcopy:
000814  1  A9 00        	lda #0
000816  1  8D 25 9F     	sta veractl
000819  1  98           	tya
00081A  1  09 10        	ora #$10
00081C  1  8D 22 9F     	sta verahi
00081F  1  A5 05        	lda r1H
000821  1  8D 21 9F     	sta veramid
000824  1  A5 04        	lda r1L
000826  1  8D 20 9F     	sta veralo
000829  1               
000829  1               @loop:
000829  1  A0 00            ldy #0
00082B  1               @loop1tile:
00082B  1  B1 02        	lda (r0),y                         	; read from tiles data
00082D  1  8D 23 9F         sta veradat                      	; Write to VRAM with +1 Autoincrement
000830  1  C8               iny
000831  1  D0 F8            bne @loop1tile
000833  1               
000833  1  E6 03        	inc r0H
000835  1  CA           	dex
000836  1  D0 F1        	bne @loop
000838  1  60           	rts
000839  1               .endscope
000839  1               
000839  1               
000839  1               .include "sprites.asm"
000839  2               ;-----------------------------------------------------------------------------
000839  2               ;/////////////////////////////////////////////////////////////////////////////
000839  2               ; START Sprite code
000839  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000839  2               ;-----------------------------------------------------------------------------
000839  2               
000839  2               .struct VSPRITE
000839  2               	address125 .byte
000839  2               	mode_xxx_address1613 .byte
000839  2               	x70 .byte
000839  2               	x98 .byte
000839  2               	y70 .byte
000839  2               	y98 .byte
000839  2               	collision_zdepth_vflip_hflip .byte
000839  2               	height_width_offset .byte
000839  2               .endstruct
000839  2               
000839  2               .scope Sprite
000839  2               
000839  2               ;-----------------------------------------
000839  2               ; sprites components collections
000839  2               MAX_SPRITES = 32
000839  2               
000839  2  xx xx xx xx  sprites_xL: .res MAX_SPRITES
00083D  2  xx xx xx xx  
000841  2  xx xx xx xx  
000859  2  xx xx xx xx  sprites_xH: .res MAX_SPRITES
00085D  2  xx xx xx xx  
000861  2  xx xx xx xx  
000879  2  xx xx xx xx  sprites_yL: .res MAX_SPRITES
00087D  2  xx xx xx xx  
000881  2  xx xx xx xx  
000899  2  xx xx xx xx  sprites_yH: .res MAX_SPRITES
00089D  2  xx xx xx xx  
0008A1  2  xx xx xx xx  
0008B9  2  xx xx xx xx  sprites_x1L: .res MAX_SPRITES
0008BD  2  xx xx xx xx  
0008C1  2  xx xx xx xx  
0008D9  2  xx xx xx xx  sprites_x1H: .res MAX_SPRITES
0008DD  2  xx xx xx xx  
0008E1  2  xx xx xx xx  
0008F9  2  xx xx xx xx  sprites_y1L: .res MAX_SPRITES
0008FD  2  xx xx xx xx  
000901  2  xx xx xx xx  
000919  2  xx xx xx xx  sprites_y1H: .res MAX_SPRITES
00091D  2  xx xx xx xx  
000921  2  xx xx xx xx  
000939  2  xx xx xx xx  sprites_aabb_x: .res MAX_SPRITES	; collision box INSIDE the sprite top-left corner
00093D  2  xx xx xx xx  
000941  2  xx xx xx xx  
000959  2  xx xx xx xx  sprites_aabb_y: .res MAX_SPRITES
00095D  2  xx xx xx xx  
000961  2  xx xx xx xx  
000979  2  xx xx xx xx  sprites_aabb_w: .res MAX_SPRITES	; collision box INSIDE the sprite height/width
00097D  2  xx xx xx xx  
000981  2  xx xx xx xx  
000999  2  xx xx xx xx  sprites_aabb_h: .res MAX_SPRITES
00099D  2  xx xx xx xx  
0009A1  2  xx xx xx xx  
0009B9  2               
0009B9  2  xx xx xx xx  sprites: .res 256		; store VRAM 12:5 address of each of the 128 sprites
0009BD  2  xx xx xx xx  
0009C1  2  xx xx xx xx  
000AB9  2  01           nb_sprites: .byte 1		; 1 reserved for the player
000ABA  2  00 00        collisions: .word 0		; L = collision happened, H = collision mask
000ABC  2               
000ABC  2               ;************************************************
000ABC  2               ;  init sprites manager
000ABC  2               ; create a table with the VERA @addr for each sprite
000ABC  2               ;
000ABC  2               init_addr_table:
000ABC  2               	; clear the sprites components
000ABC  2  A6 20        	ldx MAX_SPRITES
000ABE  2  CA           	dex
000ABF  2               :
000ABF  2  9E 39 08     	stz sprites_xL,x
000AC2  2  9E 59 08     	stz sprites_xH,x
000AC5  2  9E 79 08     	stz sprites_yL,x
000AC8  2  9E 99 08     	stz sprites_yH,x
000ACB  2  9E 79 09     	stz sprites_aabb_w,x
000ACE  2  9E 99 09     	stz sprites_aabb_h,x
000AD1  2  9E 39 09     	stz sprites_aabb_x,x
000AD4  2  9E 59 09     	stz sprites_aabb_y,x
000AD7  2  CA           	dex
000AD8  2  10 E5        	bpl :-
000ADA  2               
000ADA  2               	; activate sprite colisions
000ADA  2  AD 26 9F     	lda veraien
000ADD  2  09 04        	ora #VERA_SPRCOL_BIT
000ADF  2  8D 26 9F     	sta veraien
000AE2  2               
000AE2  2               	; all sprites are availble but ZERO (reserved player)
000AE2  2  A2 FF        	ldx #$ff
000AE4  2               :
000AE4  2  9E B9 09     	stz sprites,X
000AE7  2  CA           	dex
000AE8  2  D0 FA        	bne :-
000AEA  2  A9 01        	lda #01
000AEC  2  8D B9 09     	sta sprites
000AEF  2               
000AEF  2               	; start of the sprites in VERA memory
000AEF  2  A9 00        	lda #<vram_sprd
000AF1  2  85 02        	sta r0L
000AF3  2  A9 FC        	lda #>vram_sprd
000AF5  2  85 03        	sta r0H
000AF7  2               
000AF7  2  A2 80        	ldx #128
000AF9  2  A0 00        	ldy #0
000AFB  2                @loop:
000AFB  2  A5 03        	lda r0H
000AFD  2  99 4F 1A     	sta sprites_table,y
000B00  2  C8           	iny
000B01  2  A5 02        	lda r0L
000B03  2  99 4F 1A     	sta sprites_table,y
000B06  2  C8           	iny
000B07  2               
000B07  2  18           	clc
000B08  2  A5 02        	lda r0L
000B0A  2  69 08        	adc #8
000B0C  2  85 02        	sta r0L
000B0E  2  A5 03        	lda r0H
000B10  2  69 00        	adc #0
000B12  2  85 03        	sta r0H	; move to next sprite
000B14  2               
000B14  2  CA           	dex
000B15  2  D0 E4        	bne @loop
000B17  2               
000B17  2  60           	rts
000B18  2               
000B18  2               ;************************************************
000B18  2               ; get a new available vera sprite
000B18  2               ;	output: X = index of the vera sprite
000B18  2               ;			0 = no sprite available
000B18  2               ;
000B18  2               new:
000B18  2  A2 01        	ldx #$01
000B1A  2               :
000B1A  2  BD B9 09     	lda sprites,x
000B1D  2  F0 03        	beq @return
000B1F  2  E8           	inx
000B20  2  D0 F8        	bne :-
000B22  2               @return:
000B22  2  A9 01        	lda #01
000B24  2  9D B9 09     	sta sprites,x
000B27  2               
000B27  2               	; count activated sprites
000B27  2  EC B9 0A     	cpx nb_sprites
000B2A  2  90 03        	bcc :+
000B2C  2               
000B2C  2  EE B9 0A     	inc nb_sprites
000B2F  2               :
000B2F  2  60           	rts
000B30  2               
000B30  2               ;
000B30  2               ; the the VERA memory pointer to sprite Y + attribute X
000B30  2               ;	Y = sprite index
000B30  2               ;	X = attribute offset
000B30  2               ;
000B30  2               vram:
000B30  2  DA           	phx			; save X on the stack
000B31  2               
000B31  2  98           	tya			; index of the sprite
000B32  2  0A           	asl
000B33  2  A8           	tay			; index of the address of the sprite (y*2)
000B34  2               
000B34  2  A9 00        	lda #0
000B36  2  8D 25 9F     	sta veractl
000B39  2  A9 11        	lda #<(vram_sprd >> 16) | $10
000B3B  2  8D 22 9F     	sta verahi
000B3E  2  B9 4F 1A     	lda sprites_table, y
000B41  2  8D 21 9F     	sta veramid
000B44  2  C8           	iny
000B45  2  BA           	tsx
000B46  2  BD 01 01     	lda $0101,x	; reload X from the stack
000B49  2  79 4F 1A     	adc sprites_table, y
000B4C  2  8D 20 9F     	sta veralo	; vera = $1fc00 + sprite index (X) * 8
000B4F  2  FA           	plx
000B50  2  60           	rts
000B51  2               
000B51  2               ;************************************************
000B51  2               ; configure the sprite
000B51  2               ;	input: 	A = sprite collision mask
000B51  2               ;			Y = sprite index
000B51  2               ;		   	X = sprite size :
000B51  2               ;		   	r0 = vram @ of the sprite data
000B51  2               ;
000B51  2  08 10 20 40  sprites_size: .byte 8, 16, 32, 64
000B55  2               
000B55  2               load:
000B55  2  85 32        	sta $32
000B57  2  86 30        	stx $30
000B59  2  84 33        	sty $33
000B5B  2  20 CE 0B     	jsr set_bitmap
000B5E  2               
000B5E  2  9C 23 9F     	stz veradat					; x = 0
000B61  2  9C 23 9F     	stz veradat
000B64  2  9C 23 9F     	stz veradat					; y = 0
000B67  2  9C 23 9F     	stz veradat
000B6A  2  A5 32        	lda $32						; load collision mask
000B6C  2  09 00        	ora #%00000000				; collision mask + sprite = disabled + vflip=none + hflip=none
000B6E  2  8D 23 9F     	sta veradat
000B71  2  A5 30        	lda $30						; 32x32 sprite
000B73  2  8D 23 9F     	sta veradat
000B76  2               
000B76  2  4A           	lsr
000B77  2  4A           	lsr
000B78  2  4A           	lsr
000B79  2  4A           	lsr
000B7A  2  85 30        	sta $30						; focus on sprite_height, sprite_width
000B7C  2               
000B7C  2  A4 33        	ldy $33						; sprite index
000B7E  2               
000B7E  2  29 03        	and #%00000011				; sprite_width
000B80  2  AA           	tax
000B81  2  BD 51 0B     	lda sprites_size,x
000B84  2  99 79 09     	sta sprites_aabb_w, y		; store width in pixels in the sprite attribute
000B87  2  A9 00        	lda #00
000B89  2  99 39 09     	sta sprites_aabb_x, y		; default collision box starts (0,0)
000B8C  2               
000B8C  2  A5 30        	lda $30
000B8E  2  4A           	lsr
000B8F  2  4A           	lsr							; sprite_height
000B90  2  AA           	tax
000B91  2  BD 51 0B     	lda sprites_size,x
000B94  2  99 99 09     	sta sprites_aabb_h, y		; store height in pixels in the sprite attribute
000B97  2  A9 00        	lda #00
000B99  2  99 59 09     	sta sprites_aabb_y, y		; default collision box starts (0,0)
000B9C  2               
000B9C  2  60           	rts
000B9D  2               
000B9D  2               ;************************************************
000B9D  2               ; set the collision box of the sprite
000B9D  2               ;	input y = sprite index
000B9D  2               ;		r0L = top-left corner X
000B9D  2               ;		r0H = top-left corner Y
000B9D  2               ;		r1L = width
000B9D  2               ;		r1H = height
000B9D  2               ;
000B9D  2               set_aabb:
000B9D  2  A5 02        	lda r0L
000B9F  2  99 39 09     	sta sprites_aabb_x,y
000BA2  2  A5 03        	lda r0H
000BA4  2  99 59 09     	sta sprites_aabb_y,y
000BA7  2  A5 04        	lda r1L
000BA9  2  99 79 09     	sta sprites_aabb_w,y
000BAC  2  A5 05        	lda r1H
000BAE  2  99 99 09     	sta sprites_aabb_h,y
000BB1  2  60           	rts
000BB2  2               
000BB2  2               ;************************************************
000BB2  2               ; configure full veram memory (16:0) into optimized one (12:5)
000BB2  2               ;	input: r0 = vram @ of the sprite data
000BB2  2               ;	output: r1
000BB2  2               ;
000BB2  2               vram_to_16_5:
000BB2  2               	; load full VERA memory (12:0) into R0
000BB2  2  A5 02        	lda r0L
000BB4  2  85 04        	sta r1L
000BB6  2  A5 03        	lda r0H
000BB8  2  85 05        	sta r1H
000BBA  2               
000BBA  2               	; convert full addr to vera mode (bit shiting >> 5)
000BBA  2  A5 05        	lda r1H
000BBC  2  4A           	lsr
000BBD  2  66 04        	ror r1L
000BBF  2  4A           	lsr
000BC0  2  66 04        	ror r1L
000BC2  2  4A           	lsr
000BC3  2  66 04        	ror r1L
000BC5  2  4A           	lsr
000BC6  2  66 04        	ror r1L						; bit shift 4x 16 bits vera memory
000BC8  2  4A           	lsr
000BC9  2  66 04        	ror r1L						; bit shift 4x 16 bits vera memory
000BCB  2  85 05        	sta r1H
000BCD  2  60           	rts
000BCE  2               
000BCE  2               ;************************************************
000BCE  2               ; change the address of the bitmap for the sprite
000BCE  2               ;	Y = sprite index
000BCE  2               ;	r0 = vera memory (12:5)
000BCE  2               ;
000BCE  2               set_bitmap:
000BCE  2  A2 00        	ldx #VSPRITE::address125
000BD0  2  20 30 0B     	jsr vram			; set very pointer to the address of the bitmap
000BD3  2               
000BD3  2  A5 02        	lda r0L
000BD5  2  8D 23 9F     	sta veradat
000BD8  2  A5 03        	lda r0H
000BDA  2  09 80        	ora #$80						; M = 8 bits
000BDC  2  8D 23 9F     	sta veradat
000BDF  2               
000BDF  2  60           	rts
000BE0  2               
000BE0  2               ;************************************************
000BE0  2               ; change the display byte for a sprite
000BE0  2               ;	Y = sprite index
000BE0  2               ;	X = display value to set
000BE0  2               ;
000BE0  2               display:
000BE0  2  86 02        	stx r0L		; save X for later
000BE2  2  84 03        	sty r0H
000BE4  2               
000BE4  2               	; set vram memory on the X sprite
000BE4  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000BE6  2  20 30 0B     	jsr vram
000BE9  2  AD 23 9F     	lda veradat
000BEC  2  29 F3        	and #(<~SPRITE_ZDEPTH_TOP)
000BEE  2  05 02        	ora r0L
000BF0  2  85 02        	sta r0L
000BF2  2               
000BF2  2  A4 03        	ldy r0H
000BF4  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000BF6  2  20 30 0B     	jsr vram
000BF9  2               
000BF9  2  A5 02        	lda r0L
000BFB  2  8D 23 9F     	sta veradat
000BFE  2  60           	rts
000BFF  2               
000BFF  2               ;************************************************
000BFF  2               ; define position of sprite
000BFF  2               ;	Y = sprite index
000BFF  2               ;	r0 = addr of word X & word Y
000BFF  2               ;
000BFF  2               position:
000BFF  2               	; set vram memory on the X sprite
000BFF  2  5A           	phy
000C00  2  A2 02        	ldx #VSPRITE::x70
000C02  2  20 30 0B     	jsr vram
000C05  2  FA           	plx
000C06  2               
000C06  2  A0 01        	ldy #1
000C08  2  18           	clc
000C09  2  B2 02        	lda (r0L)				; X low => vera X
000C0B  2  8D 23 9F     	sta veradat
000C0E  2  7D 39 09     	adc sprites_aabb_x, x	; X + aabb.x => collision box.x
000C11  2  9D 39 08     	sta sprites_xL, x
000C14  2  B1 02        	lda (r0L),y				; X high => vera X hight
000C16  2  8D 23 9F     	sta veradat
000C19  2  69 00        	adc #00
000C1B  2  9D 59 08     	sta sprites_xH, x		; X + aabbx.x => collision box.x
000C1E  2               
000C1E  2  18           	clc
000C1F  2  BD 39 08     	lda sprites_xL, x
000C22  2  7D 79 09     	adc sprites_aabb_w, x
000C25  2  9D B9 08     	sta sprites_x1L, x
000C28  2  BD 59 08     	lda sprites_xH, x
000C2B  2  69 00        	adc #0
000C2D  2  9D D9 08     	sta sprites_x1H, x		;X1 = x + aabb.x + aabb.w
000C30  2               
000C30  2  18           	clc
000C31  2  C8           	iny
000C32  2  B1 02        	lda (r0L),y
000C34  2  8D 23 9F     	sta veradat				; Y low => vera
000C37  2  7D 59 09     	adc sprites_aabb_y, x
000C3A  2  9D 79 08     	sta sprites_yL, x		; Y + aabb.y => collision box.y
000C3D  2  C8           	iny
000C3E  2  B1 02        	lda (r0L),y
000C40  2  8D 23 9F     	sta veradat				; Y heigh  => vera Y high
000C43  2  69 00        	adc #0
000C45  2  9D 99 08     	sta sprites_yH, x		; Y + aabb.y => collision box.y
000C48  2               
000C48  2  18           	clc
000C49  2  BD 79 08     	lda sprites_yL, x
000C4C  2  7D 99 09     	adc sprites_aabb_h, x
000C4F  2  9D F9 08     	sta sprites_y1L, x
000C52  2  BD 99 08     	lda sprites_yH, x
000C55  2  69 00        	adc #00
000C57  2  9D 19 09     	sta sprites_y1H, x		; Y1 = y + aabb.y + aabb.h
000C5A  2               
000C5A  2  60           	rts
000C5B  2               
000C5B  2               ;************************************************
000C5B  2               ; Change the flipping of a sprite
000C5B  2               ;	Y = sprite index
000C5B  2               ;	A = value to set
000C5B  2               ;
000C5B  2               set_flip:
000C5B  2  85 30        	sta $30
000C5D  2  84 31        	sty $31
000C5F  2               
000C5F  2               	; set vram memory on the X sprite
000C5F  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000C61  2  20 30 0B     	jsr vram
000C64  2               
000C64  2  AD 23 9F     	lda veradat				;get current value
000C67  2  29 FC        	and #SPRITE_FLIP_CLEAR
000C69  2  05 30        	ora $30					; change only the flip value
000C6B  2  85 30        	sta $30
000C6D  2               
000C6D  2  A4 31        	ldy $31
000C6F  2  A2 06        	ldx #VSPRITE::collision_zdepth_vflip_hflip
000C71  2  20 30 0B     	jsr vram
000C74  2  A5 30        	lda $30
000C76  2  8D 23 9F     	sta veradat
000C79  2  60           	rts
000C7A  2               
000C7A  2               ;************************************************
000C7A  2               ; register sprites collision
000C7A  2               ; input: A = collision mask
000C7A  2               ;
000C7A  2               register_collision:
000C7A  2  EE BA 0A     	inc collisions
000C7D  2  8D BB 0A     	sta collisions + 1
000C80  2  60           	rts
000C81  2               
000C81  2               ;************************************************
000C81  2               ; Axis Aligned Bounding Box collision between 2 sprites
000C81  2               ; input: X = index of sprite 1
000C81  2               ;		 Y = index of sprite 2
000C81  2               ; return: Z = no collision
000C81  2               ;
000C81  2               aabb_collision:
000C81  2  BD 59 08     	lda sprites_xH, x
000C84  2  D9 D9 08     	cmp sprites_x1H, y
000C87  2  90 02        	bcc :+
000C89  2  D0 49        	bne @false
000C8B  2               :
000C8B  2  BD 39 08     	lda sprites_xL, x
000C8E  2  D9 B9 08     	cmp sprites_x1L, y
000C91  2  90 02        	bcc :+
000C93  2  D0 3F        	bne @false
000C95  2               :						; s(x).left_x <= s(y).right_x
000C95  2               
000C95  2  B9 59 08     	lda sprites_xH, y
000C98  2  DD D9 08     	cmp sprites_x1H, x
000C9B  2  90 02        	bcc :+
000C9D  2  D0 35        	bne @false
000C9F  2               :
000C9F  2  B9 59 08     	lda sprites_xH, y
000CA2  2  DD D9 08     	cmp sprites_x1H, x
000CA5  2  90 02        	bcc :+
000CA7  2  D0 2B        	bne @false
000CA9  2               :						; AND s(y).left_x <= s(x).right_x
000CA9  2               
000CA9  2  BD 99 08     	lda sprites_yH, x
000CAC  2  D9 19 09     	cmp sprites_y1H, y
000CAF  2  90 02        	bcc :+
000CB1  2  D0 21        	bne @false
000CB3  2               :
000CB3  2  BD 99 08     	lda sprites_yH, x
000CB6  2  D9 19 09     	cmp sprites_y1H, y
000CB9  2  90 02        	bcc :+
000CBB  2  D0 17        	bne @false
000CBD  2               :						; AND s(x).bottom_y <= s(y).top_y
000CBD  2               
000CBD  2  B9 99 08     	lda sprites_yH, y
000CC0  2  DD 19 09     	cmp sprites_y1H, x
000CC3  2  90 02        	bcc :+
000CC5  2  D0 0D        	bne @false
000CC7  2               :
000CC7  2  B9 99 08     	lda sprites_yH, y
000CCA  2  DD 19 09     	cmp sprites_y1H, x
000CCD  2  90 02        	bcc :+
000CCF  2  D0 03        	bne @false
000CD1  2               :						; AND s(y).bottom_y <= s(x).top_y
000CD1  2               
000CD1  2               @true:
000CD1  2  A9 01        	lda #01
000CD3  2  60           	rts
000CD4  2               @false:
000CD4  2  A9 00        	lda #00
000CD6  2  60           	rts
000CD7  2               
000CD7  2               ;************************************************
000CD7  2               ; find colliding sprites
000CD7  2               ; return: a = no collision
000CD7  2               ;
000CD7  2               find_colliding:
000CD7  2  AD B9 0A     	lda nb_sprites
000CDA  2  3A           	dec
000CDB  2  85 30        	sta $30
000CDD  2  3A           	dec
000CDE  2  85 31        	sta $31
000CE0  2               
000CE0  2               @inner_loop:
000CE0  2  A6 30        	ldx $30
000CE2  2  A4 31        	ldy $31
000CE4  2  20 81 0C     	jsr aabb_collision
000CE7  2  D0 15        	bne @found
000CE9  2               
000CE9  2  C6 31        	dec $31
000CEB  2  30 02        	bmi @try_next
000CED  2  80 F1        	bra @inner_loop
000CEF  2               
000CEF  2               @try_next:
000CEF  2  A5 30        	lda $30
000CF1  2  3A           	dec
000CF2  2  F0 07        	beq @not_found
000CF4  2  85 30        	sta $30					; start comparison end - 1
000CF6  2  3A           	dec						; compare with start - 1 unless < 0
000CF7  2  85 31        	sta $31
000CF9  2  80 E5        	bra @inner_loop
000CFB  2               
000CFB  2               @not_found:
000CFB  2  A9 00        	lda #00
000CFD  2  60           	rts
000CFE  2               @found:
000CFE  2  A9 01        	lda #01
000D00  2  60           	rts
000D01  2               
000D01  2               ;************************************************
000D01  2               ; manage collisions if there were detected
000D01  2               ;
000D01  2               check_collision:
000D01  2  AD BA 0A     	lda collisions
000D04  2  F0 06        	beq @return
000D06  2               
000D06  2  9C BA 0A     	stz collisions		; clear the collision flag
000D09  2               
000D09  2  20 D7 0C     	jsr find_colliding
000D0C  2               
000D0C  2               @return:
000D0C  2  60           	rts
000D0D  2               
000D0D  2               .endscope
000D0D  2               
000D0D  1               .include "objects.asm"
000D0D  2               ;-----------------------------------------------------------------------------
000D0D  2               ;/////////////////////////////////////////////////////////////////////////////
000D0D  2               ;           start OBJECT code
000D0D  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000D0D  2               ;-----------------------------------------------------------------------------
000D0D  2               
000D0D  2               .scope Objects
000D0D  2               
000D0D  2  00 00        objects_map: .word 0
000D0F  2  00 00        objects_sprites: .word 0    ; vera memory of the start of the sprites
000D11  2               
000D11  2               .struct Object
000D11  2                   spriteID    .byte   ; ID of the vera sprite
000D11  2                   imageID     .byte   ; ID of the image in the spritesheet
000D11  2                   levelx      .word   ; level position
000D11  2                   levely      .word
000D11  2                   px          .word   ; screen position
000D11  2                   py          .word
000D11  2               .endstruct
000D11  2               
000D11  2               ;************************************************
000D11  2               ; init the object data of the level
000D11  2               ;
000D11  2               init:
000D11  2                   ; load the list of objects at the end of the previous load
000D11  2  AD 10 08         lda current_load
000D14  2  8D 0D 0D         sta objects_map
000D17  2  AD 11 08         lda current_load + 1
000D1A  2  8D 0E 0D         sta objects_map + 1
000D1D  2  A9 01 A2 08  	LOAD_FILE_NEXT fsobjects, (fsobjects_end-fsobjects)
000D21  2  A0 00 20 BA  
000D25  2  FF A9 0B A2  
000D40  2               
000D40  2                   ; load the sprites  of objects at the end of the previous vload
000D40  2  AD 12 08         lda Vera::vram_load
000D43  2  8D 0F 0D         sta objects_sprites
000D46  2  AD 13 08         lda Vera::vram_load + 1
000D49  2  8D 10 0D         sta objects_sprites + 1
000D4C  2  A9 01 A2 08  	VLOAD_FILE_NEXT fssprites1, (fssprites1_end-fssprites1)
000D50  2  A0 00 20 BA  
000D54  2  FF A9 0C A2  
000D6F  2               
000D6F  2                   ; add each available sprites on screen
000D6F  2  AD 0D 0D         lda objects_map
000D72  2  85 08            sta r3L
000D74  2  AD 0E 0D         lda objects_map + 1
000D77  2  85 09            sta r3H
000D79  2               
000D79  2  B2 08            lda (r3)
000D7B  2  85 31            sta $31     ; number of objects
000D7D  2  64 32            stz $32     ; object #0
000D7F  2               
000D7F  2  E6 08            inc r3L
000D81  2               
000D81  2               @loop:
000D81  2                   ; get a free sprite
000D81  2  20 18 0B         jsr Sprite::new
000D84  2  8A               txa
000D85  2  92 08            sta (r3)
000D87  2               
000D87  2                   ; load the first object
000D87  2  AD 0F 0D     	lda objects_sprites
000D8A  2  85 02        	sta r0L
000D8C  2  AD 10 0D     	lda objects_sprites + 1
000D8F  2  85 03        	sta r0H
000D91  2  20 B2 0B         jsr Sprite::vram_to_16_5
000D94  2  A5 04            lda r1L
000D96  2  85 02            sta r0L
000D98  2  A5 05            lda r1H
000D9A  2  85 03            sta r0H
000D9C  2               
000D9C  2  B2 08        	lda (r3)                        ; sprite id
000D9E  2  A8               tay
000D9F  2  A9 10           	lda #%00010000					; collision mask 1
000DA1  2  A2 50           	ldx #%01010000					; 16x16 sprite
000DA3  2  20 55 0B     	jsr Sprite::load
000DA6  2               
000DA6  2                   ; display the object
000DA6  2  B2 08        	lda (r3)                        ; sprite id
000DA8  2  A8               tay
000DA9  2  A2 0C        	ldx #SPRITE_ZDEPTH_TOP
000DAB  2  20 E0 0B     	jsr Sprite::display
000DAE  2               
000DAE  2                   ; position the first object
000DAE  2  20 E7 0D         jsr set_position_r3
000DB1  2               
000DB1  2                   ; last object ?
000DB1  2  C6 31            dec $31
000DB3  2  F0 11            beq @return
000DB5  2               
000DB5  2                   ; move to the next object
000DB5  2  18               clc
000DB6  2  A5 08            lda r3L
000DB8  2  69 0A            adc #.sizeof(Object)
000DBA  2  85 08            sta r3L
000DBC  2  A5 09            lda r3H
000DBE  2  69 00            adc #00
000DC0  2  85 09            sta r3H
000DC2  2               
000DC2  2  E6 32            inc $32                     ; object #next
000DC4  2  80 BB            bra @loop
000DC6  2               
000DC6  2               @return:
000DC6  2  60               rts
000DC7  2               
000DC7  2               ;************************************************
000DC7  2               ; change  position of the sprite (level view) => (screen view)
000DC7  2               ;   input: X = index of the object
000DC7  2               ;
000DC7  2               set_position_index:
000DC7  2  AD 0D 0D         lda objects_map
000DCA  2  85 08            sta r3L
000DCC  2  AD 0E 0D         lda objects_map + 1
000DCF  2  85 09            sta r3H
000DD1  2  E6 08            inc r3L
000DD3  2               
000DD3  2  E0 00            cpx #00                 ; ignore object 0
000DD5  2  F0 10            beq @next
000DD7  2               
000DD7  2               @mult:
000DD7  2  18               clc
000DD8  2  A5 08            lda r3L
000DDA  2  69 0A            adc #.sizeof(Object)
000DDC  2  85 08            sta r3L
000DDE  2  A5 09            lda r3H
000DE0  2  69 00            adc #00
000DE2  2  85 09            sta r3H
000DE4  2  CA               dex
000DE5  2  D0 F0            bne @mult               ; r2 = objects_map + X*sizeof(Object)
000DE7  2               
000DE7  2               @next:
000DE7  2               
000DE7  2               ;************************************************
000DE7  2               ; change  position of the sprite (level view) => (screen view)
000DE7  2               ;   input: R3 = start of the object
000DE7  2               ;
000DE7  2               set_position_r3:
000DE7  2                   ; screenX = levelX - layer1_scroll_x
000DE7  2  A0 02            ldy #Object::levelx
000DE9  2  38               sec
000DEA  2  B1 08            lda (r3), y
000DEC  2  ED 37 9F         sbc VERA_L1_hscrolllo
000DEF  2  85 02            sta r0L
000DF1  2  C8               iny
000DF2  2  B1 08            lda (r3), y
000DF4  2  ED 38 9F         sbc VERA_L1_hscrolllo + 1
000DF7  2  85 03            sta r0H
000DF9  2               
000DF9  2                   ; screenY = levelY - layer1_scroll_y
000DF9  2  A0 04            ldy #Object::levely
000DFB  2  38               sec
000DFC  2  B1 08            lda (r3), y
000DFE  2  ED 39 9F         sbc VERA_L1_vscrolllo
000E01  2  85 04            sta r1L
000E03  2  C8               iny
000E04  2  B1 08            lda (r3), y
000E06  2  ED 3A 9F         sbc VERA_L1_vscrolllo + 1
000E09  2  85 05            sta r1H
000E0B  2               
000E0B  2                   ; save the screen positions in the object
000E0B  2  A0 06            ldy #Object::px
000E0D  2  A5 02            lda r0L
000E0F  2  91 08            sta (r3), Y
000E11  2  C8               iny
000E12  2  A5 03            lda r0H
000E14  2  91 08            sta (r3), Y
000E16  2               
000E16  2  A0 08            ldy #Object::py
000E18  2  A5 04            lda r1L
000E1A  2  91 08            sta (r3), Y
000E1C  2  C8               iny
000E1D  2  A5 05            lda r1H
000E1F  2  91 08            sta (r3), Y
000E21  2               
000E21  2                   ; set the player position
000E21  2  B2 08        	lda (r3)                        ; sprite id
000E23  2  A8               tay
000E24  2               
000E24  2                   ; adresse of thepx, py attributes
000E24  2  18               clc
000E25  2  A5 08            lda r3L
000E27  2  69 06            adc #Object::px
000E29  2  85 02            sta r0L
000E2B  2  A5 09            lda r3H
000E2D  2  69 00            adc #00
000E2F  2  85 03            sta r0H
000E31  2  20 FF 0B     	jsr Sprite::position			; set position of the sprite
000E34  2               
000E34  2  60               rts
000E35  2               
000E35  2               ;************************************************
000E35  2               ; change position of all sprites when the layer moves (level view) => (screen view)
000E35  2               ;
000E35  2               fix_positions:
000E35  2  AD 0D 0D         lda objects_map
000E38  2  85 08            sta r3L
000E3A  2  AD 0E 0D         lda objects_map + 1
000E3D  2  85 09            sta r3H
000E3F  2               
000E3F  2  B2 08            lda (r3)
000E41  2  85 31            sta $31     ; number of objects
000E43  2  64 32            stz $32
000E45  2  E6 08            inc r3L
000E47  2               
000E47  2               @loop:
000E47  2                   ; position the first object
000E47  2  20 E7 0D         jsr set_position_r3
000E4A  2               
000E4A  2                   ; last object ?
000E4A  2  E6 32            inc $32
000E4C  2  C6 31            dec $31
000E4E  2  F0 0F            beq @return
000E50  2               
000E50  2                   ; move to the next object
000E50  2  18               clc
000E51  2  A5 08            lda r3L
000E53  2  69 0A            adc #.sizeof(Object)
000E55  2  85 08            sta r3L
000E57  2  A5 09            lda r3H
000E59  2  69 00            adc #00
000E5B  2  85 09            sta r3H
000E5D  2               
000E5D  2  80 E8            bra @loop
000E5F  2               
000E5F  2               @return:
000E5F  2  60               rts
000E60  2               
000E60  2               .endscope
000E60  2               
000E60  1               .include "layers.asm"
000E60  2               ;-----------------------------------------------------------------------------
000E60  2               ;/////////////////////////////////////////////////////////////////////////////
000E60  2               ; START Layers code
000E60  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000E60  2               ;-----------------------------------------------------------------------------
000E60  2               
000E60  2               .scope Layers
000E60  2               
000E60  2               HSCROLL = 0
000E60  2               VSCROLL = 2
000E60  2               
000E60  2               ; define size of tiles for layer
000E60  2               .macro VTILEMODE layer, mode
000E60  2               	lda veral0tilebase + layer * 7
000E60  2               	and #VERA_CLEAR_TILE_SIZE
000E60  2               	ora #mode
000E60  2               	sta veral0tilebase + layer * 7
000E60  2               .endmacro
000E60  2               
000E60  2               ; define number of tiles in the map
000E60  2               .macro VCONFIG_TILES layer,mode
000E60  2               	lda veral0config + layer * 7
000E60  2               	and #VERA_CONFIG_CLEAR_TILES
000E60  2               	ora #mode
000E60  2               	sta veral0config + layer * 7
000E60  2               .endmacro
000E60  2               
000E60  2               ; define number of colors for the map
000E60  2               .macro VCONFIG_DEPTH layer,mode
000E60  2               	lda veral0config + layer * 7
000E60  2               	and #VERA_CONFIG_CLEAR_DEPTH
000E60  2               	ora #mode
000E60  2               	sta veral0config + layer * 7
000E60  2               .endmacro
000E60  2               
000E60  2               ; set the tilebase for the layer
000E60  2               .macro VTILEBASE layer,addr
000E60  2                   lda veral0tilebase + layer * 7                  ; set memory for tilebase
000E60  2               	and #VERA_TILEBASE_CLEAR_ADR
000E60  2               	ora #(addr >> 9)
000E60  2               	sta veral0tilebase + layer * 7
000E60  2               .endmacro
000E60  2               
000E60  2               ; set the mapbase for the layer
000E60  2               .macro VMAPBASE layer,addr
000E60  2                   lda #(addr >> 9)         ; store 2 last bits
000E60  2                   sta veral0mapbase + layer * 7                   ; Store to Map Base Pointer
000E60  2               .endmacro
000E60  2               
000E60  2               ;************************************************
000E60  2               ; increase layer scrolling with a 8bits limit
000E60  2               ;	X: : 0 = horizontal
000E60  2               ;	   : 2 = vertical
000E60  2               ;	Y: limit
000E60  2               ;
000E60  2               scroll_inc_8:
000E60  2  84 02        	sty r0L
000E62  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
000E65  2  C5 02        	cmp r0L
000E67  2  F0 0F        	beq @noscroll
000E69  2               @scrollinc:
000E69  2  1A           	inc
000E6A  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
000E6D  2  D0 03        	bne @scrolled
000E6F  2  FE 38 9F     	inc VERA_L1_hscrollhi, x
000E72  2               @scrolled:
000E72  2               	; fix the objects position now that the layers scrolled
000E72  2  20 35 0E     	jsr Objects::fix_positions
000E75  2  A9 01        	lda #01		; clear ZERO => scrolled
000E77  2  60           	rts
000E78  2               @noscroll:
000E78  2  A9 00        	lda #00		; set ZERO => noscroll
000E7A  2  60           	rts
000E7B  2               
000E7B  2               ;************************************************
000E7B  2               ; increase layer scrolling with a 16bits limit
000E7B  2               ;	X: : 0 = horizontal
000E7B  2               ;	   : 2 = vertical
000E7B  2               ;	r0L: limit
000E7B  2               ;
000E7B  2               scroll_inc_16:
000E7B  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
000E7E  2  C5 02        	cmp r0L
000E80  2  D0 09        	bne @scrollinc								; if low bits are not equals to the limit low bits => safe to increase
000E82  2  A8           	tay
000E83  2  BD 38 9F     	lda VERA_L1_hscrollhi, x
000E86  2  C5 03        	cmp r0H
000E88  2  F0 10        	beq @noscroll								; if high bits are equals to the limit high bits => we reached the limit
000E8A  2  98           	tya
000E8B  2               @scrollinc:
000E8B  2  1A           	inc
000E8C  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
000E8F  2  D0 03        	bne @scrolled
000E91  2  FE 38 9F     	inc VERA_L1_hscrollhi, x
000E94  2               @scrolled:
000E94  2               	; fix the objects position now that the layers scrolled
000E94  2  20 35 0E     	jsr Objects::fix_positions
000E97  2  A9 01        	lda #01	; clear ZERO => scrolled
000E99  2  60           	rts
000E9A  2               @noscroll:
000E9A  2  A9 00        	lda #00	; set ZERO => noscroll
000E9C  2  60           	rts
000E9D  2               
000E9D  2               ; increase a layer scroll offset but do NOT overlap
000E9D  2               .macro VSCROLL_INC direction,limit
000E9D  2               .if limit > 255
000E9D  2               	LOAD_r0 limit
000E9D  2               	ldx #direction
000E9D  2               	jsr Layers::scroll_inc_16
000E9D  2               .else
000E9D  2               	ldy #limit
000E9D  2               	ldx #direction
000E9D  2               	jsr Layers::scroll_inc_8
000E9D  2               .endif
000E9D  2               .endmacro
000E9D  2               
000E9D  2               ;
000E9D  2               ;
000E9D  2               ; decrease a layer scroll offset
000E9D  2               ;	X : 0 = horizontal
000E9D  2               ;	  : 2 = vertical
000E9D  2               ;
000E9D  2               scroll_dec:
000E9D  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
000EA0  2  F0 06        	beq @scrollHI			; 00 => decrease high bits
000EA2  2  3A           	dec
000EA3  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
000EA6  2  80 0E        	bra @scrolled
000EA8  2               @scrollHI:
000EA8  2  BC 38 9F     	ldy VERA_L1_hscrollhi, x
000EAB  2  F0 0F        	beq @noscroll		; 0000 => no scrolling
000EAD  2  3A           	dec
000EAE  2  9D 37 9F     	sta VERA_L1_hscrolllo, x
000EB1  2  88           	dey
000EB2  2  98           	tya
000EB3  2  9D 38 9F     	sta VERA_L1_hscrollhi, x
000EB6  2               
000EB6  2               @scrolled:
000EB6  2               	; fix the objects position now that the layers scrolled
000EB6  2  20 35 0E     	jsr Objects::fix_positions
000EB9  2  A9 01        	lda #01		; clear ZERO => scrolled
000EBB  2  60           	rts
000EBC  2               
000EBC  2               @noscroll:
000EBC  2  A9 00        	lda #00		; set ZERO => noscroll
000EBE  2  60           	rts
000EBF  2               
000EBF  2               ;
000EBF  2               ; force layer0 scrolling to be half of the layer1 scrolling
000EBF  2               ;
000EBF  2               scroll_l0:
000EBF  2  BD 38 9F     	lda VERA_L1_hscrollhi, x	; layer0 hScroll is layer 1 / 2
000EC2  2  4A           	lsr
000EC3  2  9D 31 9F     	sta VERA_L0_hscrollhi, x
000EC6  2  BD 37 9F     	lda VERA_L1_hscrolllo, x
000EC9  2  6A           	ror
000ECA  2  9D 30 9F     	sta VERA_L0_hscrolllo, x
000ECD  2  60           	rts
000ECE  2               .endscope
000ECE  2               
000ECE  1               .include "player.asm"
000ECE  2               ;-----------------------------------------------------------------------------
000ECE  2               ;/////////////////////////////////////////////////////////////////////////////
000ECE  2               ; START player code
000ECE  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
000ECE  2               ;-----------------------------------------------------------------------------
000ECE  2               
000ECE  2               PLAYER_SPRITE_ANIMATION = 3
000ECE  2               
000ECE  2               JUMP_LO_TICKS = 10
000ECE  2               JUMP_HI_TICKS = 2
000ECE  2               FALL_LO_TICKS = 8
000ECE  2               FALL_HI_TICKS = 2
000ECE  2               
000ECE  2               .enum
000ECE  2               	STATUS_WALKING_IDLE
000ECE  2               	STATUS_WALKING
000ECE  2               	STATUS_CLIMBING
000ECE  2               	STATUS_CLIMBING_IDLE
000ECE  2               	STATUS_FALLING
000ECE  2               	STATUS_JUMPING
000ECE  2               	STATUS_JUMPING_IDLE
000ECE  2               .endenum
000ECE  2               
000ECE  2               .enum
000ECE  2               	SITTING_NO_SLOP
000ECE  2               	SITTING_ON_SLOPE
000ECE  2               	SITTING_ABOVE_SLOPE
000ECE  2               .endenum
000ECE  2               
000ECE  2               .enum TILE_ATTR
000ECE  2               	SOLID_GROUND = 1
000ECE  2               	SOLID_WALL = 2
000ECE  2               	SOLID_CEILING = 4
000ECE  2               	GRABBING = 8			; player can grab the tile (ladder, ledge, rope)
000ECE  2               .endenum
000ECE  2               
000ECE  2               .struct PLAYER
000ECE  2               	sprite			.byte	; sprite index
000ECE  2               	status			.byte	; status of the player : IDLE, WALKING, CLIMBING, FALLING
000ECE  2               	falling_ticks	.word	; ticks since the player is fllaing (thing t in gravity)
000ECE  2               	delta_x			.byte	; when driving by phisics, original delta_x value
000ECE  2               	animation_tick	.byte
000ECE  2               	spriteID 		.byte	; current animation loop start
000ECE  2               	spriteAnim 		.byte	; current frame
000ECE  2               	spriteAnimDirection .byte ; direction of the animation
000ECE  2               	px 				.word	; relative X & Y on screen
000ECE  2               	py 				.word
000ECE  2               	levelx			.word	; absolute X & Y in the level
000ECE  2               	levely			.word
000ECE  2               	flip 			.byte
000ECE  2               	tilemap			.word	; cached @ of the tilemap equivalent of the center of the player
000ECE  2               	vera_bitmaps    .res 	2*12	; 9 words to store vera bitmaps address
000ECE  2               .endstruct
000ECE  2               
000ECE  2               .macro m_status value
000ECE  2               	lda #(value)
000ECE  2               	sta player0 + PLAYER::status
000ECE  2               .endmacro
000ECE  2               
000ECE  2               .scope Player
000ECE  2               
000ECE  2               .macro SET_SPRITE id, frame
000ECE  2               	lda #id
000ECE  2               	sta player0 + PLAYER::spriteID
000ECE  2               	lda #frame
000ECE  2               	sta player0 + PLAYER::spriteAnim
000ECE  2               	jsr set_bitmap
000ECE  2               .endmacro
000ECE  2               
000ECE  2               ;************************************************
000ECE  2               ; player sprites status
000ECE  2               ;
000ECE  2               .enum Sprites
000ECE  2               	FRONT = 0
000ECE  2               	LEFT = 3
000ECE  2               	CLIMB = 6
000ECE  2               	HANG = 9
000ECE  2               .endenum
000ECE  2               
000ECE  2               ;************************************************
000ECE  2               ; local variables
000ECE  2               ;
000ECE  2               
000ECE  2  00           player_on_slop: .byte 0
000ECF  2  00           ladders: .byte 0
000ED0  2  00           test_right_left: .byte 0
000ED1  2               
000ED1  2               ;************************************************
000ED1  2               ; init the player data
000ED1  2               ;
000ED1  2               init:
000ED1  2  9C 4F 1B     	stz player0 + PLAYER::sprite
000ED4  2  A9 0A        	lda #10
000ED6  2  8D 54 1B     	sta player0 + PLAYER::animation_tick
000ED9  2  A9 00        	lda #STATUS_WALKING_IDLE
000EDB  2  8D 50 1B     	sta player0 + PLAYER::status
000EDE  2  9C 51 1B     	stz player0 + PLAYER::falling_ticks
000EE1  2  9C 52 1B     	stz player0 + PLAYER::falling_ticks + 1
000EE4  2  A9 03        	lda #Player::Sprites::LEFT
000EE6  2  8D 55 1B     	sta player0 + PLAYER::spriteID
000EE9  2  9C 56 1B     	stz player0 + PLAYER::spriteAnim
000EEC  2  A9 01        	lda #1
000EEE  2  8D 57 1B     	sta player0 + PLAYER::spriteAnimDirection
000EF1  2  9C 58 1B     	stz player0 + PLAYER::px
000EF4  2  9C 59 1B     	stz player0 + PLAYER::px+1
000EF7  2  9C 5A 1B     	stz player0 + PLAYER::py
000EFA  2  9C 5B 1B     	stz player0 + PLAYER::py+1
000EFD  2  9C 5C 1B     	stz player0 + PLAYER::levelx
000F00  2  9C 5D 1B     	stz player0 + PLAYER::levelx+1
000F03  2  9C 5E 1B     	stz player0 + PLAYER::levely
000F06  2  9C 5F 1B     	stz player0 + PLAYER::levely+1
000F09  2  9C 60 1B     	stz player0 + PLAYER::flip
000F0C  2               
000F0C  2               	; load sprites data at the end of the tiles
000F0C  2  A9 01 A2 08  	VLOAD_FILE fssprite, (fsspriteend-fssprite), (VRAM_tiles + tiles * tile_size)
000F10  2  A0 00 20 BA  
000F14  2  FF A9 0B A2  
000F2D  2               
000F2D  2  AD 63 1B     	lda player0 + PLAYER::vera_bitmaps
000F30  2  85 02        	sta r0L
000F32  2  AD 64 1B     	lda player0 + PLAYER::vera_bitmaps+1
000F35  2  85 03        	sta r0H
000F37  2               
000F37  2  AC 4F 1B     	ldy player0 + PLAYER::sprite
000F3A  2  A9 10        	lda #%00010000					; collision mask 1
000F3C  2  A2 A0        	ldx #%10100000					; 32x32 sprite
000F3E  2  20 55 0B     	jsr Sprite::load
000F41  2               
000F41  2  A9 08        	lda #08
000F43  2  85 02        	sta r0L
000F45  2  A9 00        	lda #00
000F47  2  85 03        	sta r0H
000F49  2  A9 10        	lda #16
000F4B  2  85 04        	sta r1L
000F4D  2  A9 20        	lda #32
000F4F  2  85 05        	sta r1H
000F51  2  AC 4F 1B     	ldy player0 + PLAYER::sprite
000F54  2  20 9D 0B     	jsr Sprite::set_aabb			; collision box (8,0) -> (24, 32)
000F57  2               
000F57  2               	; turn sprite 0 on
000F57  2  AC 4F 1B     	ldy player0 + PLAYER::sprite
000F5A  2  A2 0C        	ldx #SPRITE_ZDEPTH_TOP
000F5C  2  20 E0 0B     	jsr Sprite::display
000F5F  2               
000F5F  2               	; register the vera simplified memory 12:5
000F5F  2  A2 00        	ldx #0
000F61  2  A0 0C        	ldy #(3*4)
000F63  2  A9 00 85 04  	LOAD_r1 (VRAM_tiles + tiles * tile_size)
000F67  2  A9 41 85 05  
000F6B  2               
000F6B  2               @loop:
000F6B  2               	; load full VERA memory (12:0) into R0
000F6B  2  A5 04        	lda r1L
000F6D  2  85 02        	sta r0L
000F6F  2  A5 05        	lda r1H
000F71  2  85 03        	sta r0H
000F73  2               
000F73  2               	; convert full addr to vera mode (bit shiting >> 5)
000F73  2  A5 03        	lda r0H
000F75  2  4A           	lsr
000F76  2  66 02        	ror r0L
000F78  2  4A           	lsr
000F79  2  66 02        	ror r0L
000F7B  2  4A           	lsr
000F7C  2  66 02        	ror r0L
000F7E  2  4A           	lsr
000F7F  2  66 02        	ror r0L						; bit shift 4x 16 bits vera memory
000F81  2  4A           	lsr
000F82  2  66 02        	ror r0L						; bit shift 4x 16 bits vera memory
000F84  2               
000F84  2               	; store 12:5 into our cache
000F84  2  9D 63 1B     	sta player0 + PLAYER::vera_bitmaps, x
000F87  2  E8           	inx
000F88  2  A5 02        	lda r0L
000F8A  2  9D 63 1B     	sta player0 + PLAYER::vera_bitmaps, x
000F8D  2  E8           	inx
000F8E  2               
000F8E  2               	; increase the vram (+4 r1H = +1024 r1)
000F8E  2  18           	clc
000F8F  2  A5 05        	lda r1H
000F91  2  69 04        	adc #4
000F93  2  85 05        	sta r1H
000F95  2               
000F95  2  88           	dey
000F96  2  D0 D3        	bne @loop
000F98  2               
000F98  2               	; set first bitmap
000F98  2  20 AB 0F     	jsr set_bitmap
000F9B  2  60           	rts
000F9C  2               
000F9C  2               ;************************************************
000F9C  2               ; force the current player sprite at its position
000F9C  2               ;
000F9C  2               position_set:
000F9C  2  AC 4F 1B     	ldy player0 + PLAYER::sprite
000F9F  2  A9 58 85 02  	LOAD_r0 (player0 + PLAYER::px)
000FA3  2  A9 1B 85 03  
000FA7  2  20 FF 0B     	jsr Sprite::position			; set position of the sprite
000FAA  2  60           	rts
000FAB  2               
000FAB  2               ;************************************************
000FAB  2               ; change the player bitmap
000FAB  2               ;
000FAB  2               set_bitmap:
000FAB  2  18           	clc
000FAC  2  AD 56 1B     	lda player0 + PLAYER::spriteAnim
000FAF  2  6D 55 1B     	adc player0 + PLAYER::spriteID
000FB2  2  0A           	asl						; convert sprite index to work position
000FB3  2  AA           	tax
000FB4  2               
000FB4  2               	; extract the vera bitmap address in vera format (12:5 bits)
000FB4  2  BD 63 1B     	lda player0 + PLAYER::vera_bitmaps, x
000FB7  2  85 03        	sta r0H
000FB9  2  BD 64 1B     	lda player0 + PLAYER::vera_bitmaps + 1, x
000FBC  2  85 02        	sta r0L
000FBE  2               
000FBE  2  AC 4F 1B     	ldy player0 + PLAYER::sprite
000FC1  2  20 CE 0B     	jsr Sprite::set_bitmap
000FC4  2  60           	rts
000FC5  2               
000FC5  2               ;************************************************
000FC5  2               ; increase player X position
000FC5  2               ;	modify r0
000FC5  2               ;
000FC5  2               position_x_inc:
000FC5  2               	; move the absolute position levelx + 1
000FC5  2  AD 5C 1B     	lda player0 + PLAYER::levelx
000FC8  2  AE 5D 1B     	ldx player0 + PLAYER::levelx + 1
000FCB  2  C9 E0        	cmp #<(LEVEL_WIDTH - 32)
000FCD  2  D0 04        	bne @incLOW1
000FCF  2  E0 01        	cpx #>(LEVEL_WIDTH - 32)
000FD1  2  F0 48        	beq @no_move						; we are at the level limit
000FD3  2               @incLOW1:
000FD3  2  1A           	inc
000FD4  2  8D 5C 1B     	sta player0 + PLAYER::levelx
000FD7  2  D0 04        	bne @inc_screen_x
000FD9  2               @incHi:
000FD9  2  E8           	inx
000FDA  2  8E 5D 1B     	stx player0 + PLAYER::levelx + 1
000FDD  2               
000FDD  2               @inc_screen_x:
000FDD  2               	; distance from layer border to sprite absolute position
000FDD  2  38           	sec
000FDE  2  AD 5C 1B     	lda player0 + PLAYER::levelx
000FE1  2  ED 37 9F     	sbc VERA_L1_hscrolllo
000FE4  2  85 02        	sta r0L
000FE6  2  AD 5D 1B     	lda player0 + PLAYER::levelx + 1
000FE9  2  ED 38 9F     	sbc VERA_L1_hscrollhi
000FEC  2  85 03        	sta r0H
000FEE  2               
000FEE  2  D0 17        	bne @move_sprite_upper
000FF0  2  A6 03        	ldx r0H
000FF2  2  A5 02        	lda r0L
000FF4  2  C9 E0        	cmp #<(SCREEN_WIDTH	- 96)
000FF6  2  90 19        	bcc @move_sprite
000FF8  2               
000FF8  2               @move_layers:
000FF8  2               	; keep the sprite onscreen 224, for level 224->416
000FF8  2  A0 BF A2 00  	VSCROLL_INC Layers::HSCROLL,(32*16-320 - 1)	; 32 tiles * 16 pixels per tiles - 320 screen pixels
000FFC  2  20 60 0E     
000FFF  2  F0 06        	beq @move_sprite_upper
001001  2  A2 00        	ldx #Layers::HSCROLL
001003  2  20 BF 0E     	jsr Layers::scroll_l0
001006  2  60           	rts
001007  2               
001007  2               @move_sprite_upper:
001007  2  AD 58 1B     	lda player0 + PLAYER::px
00100A  2  AE 59 1B     	ldx player0 + PLAYER::px + 1
00100D  2  1A           	inc
00100E  2  D0 01        	bne @move_sprite
001010  2  E8           	inx
001011  2               
001011  2               @move_sprite:
001011  2  8D 58 1B     	sta player0 + PLAYER::px
001014  2  8E 59 1B     	stx player0 + PLAYER::px + 1
001017  2  20 9C 0F     	jsr Player::position_set
00101A  2  60           	rts
00101B  2               
00101B  2               @no_move:
00101B  2  60           	rts
00101C  2               
00101C  2               ;************************************************
00101C  2               ; decrease player position X unless at 0
00101C  2               ;
00101C  2               position_x_dec:
00101C  2               	; move the absolute position levelx + 1
00101C  2  AD 5C 1B     	lda player0 + PLAYER::levelx
00101F  2  D0 05        	bne @decLOW
001021  2  AE 5D 1B     	ldx player0 + PLAYER::levelx + 1
001024  2  F0 49        	beq @no_move						; we are at Y == 0
001026  2               @decLOW:
001026  2  3A           	dec
001027  2  8D 5C 1B     	sta player0 + PLAYER::levelx
00102A  2  C9 FF        	cmp #$ff
00102C  2  D0 04        	bne @dec_screen_x
00102E  2               @decHi:
00102E  2  CA           	dex
00102F  2  8E 5D 1B     	stx player0 + PLAYER::levelx + 1
001032  2               
001032  2               @dec_screen_x:
001032  2               	; distance from layer border to sprite absolute position
001032  2  38           	sec
001033  2  AD 5C 1B     	lda player0 + PLAYER::levelx
001036  2  ED 37 9F     	sbc VERA_L1_hscrolllo
001039  2  85 02        	sta r0L
00103B  2  AD 5D 1B     	lda player0 + PLAYER::levelx + 1
00103E  2  ED 38 9F     	sbc VERA_L1_hscrollhi
001041  2  85 03        	sta r0H
001043  2               
001043  2  D0 15        	bne @move_sprite_lower				; > 256, we are far off from the border, so move the sprite
001045  2               
001045  2  A5 02        	lda r0L
001047  2  30 11        	bmi @move_sprite_lower					; > 127, move the sprites
001049  2  C9 40        	cmp #64
00104B  2  B0 0D        	bcs @move_sprite_lower					; if > 64, move the sprites
00104D  2               
00104D  2               @move_layers:
00104D  2               	; keep the sprite onscreen 224, for level 224->416
00104D  2  A2 00        	ldx #Layers::HSCROLL
00104F  2  20 9D 0E     	jsr Layers::scroll_dec
001052  2  F0 06        	beq @move_sprite_lower
001054  2  A2 00        	ldx #Layers::HSCROLL
001056  2  20 BF 0E     	jsr Layers::scroll_l0
001059  2  60           	rts
00105A  2               
00105A  2               @move_sprite_lower:
00105A  2  AD 58 1B     	lda player0 + PLAYER::px
00105D  2  AE 59 1B     	ldx player0 + PLAYER::px + 1
001060  2  3A           	dec
001061  2  C9 FF        	cmp #$ff
001063  2  D0 01        	bne @move_sprite
001065  2  CA           	dex
001066  2               
001066  2               @move_sprite:
001066  2  8D 58 1B     	sta player0 + PLAYER::px
001069  2  8E 59 1B     	stx player0 + PLAYER::px + 1
00106C  2  20 9C 0F     	jsr Player::position_set
00106F  2               
00106F  2               @no_move:
00106F  2  60           	rts
001070  2               
001070  2               ;************************************************
001070  2               ; increase player Y position
001070  2               ;
001070  2               position_y_inc:
001070  2               	; move the absolute position levelx + 1
001070  2  AD 5E 1B     	lda player0 + PLAYER::levely
001073  2  AE 5F 1B     	ldx player0 + PLAYER::levely + 1
001076  2  C9 E0        	cmp #<(LEVEL_HEIGHT - 32)
001078  2  D0 04        	bne @incLOW1
00107A  2  E0 01        	cpx #>(LEVEL_HEIGHT - 32)
00107C  2  F0 4E        	beq @no_move						; we are at the level limit
00107E  2               @incLOW1:
00107E  2  1A           	inc
00107F  2  8D 5E 1B     	sta player0 + PLAYER::levely
001082  2  D0 04        	bne @inc_screen_y
001084  2               @incHi:
001084  2  E8           	inx
001085  2  8E 5F 1B     	stx player0 + PLAYER::levely + 1
001088  2               
001088  2               @inc_screen_y:
001088  2               	; distance from layer border to sprite absolute position
001088  2  38           	sec
001089  2  AD 5E 1B     	lda player0 + PLAYER::levely
00108C  2  ED 39 9F     	sbc VERA_L1_vscrolllo
00108F  2  85 02        	sta r0L
001091  2  AD 5F 1B     	lda player0 + PLAYER::levely + 1
001094  2  ED 3A 9F     	sbc VERA_L1_vscrollhi
001097  2  85 03        	sta r0H
001099  2               
001099  2  D0 1D        	bne @move_sprite_upper
00109B  2  A6 03        	ldx r0H
00109D  2  A5 02        	lda r0L
00109F  2  C9 B0        	cmp #<(SCREEN_HEIGHT - 64)
0010A1  2  90 1F        	bcc @move_sprite
0010A3  2               
0010A3  2               @move_layers:
0010A3  2               	; keep the sprite onscreen 224, for level 224->416
0010A3  2  A9 0F 85 02  	VSCROLL_INC Layers::VSCROLL,(32*16-240 - 1)	; 32 tiles * 16 pixels per tiles - 240 screen pixels
0010A7  2  A9 01 85 03  
0010AB  2  A2 02 20 7B  
0010B0  2  F0 06        	beq @move_sprite_upper
0010B2  2  A2 02        	ldx #Layers::VSCROLL
0010B4  2  20 BF 0E     	jsr Layers::scroll_l0
0010B7  2  60           	rts
0010B8  2               
0010B8  2               @move_sprite_upper:
0010B8  2  AD 5A 1B     	lda player0 + PLAYER::py
0010BB  2  AE 5B 1B     	ldx player0 + PLAYER::py + 1
0010BE  2  1A           	inc
0010BF  2  D0 01        	bne @move_sprite
0010C1  2  E8           	inx
0010C2  2               
0010C2  2               @move_sprite:
0010C2  2  8D 5A 1B     	sta player0 + PLAYER::py
0010C5  2  8E 5B 1B     	stx player0 + PLAYER::py + 1
0010C8  2  20 9C 0F     	jsr Player::position_set
0010CB  2  60           	rts
0010CC  2               
0010CC  2               @no_move:
0010CC  2  60           	rts
0010CD  2               
0010CD  2               ;;
0010CD  2  AD 5A 1B     	lda player0 + PLAYER::py
0010D0  2  C9 D0        	cmp #(SCREEN_HEIGHT-32)
0010D2  2  F0 09        	beq @moveleftP0
0010D4  2  1A           	inc
0010D5  2  8D 5A 1B     	sta player0 + PLAYER::py
0010D8  2  D0 03        	bne @moveleftP0
0010DA  2  EE 5B 1B     	inc player0 + PLAYER::py + 1
0010DD  2               @moveleftP0:
0010DD  2  20 9C 0F     	jsr Player::position_set
0010E0  2  60           	rts
0010E1  2               
0010E1  2               ;************************************************
0010E1  2               ; decrease player position X unless at 0
0010E1  2               ;
0010E1  2               position_y_dec:
0010E1  2               	; move the absolute position levelx + 1
0010E1  2  AD 5E 1B     	lda player0 + PLAYER::levely
0010E4  2  D0 05        	bne @decLOW
0010E6  2  AE 5F 1B     	ldx player0 + PLAYER::levely + 1
0010E9  2  F0 49        	beq @no_move						; we are at Y == 0
0010EB  2               @decLOW:
0010EB  2  3A           	dec
0010EC  2  8D 5E 1B     	sta player0 + PLAYER::levely
0010EF  2  C9 FF        	cmp #$ff
0010F1  2  D0 04        	bne @dec_screen_y
0010F3  2               @decHi:
0010F3  2  CA           	dex
0010F4  2  8E 5F 1B     	stx player0 + PLAYER::levely + 1
0010F7  2               
0010F7  2               @dec_screen_y:
0010F7  2               	; distance from layer border to sprite absolute position
0010F7  2  38           	sec
0010F8  2  AD 5E 1B     	lda player0 + PLAYER::levely
0010FB  2  ED 39 9F     	sbc VERA_L1_vscrolllo
0010FE  2  85 02        	sta r0L
001100  2  AD 5F 1B     	lda player0 + PLAYER::levely + 1
001103  2  ED 3A 9F     	sbc VERA_L1_vscrollhi
001106  2  85 03        	sta r0H
001108  2               
001108  2  D0 15        	bne @move_sprite_lower				; > 256, we are far off from the border, so move the sprite
00110A  2               
00110A  2  A5 02        	lda r0L
00110C  2  30 11        	bmi @move_sprite_lower					; > 127, move the sprites
00110E  2  C9 20        	cmp #32
001110  2  B0 0D        	bcs @move_sprite_lower					; if > 32, move the sprites
001112  2               
001112  2               @move_layers:
001112  2               	; keep the sprite onscreen 224, for level 224->416
001112  2  A2 02        	ldx #Layers::VSCROLL
001114  2  20 9D 0E     	jsr Layers::scroll_dec
001117  2  F0 06        	beq @move_sprite_lower
001119  2  A2 02        	ldx #Layers::VSCROLL
00111B  2  20 BF 0E     	jsr Layers::scroll_l0
00111E  2  60           	rts
00111F  2               
00111F  2               @move_sprite_lower:
00111F  2  AD 5A 1B     	lda player0 + PLAYER::py
001122  2  AE 5B 1B     	ldx player0 + PLAYER::py + 1
001125  2  3A           	dec
001126  2  C9 FF        	cmp #$ff
001128  2  D0 01        	bne @move_sprite
00112A  2  CA           	dex
00112B  2               
00112B  2               @move_sprite:
00112B  2  8D 5A 1B     	sta player0 + PLAYER::py
00112E  2  8E 5B 1B     	stx player0 + PLAYER::py + 1
001131  2  20 9C 0F     	jsr Player::position_set
001134  2               
001134  2               @no_move:
001134  2  60           	rts
001135  2               
001135  2               ;************************************************
001135  2               ; hide the current sprite
001135  2               ;
001135  2               hide1:
001135  2  DB           	stp
001136  2  18           	clc
001137  2  AD 56 1B     	lda player0 + PLAYER::spriteAnim
00113A  2  6D 55 1B     	adc player0 + PLAYER::spriteID
00113D  2  A8           	tay		; sprite index
00113E  2  A2 00        	ldx #SPRITE_ZDEPTH_DISABLED
001140  2  20 E0 0B     	jsr Sprite::display			; turn current sprite off
001143  2  60           	rts
001144  2               
001144  2               ;************************************************
001144  2               ; Animate the player if needed
001144  2               ;
001144  2               animate:
001144  2  AD 50 1B     	lda player0 + PLAYER::status
001147  2  C9 00        	cmp #STATUS_WALKING_IDLE
001149  2  F0 3A        	beq @end
00114B  2  C9 04        	cmp #STATUS_FALLING
00114D  2  F0 36        	beq @end
00114F  2  C9 03        	cmp #STATUS_CLIMBING_IDLE
001151  2  F0 32        	beq @end
001153  2               
001153  2  CE 54 1B     	dec player0 + PLAYER::animation_tick
001156  2  D0 2D        	bne @end
001158  2               
001158  2  A9 0A        	lda #10
00115A  2  8D 54 1B     	sta player0 + PLAYER::animation_tick	; reset animation tick counter
00115D  2               
00115D  2  18           	clc
00115E  2  AD 56 1B     	lda player0 + PLAYER::spriteAnim
001161  2  6D 57 1B     	adc player0 + PLAYER::spriteAnimDirection
001164  2  F0 06        	beq @set_sprite_anim_increase					; reached 0
001166  2  C9 03        	cmp #3
001168  2  F0 0B        	beq @set_sprite_anim_decrease
00116A  2  80 10        	bra @set_sprite_on
00116C  2               @set_sprite_anim_increase:
00116C  2  A9 01        	lda #01
00116E  2  8D 57 1B     	sta player0 + PLAYER::spriteAnimDirection
001171  2  A9 00        	lda #0
001173  2  80 07        	bra @set_sprite_on
001175  2               @set_sprite_anim_decrease:
001175  2  A9 FF        	lda #$ff
001177  2  8D 57 1B     	sta player0 + PLAYER::spriteAnimDirection
00117A  2  A9 02        	lda #2
00117C  2               @set_sprite_on:
00117C  2  8D 56 1B     	sta player0 + PLAYER::spriteAnim	; turn next sprite on
00117F  2  20 AB 0F     	jsr Player::set_bitmap
001182  2  20 9C 0F     	jsr Player::position_set
001185  2               @end:
001185  2  60           	rts
001186  2               
001186  2               ;************************************************
001186  2               ; position of the player on the layer1 tilemap
001186  2               ;	modified : r1
001186  2               ;	output : r0
001186  2               ;
001186  2               get_tilemap_position:
001186  2  18           	clc
001187  2  AD 5E 1B     	lda player0 + PLAYER::levely		; sprite screen position
00118A  2  85 02        	sta r0L
00118C  2  AD 5F 1B     	lda player0 + PLAYER::levely + 1
00118F  2  85 03        	sta r0H							; r0 = sprite absolute position Y in the level
001191  2               
001191  2  A5 02        	lda r0L
001193  2  29 F0        	and #%11110000
001195  2  85 02        	sta r0L
001197  2  A5 03        	lda r0H
001199  2  85 03        	sta r0H
00119B  2  A5 02        	lda r0L
00119D  2  0A           	asl
00119E  2  26 03        	rol r0H
0011A0  2  85 02        	sta r0L 						; r0 = first tile of the tilemap in the row
0011A2  2               									; spriteY / 16 (convert to tile Y) * 32 (number of tiles per row in the tile map)
0011A2  2               
0011A2  2  AD 5C 1B     	lda player0 + PLAYER::levelx		; sprite screen position
0011A5  2  85 04        	sta r1L
0011A7  2  AD 5D 1B     	lda player0 + PLAYER::levelx + 1
0011AA  2  85 05        	sta r1H							; r1 = sprite absolute position X in the level
0011AC  2               
0011AC  2  4A           	lsr
0011AD  2  66 04        	ror r1L
0011AF  2  4A           	lsr
0011B0  2  66 04        	ror r1L
0011B2  2  4A           	lsr
0011B3  2  66 04        	ror r1L
0011B5  2  4A           	lsr
0011B6  2  66 04        	ror r1L
0011B8  2  85 05        	sta r1H 					; r1 = tile X in the row
0011BA  2               								; sprite X /16 (convert to tile X)
0011BA  2               
0011BA  2  18           	clc
0011BB  2  A5 02        	lda r0L
0011BD  2  65 04        	adc r1L
0011BF  2  85 02        	sta r0L
0011C1  2  A5 03        	lda r0H
0011C3  2  65 05        	adc r1H
0011C5  2  85 03        	sta r0H						; r0 = tile position in the tilemap
0011C7  2               
0011C7  2  18           	clc
0011C8  2  A5 03        	lda r0H
0011CA  2  69 A0        	adc #>HIMEM
0011CC  2  85 03        	sta r0H						; r0 = tile position in the memory tilemap
0011CE  2  60           	rts
0011CF  2               
0011CF  2               ;************************************************
0011CF  2               ; force player status to be idle
0011CF  2               ;
0011CF  2               set_idle:
0011CF  2  AD 50 1B     	lda player0 + PLAYER::status
0011D2  2  C9 01        	cmp #STATUS_WALKING
0011D4  2  F0 06        	beq @set_idle_walking
0011D6  2  C9 02        	cmp #STATUS_CLIMBING
0011D8  2  F0 08        	beq @set_idle_climbing
0011DA  2  60           	rts							; keep the current value
0011DB  2               @set_idle_jump:
0011DB  2  60           	rts
0011DC  2               @set_idle_walking:
0011DC  2  A9 00 8D 50  	m_status STATUS_WALKING_IDLE
0011E0  2  1B           
0011E1  2  60           	rts
0011E2  2               @set_idle_climbing:
0011E2  2  A9 03 8D 50  	m_status STATUS_CLIMBING_IDLE
0011E6  2  1B           
0011E7  2  60           	rts
0011E8  2               
0011E8  2               ;************************************************
0011E8  2               ; check if the player sits on a solid tile
0011E8  2               ;
0011E8  2               physics:
0011E8  2  20 86 11     	jsr get_tilemap_position
0011EB  2  A5 02 8D 61  	SAVE_r0 player0 + PLAYER::tilemap	; cache the tilemap @
0011EF  2  1B A5 03 8D  
0011F3  2  62 1B        
0011F5  2               
0011F5  2  AD 50 1B     	lda player0 + PLAYER::status
0011F8  2  C9 02        	cmp #STATUS_CLIMBING
0011FA  2  F0 0B        	beq @return1
0011FC  2  C9 03        	cmp #STATUS_CLIMBING_IDLE
0011FE  2  F0 07        	beq @return1
001200  2  C9 05        	cmp #STATUS_JUMPING
001202  2  D0 04        	bne @fall
001204  2  4C AC 12     	jmp @jump
001207  2               @return1:
001207  2  60           	rts
001208  2               
001208  2               	;
001208  2               	; deal with gravity driven falling
001208  2               	;
001208  2               @fall:
001208  2               .ifdef DEBUG
001208  2               	CHECK_DEBUG
001208  2               .endif
001208  2  20 8D 13     	jsr check_collision_down
00120B  2  F0 03        	beq @check_on_slope				; no solid tile below the player, still check if the player is ON a slope
00120D  2  4C 9F 12     	jmp @sit_on_solid				; solid tile below the player that is not a slope
001210  2               
001210  2               @check_on_slope:
001210  2  20 0E 14     	jsr check_player_on_slop
001213  2  F0 23        	beq @no_collision_down			; not ON a slope, and not ABOVE a solid tile => fall
001215  2               
001215  2               @on_slope:
001215  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
001217  2  F0 0B        	beq @slope_left
001219  2               @slope_right:
001219  2  AD 5C 1B     	lda player0 + PLAYER::levelx	; X position defines how far down Y can go
00121C  2  29 0F        	and #%00001111
00121E  2  49 0F        	eor #%00001111					; X = 0 => Y can go up to 15
001220  2  85 30        	sta $30
001222  2  80 09        	bra @slope_y
001224  2               @slope_left:
001224  2  AD 5C 1B     	lda player0 + PLAYER::levelx	; X position defines how far down Y can go
001227  2  29 0F        	and #%00001111
001229  2  85 30        	sta $30
00122B  2  80 00        	bra @slope_y
00122D  2               @slope_y:
00122D  2  AD 5E 1B     	lda player0 + PLAYER::levely
001230  2  29 0F        	and #%00001111
001232  2  C5 30        	cmp $30
001234  2  30 02        	bmi @no_collision_down
001236  2  80 67        	bra @sit_on_solid
001238  2               
001238  2               @no_collision_down:
001238  2               	; if the player is already falling, increase t
001238  2  AD 50 1B     	lda player0 + PLAYER::status
00123B  2  C9 04        	cmp #STATUS_FALLING
00123D  2  F0 0D        	beq @increase_ticks
00123F  2               
00123F  2               	; let the player fall
00123F  2  A9 04        	lda #STATUS_FALLING
001241  2  8D 50 1B     	sta player0 + PLAYER::status
001244  2  A9 08        	lda #FALL_LO_TICKS
001246  2  8D 51 1B     	sta player0 + PLAYER::falling_ticks	; reset t
001249  2  9C 52 1B     	stz player0 + PLAYER::falling_ticks + 1
00124C  2               @increase_ticks:
00124C  2  CE 51 1B     	dec player0 + PLAYER::falling_ticks	; increase HI every 10 refresh
00124F  2  D0 08        	bne @drive_fall
001251  2  A9 08        	lda #FALL_LO_TICKS
001253  2  8D 51 1B     	sta player0 + PLAYER::falling_ticks	; reset t
001256  2  EE 52 1B     	inc player0 + PLAYER::falling_ticks + 1
001259  2               
001259  2               @drive_fall:
001259  2  AD 52 1B     	lda player0 + PLAYER::falling_ticks + 1
00125C  2  F0 3C        	beq @fall_once
00125E  2  85 14        	sta r9L
001260  2               @loop_fall:
001260  2  20 70 10     	jsr position_y_inc
001263  2  20 86 11     	jsr get_tilemap_position
001266  2  A5 02 8D 61  	SAVE_r0 player0 + PLAYER::tilemap
00126A  2  1B A5 03 8D  
00126E  2  62 1B        
001270  2               
001270  2               	; test reached solid ground
001270  2  20 8D 13     	jsr check_collision_down
001273  2  D0 2A        	bne @sit_on_solid
001275  2               
001275  2               @loop_fall_no_collision:
001275  2  C6 14        	dec r9L
001277  2  D0 E7        	bne @loop_fall						; take t in count for gravity
001279  2               
001279  2               @apply_delta_x:
001279  2  AD 53 1B     	lda player0 + PLAYER::delta_x		; apply delatx
00127C  2  F0 2D        	beq @return
00127E  2  30 0D        	bmi @fall_left
001280  2               @fall_right:
001280  2  20 7B 13     	jsr check_collision_right
001283  2  F0 04        	beq @no_fcollision_right
001285  2               @fcollision_right:
001285  2  9C 53 1B     	stz player0 + PLAYER::delta_x		; cancel deltaX to transform to vertical movement
001288  2  60           	rts
001289  2               @no_fcollision_right:
001289  2  20 C5 0F     	jsr position_x_inc
00128C  2  60           	rts
00128D  2               @fall_left:
00128D  2  20 84 13     	jsr check_collision_left
001290  2  F0 04        	beq @no_fcollision_left
001292  2               @fcollision_left:
001292  2  9C 53 1B     	stz player0 + PLAYER::delta_x		; cancel deltaX to transform to vertical movement
001295  2  60           	rts
001296  2               @no_fcollision_left:
001296  2  20 1C 10     	jsr position_x_dec
001299  2  60           	rts
00129A  2               
00129A  2               @fall_once:
00129A  2  20 70 10     	jsr position_y_inc
00129D  2  80 DA        	bra @apply_delta_x
00129F  2               
00129F  2               @sit_on_solid:
00129F  2               	; change the status if falling
00129F  2  AD 50 1B     	lda player0 + PLAYER::status
0012A2  2  C9 04        	cmp #STATUS_FALLING
0012A4  2  D0 05        	bne @return
0012A6  2  A9 00        	lda #STATUS_WALKING_IDLE
0012A8  2  8D 50 1B     	sta player0 + PLAYER::status
0012AB  2               @return:
0012AB  2  60           	rts
0012AC  2               
0012AC  2               	;
0012AC  2               	; deal with gravity driven jumping
0012AC  2               	;
0012AC  2               @jump:
0012AC  2               @decrease_ticks:
0012AC  2  CE 51 1B     	dec player0 + PLAYER::falling_ticks	; decrease  HI every 10 refresh
0012AF  2  D0 0A        	bne @drive_jump
0012B1  2  CE 52 1B     	dec player0 + PLAYER::falling_ticks	+ 1
0012B4  2  F0 4B        	beq @apex							; reached the apex of the jump
0012B6  2               
0012B6  2  A9 0A        	lda #JUMP_LO_TICKS
0012B8  2  8D 51 1B     	sta player0 + PLAYER::falling_ticks	; reset t
0012BB  2               
0012BB  2               @drive_jump:
0012BB  2  AD 52 1B     	lda player0 + PLAYER::falling_ticks + 1
0012BE  2  85 14        	sta r9L
0012C0  2               @loop_jump:
0012C0  2  20 E1 10     	jsr position_y_dec
0012C3  2  20 86 11     	jsr get_tilemap_position
0012C6  2  A5 02 8D 61  	SAVE_r0 player0 + PLAYER::tilemap
0012CA  2  1B A5 03 8D  
0012CE  2  62 1B        
0012D0  2               
0012D0  2  AD 5E 1B     	lda player0 + PLAYER::levely
0012D3  2  29 0F        	and #%00001111
0012D5  2  D0 05        	bne @no_collision_up				; if player is not on a multiple of 16 (tile size)
0012D7  2               
0012D7  2               	; test hit a ceiling
0012D7  2  20 C2 13     	jsr check_collision_up
0012DA  2  D0 04        	bne @collision_up
0012DC  2               @no_collision_up:
0012DC  2  C6 14        	dec r9L
0012DE  2  D0 E0        	bne @loop_jump						; loop to take t in count for gravity
0012E0  2               
0012E0  2               @collision_up:
0012E0  2  AD 53 1B     	lda player0 + PLAYER::delta_x		; deal with deltax
0012E3  2  F0 C6        	beq @return
0012E5  2  30 0D        	bmi @jump_left
0012E7  2               @jump_right:
0012E7  2  20 7B 13     	jsr check_collision_right
0012EA  2  F0 04        	beq @no_collision_right
0012EC  2               @collision_right:
0012EC  2  9C 53 1B     	stz player0 + PLAYER::delta_x		; cancel deltaX to transform to vertical movement
0012EF  2  60           	rts
0012F0  2               @no_collision_right:
0012F0  2  20 C5 0F     	jsr position_x_inc
0012F3  2  60           	rts
0012F4  2               @jump_left:
0012F4  2  20 84 13     	jsr check_collision_left
0012F7  2  F0 04        	beq @no_collision_left
0012F9  2               @collision_left:
0012F9  2  9C 53 1B     	stz player0 + PLAYER::delta_x		; cancel deltaX to transform to vertical movement
0012FC  2  60           	rts
0012FD  2               @no_collision_left:
0012FD  2  20 1C 10     	jsr position_x_dec
001300  2  60           	rts
001301  2               
001301  2               @apex:
001301  2  A9 06 8D 50  	m_status STATUS_JUMPING_IDLE
001305  2  1B           
001306  2  60           	rts
001307  2               
001307  2               ;************************************************
001307  2               ;	compute the number of tiles covered by the boundingbox
001307  2               ;	return: r1L : number of tiles height
001307  2               ;			X = r1H : number of tiles width
001307  2               ;			Y = r2L : index of the first tile to test
001307  2               ;
001307  2               bbox_coverage:
001307  2               	; X = how many column of tiles to test
001307  2  AD 5C 1B     	lda player0 + PLAYER::levelx
00130A  2  29 0F        	and #%00001111
00130C  2  C9 08        	cmp #8
00130E  2  F0 08        	beq @one_tile
001310  2  30 0C        	bmi @two_tiles_straight				; if X < 8, test as if int
001312  2               @two_tiles_right:
001312  2  A2 02        	ldx #02								; test 2 column ( y % 16 <> 0)
001314  2  A0 01        	ldy #01								; starting on row +1
001316  2  80 0A        	bra @test_lines
001318  2               @one_tile:
001318  2  A2 01        	ldx #01								; test 1 column ( y % 16  == 8)
00131A  2  A0 01        	ldy #01								; starting on row +1
00131C  2  80 04        	bra @test_lines
00131E  2               @two_tiles_straight:
00131E  2  A2 02        	ldx #02								; test 2 columns ( y % 16 == 0)
001320  2  A0 00        	ldy #00								; test on row  0 ( x % 16 != 0)
001322  2               
001322  2               @test_lines:
001322  2               	; X = how many lines of tiles to test
001322  2  AD 5E 1B     	lda player0 + PLAYER::levely
001325  2  29 0F        	and #%00001111
001327  2  D0 09        	bne @yfloat				; if player is not on a multiple of 16 (tile size)
001329  2               @yint:
001329  2  A9 02        	lda #02					; test 2 lines ( y % 16 == 0)
00132B  2  85 04        	sta r1L
00132D  2  86 05        	stx r1H
00132F  2  84 06        	sty r2L
001331  2  60           	rts
001332  2               @yfloat:
001332  2  A9 03        	lda #03					; test 3 rows ( y % 16 <> 0)
001334  2  85 04        	sta r1L
001336  2  86 05        	stx r1H
001338  2  84 06        	sty r2L
00133A  2  60           	rts
00133B  2               
00133B  2               ;************************************************
00133B  2               ; check collision on the height
00133B  2               ;	A = vaule of the collision
00133B  2               ;	ZERO = no collision
00133B  2               ;
00133B  2               check_collision_height:
00133B  2               	; only test if we are 'centered'
00133B  2  AD 5C 1B     	lda player0 + PLAYER::levelx
00133E  2  29 0F        	and #%00001111
001340  2  C9 08        	cmp #08
001342  2  D0 34        	bne @no_collision
001344  2               
001344  2  AD 61 1B     	lda player0 + PLAYER::tilemap
001347  2  85 02        	sta r0L
001349  2  AD 62 1B     	lda player0 + PLAYER::tilemap + 1
00134C  2  85 03        	sta r0H
00134E  2               
00134E  2  20 07 13     	jsr bbox_coverage
001351  2  A6 04        	ldx r1L				; tiles height
001353  2  98           	tya
001354  2  18           	clc
001355  2  6D D0 0E     	adc test_right_left
001358  2  A8           	tay
001359  2               
001359  2               @test_line:
001359  2  B1 02        	lda (r0L),y
00135B  2  F0 11        	beq @test_next_line
00135D  2               
00135D  2               	; some tiles are not real collision
00135D  2  84 30        	sty $30
00135F  2  A8           	tay
001360  2  B9 48 1A     	lda tiles_attributes,y
001363  2  89 02        	bit #TILE_ATTR::SOLID_WALL
001365  2  F0 05        	beq @test_next_line1
001367  2  A4 30        	ldy $30
001369  2  B1 02        	lda (r0L),y
00136B  2  60           	rts
00136C  2               
00136C  2               @test_next_line1:
00136C  2  A4 30        	ldy $30
00136E  2               
00136E  2               @test_next_line:
00136E  2  CA           	dex
00136F  2  F0 07        	beq @no_collision
001371  2  98           	tya
001372  2  18           	clc
001373  2  69 20        	adc #LEVEL_TILES_WIDTH			; test the tile on the right of the player (hip position)
001375  2  A8           	tay
001376  2  80 E1        	bra @test_line					; LADDERS can be traversed
001378  2               
001378  2               @no_collision:						; force a no collision
001378  2  A9 00        	lda #00
00137A  2               @return:
00137A  2  60           	rts
00137B  2               
00137B  2               ;************************************************
00137B  2               ; check collision on the right
00137B  2               ;	return: A = value of the collision
00137B  2               ;			ZERO = no collision
00137B  2               ;
00137B  2               check_collision_right:
00137B  2  A9 01        	lda #$01
00137D  2  8D D0 0E     	sta test_right_left
001380  2  20 3B 13     	jsr check_collision_height
001383  2  60           	rts
001384  2               
001384  2               ;************************************************
001384  2               ; check collision on the left
001384  2               ;
001384  2               check_collision_left:
001384  2  A9 FF        	lda #$ff
001386  2  8D D0 0E     	sta test_right_left
001389  2  20 3B 13     	jsr check_collision_height
00138C  2  60           	rts
00138D  2               
00138D  2               ;************************************************
00138D  2               ; check collision down
00138D  2               ;	collision surface to test is 16 pixels around the mid X
00138D  2               ; 	output : Z = no collision
00138D  2               ;
00138D  2               check_collision_down:
00138D  2  AD 5E 1B     	lda player0 + PLAYER::levely	; if the player is inbetween 2 tiles there can be no collision
001390  2  29 0F        	and #%00001111
001392  2  F0 03        	beq @real_test
001394  2  A9 00        	lda #00
001396  2  60           	rts
001397  2               @real_test:
001397  2  AD 61 1B     	lda player0 + PLAYER::tilemap
00139A  2  85 02        	sta r0L
00139C  2  AD 62 1B     	lda player0 + PLAYER::tilemap + 1
00139F  2  85 03        	sta r0H
0013A1  2               
0013A1  2  20 07 13     	jsr bbox_coverage
0013A4  2  98           	tya
0013A5  2  18           	clc
0013A6  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)	; check below the player
0013A8  2  A8           	tay
0013A9  2               
0013A9  2               @test_colum:
0013A9  2  B1 02        	lda (r0L),y
0013AB  2  F0 0C        	beq @next_colum							; empty tile, test the next one
0013AD  2               
0013AD  2  84 30        	sty $30
0013AF  2  A8           	tay
0013B0  2  B9 48 1A     	lda tiles_attributes,y
0013B3  2  89 01        	bit #TILE_ATTR::SOLID_GROUND
0013B5  2  D0 08        	bne @return1							; considere slopes as empty
0013B7  2  A4 30        	ldy $30
0013B9  2               
0013B9  2               @next_colum:
0013B9  2  CA           	dex
0013BA  2  F0 05        	beq @return
0013BC  2  C8           	iny
0013BD  2  80 EA        	bra @test_colum
0013BF  2               @return1:
0013BF  2  A9 01        	lda #01
0013C1  2               @return:
0013C1  2  60           	rts
0013C2  2               
0013C2  2               ;************************************************
0013C2  2               ; check collision up
0013C2  2               ;	collision surface to test is 16 pixels around the mid X
0013C2  2               ;	input :
0013C2  2               ;		r0 : @ of current tile the top-left corner of the player sprite
0013C2  2               ; 	output : Z = no collision
0013C2  2               ;
0013C2  2               check_collision_up:
0013C2  2  38           	sec
0013C3  2  AD 61 1B     	lda player0 + PLAYER::tilemap
0013C6  2  E9 20        	sbc #LEVEL_TILES_WIDTH
0013C8  2  85 02        	sta r0L
0013CA  2  AD 62 1B     	lda player0 + PLAYER::tilemap + 1
0013CD  2  E9 00        	sbc #0
0013CF  2  85 03        	sta r0H
0013D1  2               
0013D1  2               	; X = how many column of tiles to test
0013D1  2  AD 5C 1B     	lda player0 + PLAYER::levelx
0013D4  2  29 0F        	and #%00001111
0013D6  2  F0 0A        	beq @xint				; if player is not on a multiple of 16 (tile size)
0013D8  2               @xfloat:
0013D8  2  C9 08        	cmp #8
0013DA  2  30 06        	bmi @xint
0013DC  2  A2 01        	ldx #1					; test 1 column ( y % 16 <> 0)
0013DE  2  A0 01        	ldy #1					; starting at colum + 1
0013E0  2  80 13        	bra @test_colum
0013E2  2               @xint:
0013E2  2  A2 02        	ldx #2					; test 2 columns ( y % 16 == 0)
0013E4  2  A0 00        	ldy #0					; starting at colum
0013E6  2  80 00        	bra @test_y
0013E8  2               
0013E8  2               @test_y:
0013E8  2               	; Y = how tile rows to test
0013E8  2  AD 5E 1B     	lda player0 + PLAYER::levely
0013EB  2  29 0F        	and #%00001111
0013ED  2  F0 06        	beq @yint				; if player is not on a multiple of 16 (tile size)
0013EF  2               @yfloat:
0013EF  2  98           	tya
0013F0  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)	; test on (row -1) +1 ( x % 16 != 0) + column
0013F2  2  A8           	tay
0013F3  2  80 00        	bra @test_colum
0013F5  2               @yint:
0013F5  2               
0013F5  2               @test_colum:
0013F5  2  B1 02        	lda (r0L),y							; left side
0013F7  2  F0 0C        	beq @next_column
0013F9  2               
0013F9  2  84 30        	sty $30
0013FB  2  A8           	tay
0013FC  2  B9 48 1A     	lda tiles_attributes,y
0013FF  2  89 04        	bit #TILE_ATTR::SOLID_CEILING
001401  2  D0 08        	bne @return1
001403  2  A4 30        	ldy $30
001405  2               
001405  2               @next_column:
001405  2  CA           	dex
001406  2  F0 05        	beq @return
001408  2  C8           	iny
001409  2  80 EA        	bra @test_colum
00140B  2               @return1:
00140B  2  A9 01        	lda #01
00140D  2               @return:
00140D  2  60           	rts
00140E  2               
00140E  2               ;************************************************
00140E  2               ; check if the player feet is exactly on a slope tile
00140E  2               ;	modify: player_on_slop
00140E  2               ;	return: Z = slop
00140E  2               ;			Y = feet position tested (vs r0)
00140E  2               ;
00140E  2               check_player_on_slop:
00140E  2  9C CE 0E     	stz player_on_slop				; no slope
001411  2               
001411  2  20 07 13     	jsr bbox_coverage
001414  2               
001414  2  18           	clc
001415  2  98           	tya
001416  2  A6 04        	ldx r1L
001418  2  CA           	dex
001419  2               :
001419  2  69 20        	adc #LEVEL_TILES_WIDTH
00141B  2  CA           	dex
00141C  2  D0 FB        	bne :-
00141E  2  A8           	tay								; position of the feet tiles
00141F  2               
00141F  2  AD 5C 1B     	lda player0 + PLAYER::levelx
001422  2  29 0F        	and #%00001111
001424  2  C9 08        	cmp #08
001426  2  10 01        	bpl :+
001428  2  C8           	iny
001429  2               :
001429  2               
001429  2               	; check if player feet is ON a slop
001429  2  B1 02        	lda (r0),y						; test ON feet level
00142B  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
00142D  2  F0 04        	beq @on_slope
00142F  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
001431  2  D0 06        	bne @no_slope
001433  2               @on_slope:
001433  2  B1 02        	lda (r0),y						; test ON feet level
001435  2  8D CE 0E     	sta player_on_slop
001438  2  60           	rts
001439  2               
001439  2               @no_slope:
001439  2  A9 00        	lda #0
00143B  2  8D CE 0E     	sta player_on_slop
00143E  2  60           	rts
00143F  2               
00143F  2               ;************************************************
00143F  2               ; check if the player feet is ABOVE a slope tile
00143F  2               ;	input: 	Y = feet position tested (vs r0)
00143F  2               ;	modify: player_on_slop
00143F  2               ;	return: Z = slop
00143F  2               ;
00143F  2               is_player_above_slop:
00143F  2  9C CE 0E     	stz player_on_slop				; no slope
001442  2               
001442  2  98           	tya
001443  2  18           	clc
001444  2  69 20        	adc #LEVEL_TILES_WIDTH
001446  2  A8           	tay								; test BELOW feet level
001447  2  B1 02        	lda (r0),y
001449  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
00144B  2  F0 0A        	beq @above_slope
00144D  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
00144F  2  F0 06        	beq @above_slope
001451  2               @no_slope:
001451  2  A9 00        	lda #0
001453  2  8D CE 0E     	sta player_on_slop
001456  2  60           	rts
001457  2               @above_slope:
001457  2  8D CE 0E     	sta player_on_slop
00145A  2  60           	rts
00145B  2               
00145B  2               ;************************************************
00145B  2               ; status to ignore while moving
00145B  2               ;
00145B  2               ignore_move_request:
00145B  2  00           	.byte	00	;	STATUS_WALKING_IDLE
00145C  2  00           	.byte	00	;	STATUS_WALKING
00145D  2  02           	.byte	02	;	STATUS_CLIMBING
00145E  2  02           	.byte	02	;	STATUS_CLIMBING_IDLE
00145F  2  01           	.byte	01	;	STATUS_FALLING
001460  2  01           	.byte	01	;	STATUS_JUMPING
001461  2  01           	.byte	01	;	STATUS_JUMPING_IDLE
001462  2               
001462  2               ;************************************************
001462  2               ; Try to move player to the right, walk up if facing a slope
001462  2               ;
001462  2               move_right:
001462  2  AC 50 1B     	ldy player0 + PLAYER::status
001465  2  B9 5B 14     	lda ignore_move_request, y
001468  2  F0 06        	beq @walk_right					; if 0 => can move
00146A  2  C9 02        	cmp #02
00146C  2  F0 6E        	beq @climb_right				; if 2 => has to climb
00146E  2  80 6B        	bra @return1					; else block the move
001470  2               
001470  2               @walk_right:
001470  2  20 0E 14     	jsr check_player_on_slop
001473  2  D0 0A        	bne @no_collision
001475  2               
001475  2  20 3F 14     	jsr is_player_above_slop
001478  2  D0 05        	bne @no_collision
00147A  2               
00147A  2  20 7B 13     	jsr Player::check_collision_right
00147D  2  D0 5C        	bne @return1					; block is collision on the right  and there is no slope on the right
00147F  2               
00147F  2               @no_collision:
00147F  2  A9 01        	lda #01
001481  2  8D 53 1B     	sta player0 + PLAYER::delta_x
001484  2               
001484  2               @set_walking_sprite:
001484  2  A9 01        	lda #SPRITE_FLIP_H
001486  2  8D 60 1B     	sta player0 + PLAYER::flip
001489  2  AC 4F 1B     	ldy player0 + PLAYER::sprite
00148C  2  20 5B 0C     	jsr Sprite::set_flip				; force sprite to look right
00148F  2               
00148F  2  A9 01 8D 50  	m_status STATUS_WALKING
001493  2  1B           
001494  2               
001494  2               	;change player sprite
001494  2  A9 03        	lda #Player::Sprites::LEFT
001496  2  CD 55 1B     	cmp player0 + PLAYER::spriteID
001499  2  F0 08        	beq @move_x
00149B  2               
00149B  2  A9 03        	lda #Player::Sprites::LEFT
00149D  2  8D 55 1B     	sta player0 + PLAYER::spriteID
0014A0  2  20 AB 0F     	jsr set_bitmap
0014A3  2               
0014A3  2               @move_x:
0014A3  2  20 C5 0F     	jsr Player::position_x_inc		; move the player in the level, and the screen layers and sprite
0014A6  2               
0014A6  2               	; if sitting on a slop
0014A6  2  AD CE 0E     	lda player_on_slop
0014A9  2  F0 2D        	beq @set_position
0014AB  2  C9 03        	cmp #TILE_SOLD_SLOP_RIGHT
0014AD  2  F0 26        	beq @move_y_up
0014AF  2               @try_move_y_dow:
0014AF  2  AD 5E 1B     	lda player0 + PLAYER::levely
0014B2  2  29 0F        	and #%00001111
0014B4  2  D0 1A        	bne @move_y_down
0014B6  2  AD 61 1B     	lda player0 + PLAYER::tilemap
0014B9  2  85 02        	sta r0L
0014BB  2  AD 62 1B     	lda player0 + PLAYER::tilemap+1
0014BE  2  85 03        	sta r0H
0014C0  2  A5 06        	lda r2L
0014C2  2  18           	clc
0014C3  2  69 41        	adc #(LEVEL_TILES_WIDTH * 2 + 1)	; check on the 2nd block
0014C5  2  A8           	tay
0014C6  2  B1 02        	lda (r0), y							; check if the tile below as an attribute SOLID_GROUND
0014C8  2  A8           	tay
0014C9  2  B9 48 1A     	lda tiles_attributes,y
0014CC  2  89 01        	bit #TILE_ATTR::SOLID_GROUND
0014CE  2  D0 61        	bne @return							; do not change Y if the tile below the player is a solid one
0014D0  2               @move_y_down:
0014D0  2  20 70 10     	jsr position_y_inc
0014D3  2  80 03        	bra @set_position
0014D5  2               @move_y_up:
0014D5  2  20 E1 10     	jsr position_y_dec
0014D8  2               
0014D8  2               @set_position:
0014D8  2  20 9C 0F     	jsr position_set
0014DB  2               @return1:
0014DB  2  60           	rts
0014DC  2               
0014DC  2               @climb_right:
0014DC  2  20 7B 13     	jsr Player::check_collision_right
0014DF  2  F0 05        	beq @climb_right_1
0014E1  2  C9 04        	cmp #TILE_SOLID_LADER
0014E3  2  F0 01        	beq @climb_right_1
0014E5  2  60           	rts
0014E6  2               @climb_right_1:
0014E6  2  20 07 13     	jsr bbox_coverage
0014E9  2               @get_tile:
0014E9  2  B1 02        	lda (r0),y
0014EB  2  F0 0E        	beq @no_grab					; no tile on right
0014ED  2  85 31        	sta $31
0014EF  2  84 30        	sty $30
0014F1  2  A8           	tay
0014F2  2  B9 48 1A     	lda tiles_attributes,y
0014F5  2  89 08        	bit #TILE_ATTR::GRABBING
0014F7  2  D0 08        	bne @climb_right_2				; tile on right with a GRAB attribute
0014F9  2  A4 30        	ldy $30
0014FB  2               @no_grab:							; test the tile on the right on next line
0014FB  2  C8           	iny
0014FC  2  CA           	dex
0014FD  2  D0 EA        	bne @get_tile
0014FF  2  80 1E        	bra @climb_right_drop			; no grab tile on the right of the player
001501  2               @climb_right_2:
001501  2  A5 31        	lda $31							; tile index with grab attribute
001503  2  C9 05        	cmp #TILE_LEDGE
001505  2  D0 04        	bne @set_climb_sprite
001507  2               @set_hang_sprite:
001507  2  A9 09        	lda #Player::Sprites::HANG
001509  2  80 02        	bra @next
00150B  2               @set_climb_sprite:
00150B  2  A9 06        	lda #Player::Sprites::CLIMB
00150D  2               @next:
00150D  2  8D 55 1B     	sta player0 + PLAYER::spriteID
001510  2  20 AB 0F     	jsr set_bitmap
001513  2  A9 02 8D 50  	m_status STATUS_CLIMBING
001517  2  1B           
001518  2  20 C5 0F     	jsr Player::position_x_inc		; move the player sprite, if the
00151B  2  20 9C 0F     	jsr position_set
00151E  2  60           	rts
00151F  2               @climb_right_drop:
00151F  2  A9 01 8D 50  	m_status STATUS_WALKING
001523  2  1B           
001524  2  A9 03 8D 55  	SET_SPRITE Player::Sprites::LEFT, 1
001528  2  1B A9 01 8D  
00152C  2  56 1B 20 AB  
001531  2               
001531  2               @return:
001531  2  60           	rts
001532  2               
001532  2               ;************************************************
001532  2               ; try to move the player to the left
001532  2               ;
001532  2               move_left:
001532  2  AC 50 1B     	ldy player0 + PLAYER::status
001535  2  B9 5B 14     	lda ignore_move_request, y
001538  2  F0 06        	beq @walk_left					; if 0 => can move
00153A  2  C9 02        	cmp #02
00153C  2  F0 6E        	beq @climb_left				; if 2 => has to climb
00153E  2  80 6B        	bra @return					; else block the move
001540  2               
001540  2               @walk_left:
001540  2  20 0E 14     	jsr check_player_on_slop
001543  2  D0 0A        	bne @no_collision				; ignore right collision left if on a slope
001545  2               
001545  2  20 3F 14     	jsr is_player_above_slop
001548  2  D0 05        	bne @no_collision
00154A  2               
00154A  2  20 84 13     	jsr Player::check_collision_left
00154D  2  D0 5C        	bne @return						; block is collision on the right  and there is no slope on the right
00154F  2               
00154F  2               @no_collision:
00154F  2  A9 FF        	lda #$ff
001551  2  8D 53 1B     	sta player0 + PLAYER::delta_x
001554  2               
001554  2               @set_walking_sprite:
001554  2  A9 00        	lda #SPRITE_FLIP_NONE
001556  2  8D 60 1B     	sta player0 + PLAYER::flip
001559  2  AC 4F 1B     	ldy player0 + PLAYER::sprite
00155C  2  20 5B 0C     	jsr Sprite::set_flip				; force sprite to loop right
00155F  2               
00155F  2  A9 01 8D 50  	m_status STATUS_WALKING
001563  2  1B           
001564  2               
001564  2  A9 03        	lda #Player::Sprites::LEFT
001566  2  CD 55 1B     	cmp player0 + PLAYER::spriteID
001569  2  F0 08        	beq @move_x
00156B  2               
00156B  2               	;change player sprite
00156B  2  A9 03        	lda #Player::Sprites::LEFT
00156D  2  8D 55 1B     	sta player0 + PLAYER::spriteID
001570  2  20 AB 0F     	jsr set_bitmap
001573  2               
001573  2               @move_x:
001573  2  20 1C 10     	jsr Player::position_x_dec
001576  2               
001576  2  AD CE 0E     	lda player_on_slop				; if walking a slop also increase Y
001579  2  F0 2D        	beq @set_position
00157B  2  C9 02        	cmp #TILE_SOLD_SLOP_LEFT
00157D  2  F0 26        	beq @move_y_up
00157F  2               @try_move_y_dow:
00157F  2  AD 5E 1B     	lda player0 + PLAYER::levely
001582  2  29 0F        	and #%00001111
001584  2  D0 1A        	bne @move_y_down
001586  2  AD 61 1B     	lda player0 + PLAYER::tilemap
001589  2  85 02        	sta r0L
00158B  2  AD 62 1B     	lda player0 + PLAYER::tilemap+1
00158E  2  85 03        	sta r0H
001590  2  A5 06        	lda r2L
001592  2  18           	clc
001593  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)
001595  2  A8           	tay
001596  2  B1 02        	lda (r0), y							; check if the tile below as an attribute TILE_SOLID_GROUND
001598  2  A8           	tay
001599  2  B9 48 1A     	lda tiles_attributes,y
00159C  2  89 01        	bit #TILE_ATTR::SOLID_GROUND
00159E  2  D0 0B        	bne @return							; do not change Y if the tile below the player is a solid one
0015A0  2               @move_y_down:
0015A0  2  20 70 10     	jsr position_y_inc
0015A3  2  80 03        	bra @set_position
0015A5  2               @move_y_up:
0015A5  2  20 E1 10     	jsr position_y_dec
0015A8  2               
0015A8  2               @set_position:
0015A8  2  20 9C 0F     	jsr position_set
0015AB  2               
0015AB  2               @return:
0015AB  2  60           	rts
0015AC  2               
0015AC  2               @climb_left:
0015AC  2  20 84 13     	jsr Player::check_collision_left
0015AF  2  F0 01        	beq @climb_left_1
0015B1  2  60           	rts								; collision on left, block the move
0015B2  2               @climb_left_1:
0015B2  2  20 07 13     	jsr bbox_coverage				; what tiles is the player covering
0015B5  2               @get_tile:
0015B5  2  B1 02        	lda (r0),y
0015B7  2  F0 0E        	beq @no_grab					; no tile on right
0015B9  2  85 31        	sta $31
0015BB  2  84 30        	sty $30
0015BD  2  A8           	tay
0015BE  2  B9 48 1A     	lda tiles_attributes,y
0015C1  2  89 08        	bit #TILE_ATTR::GRABBING
0015C3  2  D0 08        	bne @climb_left_2				; tile on left with a GRAB attribute
0015C5  2  A4 30        	ldy $30
0015C7  2               @no_grab:							; test the tile on the left on next line
0015C7  2  C8           	iny
0015C8  2  CA           	dex
0015C9  2  D0 EA        	bne @get_tile
0015CB  2  80 1E        	bra @climb_left_drop			; no grab tile on the right of the player
0015CD  2               @climb_left_2:
0015CD  2  A5 31        	lda $31							; tile index with grab attribute
0015CF  2  C9 05        	cmp #TILE_LEDGE
0015D1  2  D0 04        	bne @set_climb_sprite
0015D3  2               @set_hang_sprite:
0015D3  2  A9 09        	lda #Player::Sprites::HANG
0015D5  2  80 02        	bra @next
0015D7  2               @set_climb_sprite:
0015D7  2  A9 06        	lda #Player::Sprites::CLIMB
0015D9  2               @next:
0015D9  2  8D 55 1B     	sta player0 + PLAYER::spriteID
0015DC  2  20 AB 0F     	jsr set_bitmap
0015DF  2  A9 02 8D 50  	m_status STATUS_CLIMBING
0015E3  2  1B           
0015E4  2  20 1C 10     	jsr Player::position_x_dec		; move the player sprite, if the
0015E7  2  20 9C 0F     	jsr position_set
0015EA  2  60           	rts
0015EB  2               @climb_left_drop:					; no ladder to stick to
0015EB  2  A9 01 8D 50  	m_status STATUS_WALKING
0015EF  2  1B           
0015F0  2  A9 03 8D 55  	SET_SPRITE Player::Sprites::LEFT, 1
0015F4  2  1B A9 01 8D  
0015F8  2  56 1B 20 AB  
0015FD  2  60           	rts
0015FE  2               
0015FE  2               ;************************************************
0015FE  2               ; try to move the player down (crouch, hide, move down a ladder)
0015FE  2               ;
0015FE  2               move_down:
0015FE  2  AD 50 1B     	lda player0 + PLAYER::status
001601  2  C9 04        	cmp #STATUS_FALLING
001603  2  D0 01        	bne @try_move_down						; cannot move when falling
001605  2  60           	rts
001606  2               
001606  2               @try_move_down:
001606  2               	; custom collision down
001606  2  AD 61 1B     	lda player0 + PLAYER::tilemap
001609  2  85 02        	sta r0L
00160B  2  AD 62 1B     	lda player0 + PLAYER::tilemap + 1
00160E  2  85 03        	sta r0H
001610  2               
001610  2  20 07 13     	jsr bbox_coverage
001613  2  8E CF 0E     	stx ladders						; width of the player in tiles = number of ladders to find below
001616  2  98           	tya
001617  2  18           	clc
001618  2  69 40        	adc #(LEVEL_TILES_WIDTH * 2)	; check below the player
00161A  2  A8           	tay
00161B  2               
00161B  2               @test_colum:
00161B  2  B1 02        	lda (r0L),y
00161D  2  C9 04        	cmp #TILE_SOLID_LADER
00161F  2  D0 05        	bne @check_solid_ground
001621  2               @ladder_down:
001621  2  CE CF 0E     	dec ladders
001624  2  80 0C        	bra @next_column
001626  2               @check_solid_ground:
001626  2  84 30        	sty $30
001628  2  A8           	tay
001629  2  B9 48 1A     	lda tiles_attributes,y
00162C  2  89 01        	bit #TILE_ATTR::SOLID_GROUND
00162E  2  D0 45        	bne @cannot_move_down
001630  2  A4 30        	ldy $30
001632  2               @next_column:
001632  2  CA           	dex
001633  2  F0 03        	beq @end
001635  2  C8           	iny
001636  2  80 E3        	bra @test_colum
001638  2               @end:
001638  2               
001638  2  AD CF 0E     	lda ladders
00163B  2  F0 1C        	beq @move_down						; correct number of ladder tiles below the player
00163D  2               
00163D  2               	; if there player is covering ANY ladders (accros the boundingbox)
00163D  2  A4 06        	ldy r2L
00163F  2               @check_line:							; already climbing down is player grabbing no ladder
00163F  2  A6 05        	ldx r1H
001641  2               @check_row:
001641  2  B1 02        	lda (r0L),y
001643  2  C9 04        	cmp #TILE_SOLID_LADER
001645  2  F0 12        	beq @move_down
001647  2  C8           	iny
001648  2  CA           	dex
001649  2  D0 F6        	bne @check_row
00164B  2  C6 04        	dec r1L
00164D  2  F0 26        	beq @cannot_move_down
00164F  2               
00164F  2  98           	tya
001650  2  18           	clc
001651  2  69 20        	adc #LEVEL_TILES_WIDTH
001653  2  38           	sec
001654  2  E5 05        	sbc r1H
001656  2  A8           	tay
001657  2  80 E6        	bra @check_line
001659  2               
001659  2               @move_down:
001659  2  20 70 10     	jsr Player::position_y_inc		; move down the ladder
00165C  2  20 9C 0F     	jsr position_set
00165F  2               
00165F  2  A9 02 8D 50  	m_status STATUS_CLIMBING
001663  2  1B           
001664  2               
001664  2  A9 06        	lda #Player::Sprites::CLIMB
001666  2  CD 55 1B     	cmp player0 + PLAYER::spriteID
001669  2  D0 01        	bne @change_sprite
00166B  2  60           	rts
00166C  2               
00166C  2               @change_sprite:
00166C  2               	;change player sprite
00166C  2  A9 06        	lda #Player::Sprites::CLIMB
00166E  2  8D 55 1B     	sta player0 + PLAYER::spriteID
001671  2  20 AB 0F     	jsr set_bitmap
001674  2  60           	rts
001675  2               
001675  2               @cannot_move_down:
001675  2  A9 00        	lda #STATUS_WALKING_IDLE
001677  2  8D 50 1B     	sta player0 + PLAYER::status
00167A  2  A9 01        	lda #01
00167C  2  8D 56 1B     	sta player0 + PLAYER::spriteAnim
00167F  2  20 AB 0F     	jsr set_bitmap
001682  2  9C 53 1B     	stz player0 + PLAYER::delta_x
001685  2  60           	rts
001686  2               
001686  2               ;************************************************
001686  2               ; try to move the player up (move up a ladder)
001686  2               ;	only climb a ladder if the 16 pixels mid-X are fully enclosed in the ladder
001686  2               ;	modify: r0, r1, r2
001686  2               ;
001686  2               move_up:
001686  2  AD 50 1B     	lda player0 + PLAYER::status
001689  2  C9 04        	cmp #STATUS_FALLING
00168B  2  D0 01        	bne @try_move_up				; cannot move when falling
00168D  2  60           	rts
00168E  2               @try_move_up:
00168E  2               	; custom collision up
00168E  2  20 07 13     	jsr bbox_coverage
001691  2  8E CF 0E     	stx ladders						; width of the player in tiles = number of ladders to find below
001694  2               
001694  2               	; check the situation ABOVE the player
001694  2  38           	sec
001695  2  AD 61 1B     	lda player0 + PLAYER::tilemap
001698  2  E9 20        	sbc #LEVEL_TILES_WIDTH
00169A  2  85 02        	sta r0L
00169C  2  AD 62 1B     	lda player0 + PLAYER::tilemap+1
00169F  2  E9 00        	sbc #0
0016A1  2  85 03        	sta r0H
0016A3  2               
0016A3  2               	; if there the right numbers of ladder tiles above the player
0016A3  2               @test_colum:
0016A3  2  B1 02        	lda (r0L),y
0016A5  2  C9 04        	cmp #TILE_SOLID_LADER
0016A7  2  D0 05        	bne @check_solid_ceiling
0016A9  2  CE CF 0E     	dec ladders
0016AC  2  80 0C        	bra @next_column
0016AE  2               @check_solid_ceiling:
0016AE  2  84 30        	sty $30
0016B0  2  A8           	tay
0016B1  2  B9 48 1A     	lda tiles_attributes,y
0016B4  2  89 04        	bit #TILE_ATTR::SOLID_CEILING
0016B6  2  D0 4F        	bne @cannot_move_up
0016B8  2  A4 30        	ldy $30
0016BA  2               @next_column:
0016BA  2  CA           	dex
0016BB  2  F0 03        	beq @end
0016BD  2  C8           	iny
0016BE  2  80 E3        	bra @test_colum
0016C0  2               @end:
0016C0  2               
0016C0  2  AD CF 0E     	lda ladders
0016C3  2  F0 26        	beq @climb_down						; correct number of ladder tiles above the player
0016C5  2               
0016C5  2               	; if there player is covering ANY LADER (accros the boundingbox)
0016C5  2  AD 61 1B     	lda player0 + PLAYER::tilemap
0016C8  2  85 02        	sta r0L
0016CA  2  AD 62 1B     	lda player0 + PLAYER::tilemap+1
0016CD  2  85 03        	sta r0H
0016CF  2               
0016CF  2  A4 06        	ldy r2L
0016D1  2               @check_line:							; already climbing up is player grabbing no ladder
0016D1  2  A6 05        	ldx r1H
0016D3  2               @check_row:
0016D3  2  B1 02        	lda (r0L),y
0016D5  2  C9 04        	cmp #TILE_SOLID_LADER
0016D7  2  F0 12        	beq @climb_down
0016D9  2  C8           	iny
0016DA  2  CA           	dex
0016DB  2  D0 F6        	bne @check_row
0016DD  2  C6 04        	dec r1L
0016DF  2  F0 26        	beq @cannot_move_up
0016E1  2               
0016E1  2  98           	tya
0016E2  2  18           	clc
0016E3  2  69 20        	adc #LEVEL_TILES_WIDTH
0016E5  2  38           	sec
0016E6  2  E5 05        	sbc r1H
0016E8  2  A8           	tay
0016E9  2  80 E6        	bra @check_line
0016EB  2               
0016EB  2               @climb_down:
0016EB  2  20 E1 10     	jsr Player::position_y_dec		; move up the ladder
0016EE  2  20 9C 0F     	jsr position_set
0016F1  2               
0016F1  2  A9 02 8D 50  	m_status STATUS_CLIMBING
0016F5  2  1B           
0016F6  2               
0016F6  2  A9 06        	lda #Player::Sprites::CLIMB
0016F8  2  CD 55 1B     	cmp player0 + PLAYER::spriteID
0016FB  2  D0 01        	bne @set_sprite
0016FD  2  60           	rts
0016FE  2               @set_sprite:						;change player sprite
0016FE  2  A9 06        	lda #Player::Sprites::CLIMB
001700  2  8D 55 1B     	sta player0 + PLAYER::spriteID
001703  2  20 AB 0F     	jsr set_bitmap
001706  2  60           	rts
001707  2               
001707  2               @cannot_move_up:
001707  2  A9 00        	lda #STATUS_WALKING_IDLE
001709  2  8D 50 1B     	sta player0 + PLAYER::status
00170C  2  60           	rts
00170D  2               
00170D  2               ;************************************************
00170D  2               ; jump
00170D  2               ;	A = delta X value
00170D  2               ;
00170D  2               jump:
00170D  2  AA           	tax
00170E  2  AC 50 1B         ldy player0 + PLAYER::status
001711  2  B9 5B 14     	lda ignore_move_request,y
001714  2  D0 17        	bne @return
001716  2  8E 53 1B     	stx player0 + PLAYER::delta_x
001719  2               
001719  2               	; ensure there is no ceiling over the player
001719  2  20 C2 13     	jsr check_collision_up
00171C  2  D0 0F        	bne @return
00171E  2               
00171E  2  A9 0A        	lda #JUMP_LO_TICKS
001720  2  8D 51 1B     	sta player0 + PLAYER::falling_ticks	; decrease  HI every 10 refresh
001723  2  A9 02        	lda #JUMP_HI_TICKS
001725  2  8D 52 1B     	sta player0 + PLAYER::falling_ticks	+ 1
001728  2               
001728  2  A9 05 8D 50  	m_status STATUS_JUMPING
00172C  2  1B           
00172D  2               @return:
00172D  2  60           	rts
00172E  2               
00172E  2               .endscope
00172E  2               
00172E  1               .include "tiles.asm"
00172E  2               ;-----------------------------------------------------------------------------
00172E  2               ;/////////////////////////////////////////////////////////////////////////////
00172E  2               ; START Tiles code
00172E  2               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
00172E  2               ;-----------------------------------------------------------------------------
00172E  2               
00172E  2               .scope Tiles
00172E  2               
00172E  2               ;animated_tiles_map
00172E  2               ;   nb_animated_tiles
00172E  2               ;   tile[0]
00172E  2               ;        tick,
00172E  2               ;        nb_frames
00172E  2               ;        current_frame
00172E  2               ;        @frame[0][0]
00172E  2               ;        nb_tiles
00172E  2               ;        @addr_tiles_list[0]
00172E  2               ;   tile[1]
00172E  2               ;   ....
00172E  2               ;   tile[nb_animated_tiles-1]
00172E  2               ;   frame[t0][0]: duration, tile_index
00172E  2               ;   frame[t0][1]
00172E  2               ;   .....
00172E  2               ;   frame[t0][ tile[0].nb_frames - 1 ]
00172E  2               ;   frame[t1][0]: duration, tile_index
00172E  2               ;   frame[t1][1]
00172E  2               ;   .....
00172E  2               ;   frame[t1][ tile[1].nb_frames - 1 ]
00172E  2               ;   .....
00172E  2               ;   frame[tnb_animated_tiles-1][0]
00172E  2               ;   .....
00172E  2               ;   frame[tnb_animated_tiles-1][ tile[nb_animated_tiles-1].nb_frames - 1 ]
00172E  2               ;   addr_tiles_list[0] : tile[0].nb_tiles word
00172E  2               ;   addr_tiles_list[1] : tile[1].nb_tiles word
00172E  2               ;   addr_tiles_list[nb_animated_times -1] : tile[1].nb_tiles word
00172E  2               
00172E  2               .struct ANIMATED_TILES
00172E  2                   nb_animated_tiles   .byte
00172E  2               
00172E  2                   .struct ANIMATED_TILE
00172E  2                       tick            .byte   ; number of 18ms frames until next animation
00172E  2                       nb_frames       .byte
00172E  2                       current_frame   .byte
00172E  2                       addr_frames  .addr   ; offset of the list of animation
00172E  2                       nb_tiles        .byte   ; numner of tiles on the tilemap
00172E  2                       addr_tiles_list      .addr   ; offset of the list of tiles on the tilemap
00172E  2                   .endstruct
00172E  2               .endstruct
00172E  2               
00172E  2               .struct FRAME
00172E  2                   duration    .byte
00172E  2                   tile_index  .byte
00172E  2               .endstruct
00172E  2               
00172E  2               animated_tiles_map = HIMEM + $400
00172E  2               animated_tiles = HIMEM + $400 + 1
00172E  2               
00172E  2  74 69 6C 65  fsanimated_tiles: .literal "tilesani.bin"
001732  2  73 61 6E 69  
001736  2  2E 62 69 6E  
00173A  2               fsanimated_tiles_end:
00173A  2               
00173A  2               ;-----------------------------------------
00173A  2               ; load and fix the animated tiles data
00173A  2               ;
00173A  2               load:
00173A  2  A9 00        	lda #0
00173C  2  85 00        	sta $00
00173E  2  A9 01 A2 08  	LOAD_FILE fsanimated_tiles, (fsanimated_tiles_end-fsanimated_tiles), animated_tiles_map
001742  2  A0 00 20 BA  
001746  2  FF A9 0C A2  
00175F  2               
00175F  2                   ; convert offsets in the data structure to memory addr
00175F  2  AC 00 A4         ldy animated_tiles_map + ANIMATED_TILES::nb_animated_tiles
001762  2  A2 00            ldx #0
001764  2               
001764  2               @next_tile:
001764  2  18               clc
001765  2  BD 04 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames, x
001768  2  69 00            adc #<animated_tiles_map
00176A  2  9D 04 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames, x
00176D  2  BD 05 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames + 1, x
001770  2  69 A4            adc #>animated_tiles_map
001772  2  9D 05 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames + 1, x
001775  2               
001775  2  18               clc
001776  2  BD 07 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list, x
001779  2  69 00            adc #<animated_tiles_map
00177B  2  9D 07 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list, x
00177E  2  BD 08 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list + 1, x
001781  2  69 A4            adc #>animated_tiles_map
001783  2  9D 08 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list + 1, x
001786  2               
001786  2  88               dey
001787  2  F0 07            beq @convert_tileslist_addr
001789  2               
001789  2  8A               txa
00178A  2  18               clc
00178B  2  69 08            adc #.sizeof(ANIMATED_TILES::ANIMATED_TILE)
00178D  2  AA               tax
00178E  2  80 D4            bra @next_tile
001790  2               
001790  2               @convert_tileslist_addr:
001790  2                   ; convert tilemap offset into vera offset
001790  2                   ; convert offsets in the data structure to memory addr
001790  2  AC 00 A4         ldy animated_tiles_map + ANIMATED_TILES::nb_animated_tiles
001793  2  A2 00            ldx #0
001795  2               @next_tile1:
001795  2                   ; setup the listf of memory offset in vera memory
001795  2  BD 07 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list, x
001798  2  85 02            sta r0L
00179A  2  BD 08 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list + 1, x
00179D  2  85 03            sta r0H
00179F  2               
00179F  2  5A               phy
0017A0  2  DA               phx
0017A1  2  BD 06 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::nb_tiles, x
0017A4  2  AA               tax
0017A5  2  A0 00            ldy #00
0017A7  2               
0017A7  2               @loop_tiles:
0017A7  2  18               clc
0017A8  2  B1 02            lda (r0),y
0017AA  2  69 00            adc #<VRAM_layer1_map
0017AC  2  91 02            sta (r0),y
0017AE  2  C8               iny
0017AF  2               
0017AF  2  B1 02            lda (r0),y
0017B1  2  69 08            adc #>VRAM_layer1_map
0017B3  2  91 02            sta (r0),y
0017B5  2  C8               iny
0017B6  2               
0017B6  2  CA               dex
0017B7  2  D0 EE            bne @loop_tiles
0017B9  2  FA               plx
0017BA  2  7A               ply
0017BB  2               
0017BB  2  88               dey
0017BC  2  F0 07            beq @init
0017BE  2               
0017BE  2  8A               txa
0017BF  2  18               clc
0017C0  2  69 08            adc #.sizeof(ANIMATED_TILES::ANIMATED_TILE)
0017C2  2  AA               tax
0017C3  2  80 D0            bra @next_tile1
0017C5  2               
0017C5  2               @init:
0017C5  2                   ; init the timers
0017C5  2  AC 00 A4         ldy animated_tiles_map + ANIMATED_TILES::nb_animated_tiles
0017C8  2  A2 00            ldx #0
0017CA  2               
0017CA  2               @next_tile2:
0017CA  2                   ; setup the list of frames
0017CA  2  BD 04 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames, x
0017CD  2  85 02            sta r0L
0017CF  2  BD 05 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames + 1, x
0017D2  2  85 03            sta r0H
0017D4  2               
0017D4  2                   ; save new frame duration in the timer
0017D4  2  B2 02            lda (r0)
0017D6  2  9D 01 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::tick, x
0017D9  2               
0017D9  2  88               dey
0017DA  2  F0 07            beq @return
0017DC  2               
0017DC  2  8A               txa
0017DD  2  18               clc
0017DE  2  69 08            adc #.sizeof(ANIMATED_TILES::ANIMATED_TILE)
0017E0  2  AA               tax
0017E1  2  80 E7            bra @next_tile2
0017E3  2               
0017E3  2               @return:
0017E3  2  60               rts
0017E4  2               
0017E4  2               ;-----------------------------------------
0017E4  2               ; parse the animated tiles to update
0017E4  2               ;
0017E4  2               animate:
0017E4  2  AC 00 A4         ldy animated_tiles_map + ANIMATED_TILES::nb_animated_tiles
0017E7  2  A2 00            ldx #0
0017E9  2               
0017E9  2               @next_tile:
0017E9  2  DE 01 A4         dec animated_tiles + ANIMATED_TILES::ANIMATED_TILE::tick, x
0017EC  2  D0 03            bne :+
0017EE  2  20 FC 17         jsr next_frame
0017F1  2               :
0017F1  2  88               dey
0017F2  2  F0 07            beq @return
0017F4  2               
0017F4  2  8A               txa
0017F5  2  18               clc
0017F6  2  69 08            adc #.sizeof(ANIMATED_TILES::ANIMATED_TILE)
0017F8  2  AA               tax
0017F9  2  80 EE            bra @next_tile
0017FB  2               
0017FB  2               @return:
0017FB  2  60               rts
0017FC  2               
0017FC  2               ;-----------------------------------------
0017FC  2               ; move to the next frame of an animated tile
0017FC  2               ; update tiles on the tilemap
0017FC  2               ; input X : offset of the anim_tile structure
0017FC  2               ;
0017FC  2               next_frame:
0017FC  2  BD 03 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::current_frame, x
0017FF  2  1A               inc
001800  2  DD 02 A4         cmp animated_tiles + ANIMATED_TILES::ANIMATED_TILE::nb_frames, x
001803  2  D0 02            bne :+
001805  2  A9 00            lda #00         ; roll back to 0
001807  2               :
001807  2  9D 03 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::current_frame, x
00180A  2  DA               phx
00180B  2  5A               phy
00180C  2               
00180C  2  0A               asl         ; the are 2 bytes per frame, so multiply the index by 2
00180D  2  A8               tay         ; Y = current animation frame
00180E  2               
00180E  2                   ; setup the list of frames
00180E  2  BD 04 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames, x
001811  2  85 02            sta r0L
001813  2  BD 05 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_frames + 1, x
001816  2  85 03            sta r0H
001818  2               
001818  2  B1 02            lda (r0), y         ; save new frame duration in the timer
00181A  2  9D 01 A4         sta animated_tiles + ANIMATED_TILES::ANIMATED_TILE::tick, x
00181D  2  C8               iny
00181E  2  B1 02            lda (r0), y
001820  2  85 30            sta $30                 ; X = index of the new tile to store in VERA memory
001822  2               
001822  2                   ; setup the listf of memory offset in vera memory
001822  2  BD 07 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list, x
001825  2  85 02            sta r0L
001827  2  BD 08 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::addr_tiles_list + 1, x
00182A  2  85 03            sta r0H
00182C  2               
00182C  2                   ; push all tiles in vera memory
00182C  2  BD 06 A4         lda animated_tiles + ANIMATED_TILES::ANIMATED_TILE::nb_tiles, x
00182F  2  0A               asl         ; number of tiles in the list * 2 (these are addr)
001830  2  3A               dec         ; start at the end
001831  2  A8               tay
001832  2               
001832  2  A6 30            ldx $30
001834  2               
001834  2               @next_tile_index:
001834  2                   ; set the vera memory (as we start from the end of the list, vera gigh is first)
001834  2               
001834  2  A9 00        	lda #0
001836  2  8D 25 9F     	sta veractl
001839  2  A9 02          	lda #(^VRAM_layer1_map + 2)
00183B  2  8D 22 9F     	sta verahi
00183E  2  B1 02            lda (r0), y
001840  2  8D 21 9F     	sta veramid	                ; vera = $1fc00 + sprite index (X) * 8
001843  2  88               dey
001844  2  B1 02            lda (r0), y
001846  2  8D 20 9F     	sta veralo
001849  2  88               dey
00184A  2  8E 23 9F         stx veradat
00184D  2               
00184D  2  10 E5            bpl @next_tile_index
00184F  2               
00184F  2  7A               ply
001850  2  FA               plx
001851  2  60               rts
001852  2               .endscope
001852  2               
001852  1               
001852  1               ;-----------------------------------------------------------------------------
001852  1               ;/////////////////////////////////////////////////////////////////////////////
001852  1               ; main code
001852  1               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
001852  1               ;-----------------------------------------------------------------------------
001852  1               
001852  1  00 00        objects: .word 0
001854  1               
001854  1               start:
001854  1               	; 320x240
001854  1  A9 40        	lda #64
001856  1  8D 2A 9F     	sta veradchscale
001859  1  8D 2B 9F     	sta veradcvscale
00185C  1               
00185C  1               	; activate layer0
00185C  1  A9 71        	lda #%01110001
00185E  1               ;	and #(255-VERA_LAYER0)
00185E  1               ;	ora #(VERA_LAYER1)             ; Read Video Register
00185E  1  8D 29 9F     	sta veradcvideo             ; Store new value to Video Register
001861  1               
001861  1               	;---------------------------------
001861  1               	; load tiles file into vram
001861  1               	;---------------------------------
001861  1  A9 01 A2 08  	VLOAD_FILE fstile, (fstileend-fstile), VRAM_tiles
001865  1  A0 00 20 BA  
001869  1  FF A9 09 A2  
001882  1               
001882  1               	;---------------------------------
001882  1               	; load tilemaps into vram
001882  1               	;---------------------------------
001882  1               setlayer0:
001882  1  AD 2D 9F 29  	VCONFIG_TILES 0,VERA_CONFIG_32x32
001886  1  0F 09 00 8D  
00188A  1  2D 9F        
00188C  1  AD 2D 9F 29  	VCONFIG_DEPTH 0,VERA_CONFIG_8BPP
001890  1  0F 09 03 8D  
001894  1  2D 9F        
001896  1  A9 00 8D 2E  	VMAPBASE 0, VRAM_layer0_map
00189A  1  9F           
00189B  1  AD 2F 9F 29  	VTILEBASE 0, VRAM_tiles
00189F  1  03 09 08 8D  
0018A3  1  2F 9F        
0018A5  1  AD 2F 9F 29  	VTILEMODE 0,VERA_TILE_16x16
0018A9  1  FC 09 03 8D  
0018AD  1  2F 9F        
0018AF  1  A9 01 A2 08  	VLOAD_FILE fsbackground, (fsbackground_end-fsbackground), VRAM_layer0_map
0018B3  1  A0 00 20 BA  
0018B7  1  FF A9 0B A2  
0018D0  1               
0018D0  1               setlayer1:
0018D0  1  AD 34 9F 29  	VCONFIG_TILES 1,VERA_CONFIG_32x32
0018D4  1  0F 09 00 8D  
0018D8  1  34 9F        
0018DA  1  AD 34 9F 29  	VCONFIG_DEPTH 1,VERA_CONFIG_8BPP
0018DE  1  0F 09 03 8D  
0018E2  1  34 9F        
0018E4  1  A9 04 8D 35  	VMAPBASE 1, VRAM_layer1_map
0018E8  1  9F           
0018E9  1  AD 36 9F 29  	VTILEBASE 1, VRAM_tiles
0018ED  1  03 09 08 8D  
0018F1  1  36 9F        
0018F3  1  AD 36 9F 29  	VTILEMODE 1,VERA_TILE_16x16
0018F7  1  FC 09 03 8D  
0018FB  1  36 9F        
0018FD  1  A9 01 A2 08  	VLOAD_FILE fslevel, (fslevel_end-fslevel), VRAM_layer1_map
001901  1  A0 00 20 BA  
001905  1  FF A9 09 A2  
00191E  1               
00191E  1               	;---------------------------------
00191E  1               	; load collisionmap into ram
00191E  1               	;---------------------------------
00191E  1  A9 00        	lda #0
001920  1  85 00        	sta $00
001922  1  A9 01 A2 08  	LOAD_FILE fscollision, (fscollision_end-fscollision), HIMEM
001926  1  A0 00 20 BA  
00192A  1  FF A9 0D A2  
001943  1               
001943  1               	;---------------------------------
001943  1               	; load animated tiles into ram
001943  1               	;---------------------------------
001943  1  20 3A 17     	jsr Tiles::load
001946  1               
001946  1               	;---------------------------------
001946  1               	; load sprite 0,1,2 into vram
001946  1               	;---------------------------------
001946  1               load_sprites:
001946  1               	; prepare VERA sprites
001946  1  20 BC 0A     	jsr Sprite::init_addr_table
001949  1               
001949  1  A9 00 85 02  	LOAD_r0 (VRAM_tiles + tiles * tile_size)	; base for the sprites
00194D  1  A9 41 85 03  
001951  1  20 D1 0E     	jsr Player::init
001954  1               
001954  1               	;---------------------------------
001954  1               	; load objects list into ram
001954  1               	;---------------------------------
001954  1  20 11 0D     	jsr Objects::init
001957  1               
001957  1               setirq:
001957  1                  ; backup default RAM IRQ vector
001957  1  AD 14 03        lda IRQVec
00195A  1  8D 45 1A        sta default_irq_vector
00195D  1  AD 15 03        lda IRQVec+1
001960  1  8D 46 1A        sta default_irq_vector+1
001963  1               
001963  1                  ; overwrite RAM IRQ vector with custom handler address
001963  1  78              sei ; disable IRQ while vector is changing
001964  1  A9 7B           lda #<custom_irq_handler
001966  1  8D 14 03        sta IRQVec
001969  1  A9 19           lda #>custom_irq_handler
00196B  1  8D 15 03        sta IRQVec+1
00196E  1  AD 26 9F        lda veraien
001971  1  09 01           ora #VERA_VSYNC_BIT ; make VERA only generate VSYNC IRQs
001973  1  8D 26 9F        sta veraien
001976  1  58              cli ; enable IRQ now that vector is properly set
001977  1               
001977  1               mainloop:
001977  1  CB           	wai
001978  1               	; do nothing in main loop, just let ISR do everything
001978  1  80 FD        	bra mainloop
00197A  1               
00197A  1  60           	rts
00197B  1               
00197B  1               ;-----------------------------------------------------------------------------
00197B  1               ;/////////////////////////////////////////////////////////////////////////////
00197B  1               ; deal with IRQ"s
00197B  1               ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
00197B  1               ;-----------------------------------------------------------------------------
00197B  1               custom_irq_handler:
00197B  1  AD 27 9F     	lda veraisr
00197E  1  AA           	tax
00197F  1  29 04        	and #VERA_SPRCOL_BIT
001981  1  F0 0B        	beq @check_vsync
001983  1               
001983  1               @sprite_collision:
001983  1  8D 27 9F     	sta veraisr						; acknowled the SPRCOL IRQ
001986  1  8A           	txa
001987  1  4A           	lsr
001988  1  4A           	lsr
001989  1  4A           	lsr
00198A  1  4A           	lsr								; extract the collision mask (4:7)
00198B  1  20 7A 0C     	jsr Sprite::register_collision
00198E  1               
00198E  1               @check_vsync:
00198E  1  8A           	txa
00198F  1  29 01        	and #VERA_VSYNC_BIT
001991  1  F0 36        	beq @continue
001993  1               
001993  1               @frame_update:
001993  1  8D 27 9F     	sta veraisr						; acknowled the VSYNC IRQ
001996  1               
001996  1               	;---------------------------------
001996  1               	; animate sprite
001996  1               	;---------------------------------
001996  1  20 44 11     	jsr Player::animate
001999  1               
001999  1               	;---------------------------------
001999  1               	; swap animated tiles
001999  1               	;---------------------------------
001999  1  20 E4 17     	jsr Tiles::animate
00199C  1               
00199C  1               	;---------------------------------
00199C  1               	; sprite collisions management
00199C  1               	;---------------------------------
00199C  1  20 01 0D     	jsr Sprite::check_collision
00199F  1               
00199F  1               	;---------------------------------
00199F  1               	; player physics
00199F  1               	;---------------------------------
00199F  1  20 E8 11     	jsr Player::physics
0019A2  1               
0019A2  1               	;---------------------------------
0019A2  1               	; check keyboard
0019A2  1               	;---------------------------------
0019A2  1               @check_keyboard:
0019A2  1  A9 00        	lda #0
0019A4  1  20 56 FF     	jsr joystick_get
0019A7  1  8D 4E 1A     	sta joystick
0019AA  1               
0019AA  1               ;  .A, byte 0:      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
0019AA  1               ;              NES  | A | B |SEL|STA|UP |DN |LT |RT |
0019AA  1               ;              SNES | B | Y |SEL|STA|UP |DN |LT |RT |
0019AA  1               ;
0019AA  1               ;  .X, byte 1:      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
0019AA  1               ;              NES  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | X |
0019AA  1               ;              SNES | A | X | L | R | 1 | 1 | 1 | 1 |
0019AA  1               ;  .Y, byte 2:
0019AA  1               ;              $00 = joystick present
0019AA  1               ;              $FF = joystick not present
0019AA  1  89 81        	bit #(JOY_RIGHT|JOY_B)
0019AC  1  F0 1E        	beq @jump_right
0019AE  1  89 82        	bit #(JOY_LEFT|JOY_B)
0019B0  1  F0 21        	beq @jump_left
0019B2  1  89 01        	bit #JOY_RIGHT
0019B4  1  F0 29        	beq @joystick_right
0019B6  1  89 02        	bit #JOY_LEFT
0019B8  1  F0 20        	beq @joystick_left
0019BA  1  89 04        	bit #JOY_DOWN
0019BC  1  F0 2B        	beq @movedown
0019BE  1  89 08        	bit #JOY_UP
0019C0  1  F0 22        	beq @moveup
0019C2  1  89 80        	bit #JOY_B
0019C4  1  F0 28        	beq @jump
0019C6  1               
0019C6  1  20 CF 11     	jsr Player::set_idle
0019C9  1               
0019C9  1               @continue:
0019C9  1                  ; continue to default IRQ handler
0019C9  1  6C 45 1A        jmp (default_irq_vector)
0019CC  1                  ; RTI will happen after jump
0019CC  1               
0019CC  1               @jump_right:
0019CC  1  A9 01        	lda #$01					; jump right
0019CE  1  20 0D 17     	jsr Player::jump
0019D1  1  80 F6        	bra @continue
0019D3  1               
0019D3  1               @jump_left:
0019D3  1  A9 FF        	lda #$ff					; jump left
0019D5  1  20 0D 17     	jsr Player::jump
0019D8  1  80 EF        	bra @continue
0019DA  1               
0019DA  1               @joystick_left:
0019DA  1  20 32 15     	jsr Player::move_left
0019DD  1  80 EA        	bra @continue
0019DF  1               
0019DF  1               @joystick_right:
0019DF  1  20 62 14     	jsr Player::move_right
0019E2  1  80 E5        	bra @continue
0019E4  1               
0019E4  1               @moveup:
0019E4  1  20 86 16     	jsr Player::move_up
0019E7  1  80 E0        	bra @continue
0019E9  1               
0019E9  1               @movedown:
0019E9  1  20 FE 15     	jsr Player::move_down
0019EC  1  80 DB        	bra @continue
0019EE  1               
0019EE  1               @jump:
0019EE  1  A9 00        	lda #0				; jump up
0019F0  1  20 0D 17     	jsr Player::jump
0019F3  1  80 D4        	bra @continue
0019F5  1               
0019F5  1               .segment "DATA"
0019F5  1               .include "tilemap.inc"
0019F5  2               map:
0019F5  2  20 20        	.byte 32,32
0019F7  2  6C 65 76 65  fslevel: .literal "level.bin"
0019FB  2  6C 2E 62 69  
0019FF  2  6E           
001A00  2               fslevel_end:
001A00  2  73 63 65 6E  fsbackground: .literal "scenery.bin"
001A04  2  65 72 79 2E  
001A08  2  62 69 6E     
001A0B  2               fsbackground_end:
001A0B  2  63 6F 6C 6C  fscollision: .literal "collision.bin"
001A0F  2  69 73 69 6F  
001A13  2  6E 2E 62 69  
001A18  2               fscollision_end:
001A18  2  6F 62 6A 65  fsobjects: .literal "objects.bin"
001A1C  2  63 74 73 2E  
001A20  2  62 69 6E     
001A23  2               fsobjects_end:
001A23  2  73 70 72 69  fssprites1: .literal "sprites1.bin"
001A27  2  74 65 73 31  
001A2B  2  2E 62 69 6E  
001A2F  2               fssprites1_end:
001A2F  2               tileset:
001A2F  2  10 10        	.byte 16,16
001A31  2               tiles = 49
001A31  2               tile_size = 256
001A31  2  74 69 6C 65  fstile: .literal "tiles.bin"
001A35  2  73 2E 62 69  
001A39  2  6E           
001A3A  2               fstileend:
001A3A  2               
001A3A  1               .include "sprite.inc"
001A3A  2  73 70 72 69  fssprite:	.literal "sprites.bin"
001A3E  2  74 65 73 2E  
001A42  2  62 69 6E     
001A45  2               fsspriteend:
001A45  2               sprites = 12
001A45  2               sprite_size = 1024
001A45  2               
001A45  1               
001A45  1  00 00        default_irq_vector: .addr 0
001A47  1  00           trigger_debug: .byte 0
001A48  1               tiles_attributes:
001A48  1  00           	.byte %00000000	;	TILE_NO_COLLISION
001A49  1  07           	.byte %00000111	;	TILE_SOLID_GROUND
001A4A  1  04           	.byte %00000100	;	TILE_SOLD_SLOP_LEFT
001A4B  1  04           	.byte %00000100	;	TILE_SOLD_SLOP_RIGHT
001A4C  1  09           	.byte %00001001	;	TILE_SOLID_LADER
001A4D  1  09           	.byte %00001001	;	TILE_LEDGE
001A4E  1               
001A4E  1               .segment "BSS"
001A4E  1  xx           	joystick: .res 1
001A4F  1  xx xx xx xx  	sprites_table: .res 256		; VERA memory of each of the 256 sprites
001A53  1  xx xx xx xx  
001A57  1  xx xx xx xx  
001B4F  1  xx xx xx xx  	player0: .tag PLAYER
001B53  1  xx xx xx xx  
001B57  1  xx xx xx xx  
001B4F  1               
